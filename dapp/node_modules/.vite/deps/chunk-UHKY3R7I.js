"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  require_argSerializer,
  require_codeMetadata,
  require_codec,
  require_logger,
  require_resultsParser,
  require_returnCode,
  require_typesystem
} from "./chunk-C426NY4X.js";
import {
  require_utils as require_utils2
} from "./chunk-PA4YGARE.js";
import {
  require_function
} from "./chunk-FOX6T53T.js";
import {
  require_signature
} from "./chunk-KLHSS55O.js";
import {
  require_address,
  require_bignumber,
  require_config,
  require_constants,
  require_js,
  require_utils,
  require_utils_codec
} from "./chunk-JDLAKVPX.js";
import {
  require_errors
} from "./chunk-7T325JRE.js";
import {
  __commonJS,
  __require,
  __toESM,
  require_buffer_polyfill,
  require_dist
} from "./chunk-UOCZJ3B4.js";

// node_modules/@multiversx/sdk-core/out/compatibility.js
var require_compatibility = __commonJS({
  "node_modules/@multiversx/sdk-core/out/compatibility.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Compatibility = void 0;
    var address_1 = require_address();
    var Compatibility = class {
      /**
       * For internal use only.
       */
      static guardAddressIsSetAndNonZero(address, context, resolution) {
        if (!address || address.bech32() == "") {
          console.warn(`${context}: address should be set; ${resolution}. In the future, this will throw an exception instead of emitting a WARN.`);
        } else if (address.bech32() == address_1.Address.Zero().bech32()) {
          console.warn(`${context}: address should not be the 'zero' address (also known as the 'contracts deployment address'); ${resolution}. In the future, this will throw an exception instead of emitting a WARN.`);
        }
      }
    };
    exports2.Compatibility = Compatibility;
  }
});

// node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "node_modules/nanoassert/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    assert.notEqual = notEqual;
    assert.notOk = notOk;
    assert.equal = equal;
    assert.ok = assert;
    module2.exports = assert;
    function equal(a, b, m) {
      assert(a == b, m);
    }
    function notEqual(a, b, m) {
      assert(a != b, m);
    }
    function notOk(t, m) {
      assert(!t, m);
    }
    function assert(t, m) {
      if (!t) throw new Error(m || "AssertionError");
    }
  }
});

// node_modules/blake2b-wasm/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/blake2b-wasm/blake2b.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = loadWebAssembly;
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly(opts) {
      if (!loadWebAssembly.supported) return null;
      var imp = opts && opts.imports;
      var wasm = toUint8Array("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL");
      var ready = null;
      var mod2 = {
        buffer: wasm,
        memory: null,
        exports: null,
        realloc,
        onload
      };
      onload(function() {
      });
      return mod2;
      function realloc(size) {
        mod2.exports.memory.grow(Math.ceil(Math.abs(size - mod2.memory.length) / 65536));
        mod2.memory = new Uint8Array(mod2.exports.memory.buffer);
      }
      function onload(cb) {
        if (mod2.exports) return cb();
        if (ready) {
          ready.then(cb.bind(null, null)).catch(cb);
          return;
        }
        try {
          if (opts && opts.async) throw new Error("async");
          setup({ instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp) });
        } catch (err) {
          ready = WebAssembly.instantiate(wasm, imp).then(setup);
        }
        onload(cb);
      }
      function setup(w) {
        mod2.exports = w.instance.exports;
        mod2.memory = mod2.exports.memory && mod2.exports.memory.buffer && new Uint8Array(mod2.exports.memory.buffer);
      }
    }
    function toUint8Array(s) {
      if (typeof atob === "function") return new Uint8Array(atob(s).split("").map(charCodeAt));
      return new (require_buffer_polyfill()).Buffer(s, "base64");
    }
    function charCodeAt(c) {
      return c.charCodeAt(0);
    }
  }
});

// node_modules/blake2b-wasm/index.js
var require_blake2b_wasm = __commonJS({
  "node_modules/blake2b-wasm/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var assert = require_nanoassert();
    var wasm = require_blake2b()();
    var head = 64;
    var freeList = [];
    module2.exports = Blake2b;
    var BYTES_MIN = module2.exports.BYTES_MIN = 16;
    var BYTES_MAX = module2.exports.BYTES_MAX = 64;
    var BYTES = module2.exports.BYTES = 32;
    var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
    var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
    var KEYBYTES = module2.exports.KEYBYTES = 32;
    var SALTBYTES = module2.exports.SALTBYTES = 16;
    var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
    function Blake2b(digestLength, key, salt, personal, noAssert) {
      if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);
      if (!(wasm && wasm.exports)) throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
      if (!digestLength) digestLength = 32;
      if (noAssert !== true) {
        assert(digestLength >= BYTES_MIN, "digestLength must be at least " + BYTES_MIN + ", was given " + digestLength);
        assert(digestLength <= BYTES_MAX, "digestLength must be at most " + BYTES_MAX + ", was given " + digestLength);
        if (key != null) assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
        if (key != null) assert(key.length <= KEYBYTES_MAX, "key must be at least " + KEYBYTES_MAX + ", was given " + key.length);
        if (salt != null) assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
        if (personal != null) assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
      }
      if (!freeList.length) {
        freeList.push(head);
        head += 216;
      }
      this.digestLength = digestLength;
      this.finalized = false;
      this.pointer = freeList.pop();
      wasm.memory.fill(0, 0, 64);
      wasm.memory[0] = this.digestLength;
      wasm.memory[1] = key ? key.length : 0;
      wasm.memory[2] = 1;
      wasm.memory[3] = 1;
      if (salt) wasm.memory.set(salt, 32);
      if (personal) wasm.memory.set(personal, 48);
      if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216);
      wasm.exports.blake2b_init(this.pointer, this.digestLength);
      if (key) {
        this.update(key);
        wasm.memory.fill(0, head, head + key.length);
        wasm.memory[this.pointer + 200] = 128;
      }
    }
    Blake2b.prototype.update = function(input) {
      assert(this.finalized === false, "Hash instance finalized");
      assert(input, "input must be TypedArray or Buffer");
      if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);
      wasm.memory.set(input, head);
      wasm.exports.blake2b_update(this.pointer, head, head + input.length);
      return this;
    };
    Blake2b.prototype.digest = function(enc) {
      assert(this.finalized === false, "Hash instance finalized");
      this.finalized = true;
      freeList.push(this.pointer);
      wasm.exports.blake2b_final(this.pointer);
      if (!enc || enc === "binary") {
        return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      if (enc === "hex") {
        return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);
      }
      assert(enc.length >= this.digestLength, "input must be TypedArray or Buffer");
      for (var i = 0; i < this.digestLength; i++) {
        enc[i] = wasm.memory[this.pointer + 128 + i];
      }
      return enc;
    };
    Blake2b.prototype.final = Blake2b.prototype.digest;
    Blake2b.WASM = wasm && wasm.buffer;
    Blake2b.SUPPORTED = typeof WebAssembly !== "undefined";
    Blake2b.ready = function(cb) {
      if (!cb) cb = noop;
      if (!wasm) return cb(new Error("WebAssembly not supported"));
      var p = new Promise(function(reject, resolve) {
        wasm.onload(function(err) {
          if (err) resolve();
          else reject();
          cb(err);
        });
      });
      return p;
    };
    Blake2b.prototype.ready = Blake2b.ready;
    function noop() {
    }
    function hexSlice(buf, start, len) {
      var str = "";
      for (var i = 0; i < len; i++) str += toHex(buf[start + i]);
      return str;
    }
    function toHex(n) {
      if (n < 16) return "0" + n.toString(16);
      return n.toString(16);
    }
  }
});

// node_modules/blake2b/index.js
var require_blake2b2 = __commonJS({
  "node_modules/blake2b/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var assert = require_nanoassert();
    var b2wasm = require_blake2b_wasm();
    function ADD64AA(v2, a, b) {
      var o0 = v2[a] + v2[b];
      var o1 = v2[a + 1] + v2[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function ADD64AC(v2, a, b0, b1) {
      var o0 = v2[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      var o1 = v2[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function B2B_GET32(arr, i) {
      return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
    }
    function B2B_G(a, b, c, d, ix, iy) {
      var x0 = m[ix];
      var x1 = m[ix + 1];
      var y0 = m[iy];
      var y1 = m[iy + 1];
      ADD64AA(v, a, b);
      ADD64AC(v, a, x0, x1);
      var xor0 = v[d] ^ v[a];
      var xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor1;
      v[d + 1] = xor0;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor0 >>> 24 ^ xor1 << 8;
      v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v, a, b);
      ADD64AC(v, a, y0, y1);
      xor0 = v[d] ^ v[a];
      xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor0 >>> 16 ^ xor1 << 16;
      v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor1 >>> 31 ^ xor0 << 1;
      v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(SIGMA8.map(function(x) {
      return x * 2;
    }));
    var v = new Uint32Array(32);
    var m = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      var i = 0;
      for (i = 0; i < 16; i++) {
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
      }
      v[24] = v[24] ^ ctx.t;
      v[25] = v[25] ^ ctx.t / 4294967296;
      if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
      }
      for (i = 0; i < 32; i++) {
        m[i] = B2B_GET32(ctx.b, 4 * i);
      }
      for (i = 0; i < 12; i++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
      }
      for (i = 0; i < 16; i++) {
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
      }
    }
    var parameter_block = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function Blake2b(outlen, key, salt, personal) {
      parameter_block.fill(0);
      this.b = new Uint8Array(128);
      this.h = new Uint32Array(16);
      this.t = 0;
      this.c = 0;
      this.outlen = outlen;
      parameter_block[0] = outlen;
      if (key) parameter_block[1] = key.length;
      parameter_block[2] = 1;
      parameter_block[3] = 1;
      if (salt) parameter_block.set(salt, 32);
      if (personal) parameter_block.set(personal, 48);
      for (var i = 0; i < 16; i++) {
        this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
      }
      if (key) {
        blake2bUpdate(this, key);
        this.c = 128;
      }
    }
    Blake2b.prototype.update = function(input) {
      assert(input != null, "input must be Uint8Array or Buffer");
      blake2bUpdate(this, input);
      return this;
    };
    Blake2b.prototype.digest = function(out) {
      var buf = !out || out === "binary" || out === "hex" ? new Uint8Array(this.outlen) : out;
      assert(buf.length >= this.outlen, "out must have at least outlen bytes of space");
      blake2bFinal(this, buf);
      if (out === "hex") return hexSlice(buf);
      return buf;
    };
    Blake2b.prototype.final = Blake2b.prototype.digest;
    Blake2b.ready = function(cb) {
      b2wasm.ready(function() {
        cb();
      });
    };
    function blake2bUpdate(ctx, input) {
      for (var i = 0; i < input.length; i++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i];
      }
    }
    function blake2bFinal(ctx, out) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      for (var i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
      }
      return out;
    }
    function hexSlice(buf) {
      var str = "";
      for (var i = 0; i < buf.length; i++) str += toHex(buf[i]);
      return str;
    }
    function toHex(n) {
      if (n < 16) return "0" + n.toString(16);
      return n.toString(16);
    }
    var Proto = Blake2b;
    module2.exports = function createHash(outlen, key, salt, personal, noAssert) {
      if (noAssert !== true) {
        assert(outlen >= BYTES_MIN, "outlen must be at least " + BYTES_MIN + ", was given " + outlen);
        assert(outlen <= BYTES_MAX, "outlen must be at most " + BYTES_MAX + ", was given " + outlen);
        if (key != null) assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
        if (key != null) assert(key.length <= KEYBYTES_MAX, "key must be at most " + KEYBYTES_MAX + ", was given " + key.length);
        if (salt != null) assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
        if (personal != null) assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
      }
      return new Proto(outlen, key, salt, personal);
    };
    module2.exports.ready = function(cb) {
      b2wasm.ready(function() {
        cb();
      });
    };
    module2.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
    module2.exports.WASM_LOADED = false;
    var BYTES_MIN = module2.exports.BYTES_MIN = 16;
    var BYTES_MAX = module2.exports.BYTES_MAX = 64;
    var BYTES = module2.exports.BYTES = 32;
    var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
    var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
    var KEYBYTES = module2.exports.KEYBYTES = 32;
    var SALTBYTES = module2.exports.SALTBYTES = 16;
    var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
    b2wasm.ready(function(err) {
      if (!err) {
        module2.exports.WASM_LOADED = true;
        Proto = b2wasm;
      }
    });
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/code.js
var require_code = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/code.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Code = void 0;
    var createHasher = require_blake2b2();
    var CODE_HASH_LENGTH = 32;
    var Code = class _Code {
      constructor(hex) {
        this.hex = hex;
      }
      /**
       * Creates a Code object from a buffer (sequence of bytes).
       */
      static fromBuffer(code) {
        return new _Code(code.toString("hex"));
      }
      /**
       * Creates a Code object from a hex-encoded string.
       */
      static fromHex(hex) {
        return new _Code(hex);
      }
      /**
       * Returns the bytecode as a hex-encoded string.
       */
      toString() {
        return this.hex;
      }
      valueOf() {
        return Buffer.from(this.hex, "hex");
      }
      computeHash() {
        const hash = createHasher(CODE_HASH_LENGTH).update(this.valueOf()).digest();
        return Buffer.from(hash);
      }
    };
    exports2.Code = Code;
  }
});

// node_modules/@multiversx/sdk-core/out/tokens.js
var require_tokens = __commonJS({
  "node_modules/@multiversx/sdk-core/out/tokens.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenPayment = exports2.TokenComputer = exports2.TokenTransfer = exports2.Token = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var EGLDTokenIdentifier = "EGLD";
    var EGLDNumDecimals = 18;
    bignumber_js_1.default.set({ ROUNDING_MODE: 1 });
    var Token = class {
      constructor(options) {
        this.identifier = options.identifier;
        this.nonce = options.nonce || 0n;
      }
    };
    exports2.Token = Token;
    var TokenTransfer = class _TokenTransfer {
      constructor(options) {
        if (this.isLegacyTokenTransferOptions(options)) {
          const amount = new bignumber_js_1.default(options.amountAsBigInteger);
          if (!amount.isInteger() || amount.isNegative()) {
            throw new errors_1.ErrInvalidArgument(`bad amountAsBigInteger: ${options.amountAsBigInteger}`);
          }
          this.tokenIdentifier = options.tokenIdentifier;
          this.nonce = options.nonce;
          this.amountAsBigInteger = amount;
          this.numDecimals = options.numDecimals || 0;
          this.token = new Token({
            identifier: options.tokenIdentifier,
            nonce: BigInt(options.nonce)
          });
          this.amount = BigInt(this.amountAsBigInteger.toFixed(0));
        } else {
          this.token = options.token;
          this.amount = options.amount;
          this.tokenIdentifier = options.token.identifier;
          this.nonce = Number(options.token.nonce);
          this.amountAsBigInteger = new bignumber_js_1.default(this.amount.toString());
          this.numDecimals = 0;
        }
      }
      static newFromEgldAmount(amount) {
        const token = new Token({ identifier: constants_1.EGLD_IDENTIFIER_FOR_MULTI_ESDTNFT_TRANSFER });
        return new _TokenTransfer({ token, amount });
      }
      isLegacyTokenTransferOptions(options) {
        return options.tokenIdentifier !== void 0;
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static egldFromAmount(amount) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(EGLDNumDecimals).decimalPlaces(0);
        return this.egldFromBigInteger(amountAsBigInteger);
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static egldFromBigInteger(amountAsBigInteger) {
        return new _TokenTransfer({
          tokenIdentifier: EGLDTokenIdentifier,
          nonce: 0,
          amountAsBigInteger,
          numDecimals: EGLDNumDecimals
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static fungibleFromAmount(tokenIdentifier, amount, numDecimals) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(numDecimals).decimalPlaces(0);
        return this.fungibleFromBigInteger(tokenIdentifier, amountAsBigInteger, numDecimals);
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static fungibleFromBigInteger(tokenIdentifier, amountAsBigInteger, numDecimals = 0) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce: 0,
          amountAsBigInteger,
          numDecimals
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static nonFungible(tokenIdentifier, nonce) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce,
          amountAsBigInteger: 1,
          numDecimals: 0
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static semiFungible(tokenIdentifier, nonce, quantity) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce,
          amountAsBigInteger: quantity,
          numDecimals: 0
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static metaEsdtFromAmount(tokenIdentifier, nonce, amount, numDecimals) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(numDecimals).decimalPlaces(0);
        return this.metaEsdtFromBigInteger(tokenIdentifier, nonce, amountAsBigInteger, numDecimals);
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static metaEsdtFromBigInteger(tokenIdentifier, nonce, amountAsBigInteger, numDecimals = 0) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce,
          amountAsBigInteger,
          numDecimals
        });
      }
      toString() {
        return this.amount.toString();
      }
      /**
       * Legacy function. Use the "amount" field instead.
       */
      valueOf() {
        return new bignumber_js_1.default(this.amount.toString());
      }
      /**
       * Legacy function. For formatting and parsing amounts, use "sdk-dapp" or "bignumber.js" directly.
       */
      toPrettyString() {
        return `${this.toAmount()} ${this.tokenIdentifier}`;
      }
      toAmount() {
        return this.amountAsBigInteger.shiftedBy(-this.numDecimals).toFixed(this.numDecimals);
      }
      /**
       * Legacy function. Within your code, don't mix native values (EGLD) and custom (ESDT) tokens.
       * See "TransferTransactionsFactory.createTransactionForNativeTokenTransfer()" vs. "TransferTransactionsFactory.createTransactionForESDTTokenTransfer()".
       */
      isEgld() {
        return this.token.identifier == EGLDTokenIdentifier;
      }
      /**
       * Legacy function. Use "TokenComputer.isFungible(token)" instead.
       */
      isFungible() {
        return this.token.nonce == 0n;
      }
    };
    exports2.TokenTransfer = TokenTransfer;
    var TokenComputer = class {
      constructor() {
        this.TOKEN_RANDOM_SEQUENCE_LENGTH = 6;
      }
      isFungible(token) {
        return token.nonce === 0n;
      }
      extractNonceFromExtendedIdentifier(identifier) {
        const parts = identifier.split("-");
        const { prefix, ticker, randomSequence } = this.splitIdentifierIntoComponents(parts);
        this.validateExtendedIdentifier(prefix, ticker, randomSequence, parts);
        if (parts.length === 2 || prefix && parts.length === 3) {
          return 0;
        }
        const hexNonce = parts[parts.length - 1];
        return decodeUnsignedNumber(Buffer.from(hexNonce, "hex"));
      }
      extractIdentifierFromExtendedIdentifier(identifier) {
        const parts = identifier.split("-");
        const { prefix, ticker, randomSequence } = this.splitIdentifierIntoComponents(parts);
        this.validateExtendedIdentifier(prefix, ticker, randomSequence, parts);
        if (prefix) {
          this.checkLengthOfPrefix(prefix);
          return prefix + "-" + ticker + "-" + randomSequence;
        }
        return ticker + "-" + randomSequence;
      }
      validateExtendedIdentifier(prefix, ticker, randomSequence, parts) {
        this.checkIfExtendedIdentifierWasProvided(prefix, parts);
        this.ensureTokenTickerValidity(ticker);
        this.checkLengthOfRandomSequence(randomSequence);
      }
      splitIdentifierIntoComponents(parts) {
        if (this.isLowercaseAlphanumeric(parts[0])) {
          return { prefix: parts[0], ticker: parts[1], randomSequence: parts[2] };
        }
        return { prefix: null, ticker: parts[0], randomSequence: parts[1] };
      }
      checkIfExtendedIdentifierWasProvided(prefix, tokenParts) {
        const MIN_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED = 2;
        const MAX_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED = prefix ? 4 : 3;
        if (tokenParts.length < MIN_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED || tokenParts.length > MAX_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED) {
          throw new errors_1.ErrInvalidTokenIdentifier("Invalid extended token identifier provided");
        }
      }
      isLowercaseAlphanumeric(str) {
        return /^[a-z0-9]+$/.test(str);
      }
      checkLengthOfRandomSequence(randomSequence) {
        if (randomSequence.length !== this.TOKEN_RANDOM_SEQUENCE_LENGTH) {
          throw new errors_1.ErrInvalidTokenIdentifier("The identifier is not valid. The random sequence does not have the right length");
        }
      }
      checkLengthOfPrefix(prefix) {
        const MAX_TOKEN_PREFIX_LENGTH = 4;
        const MIN_TOKEN_PREFIX_LENGTH = 1;
        if (prefix.length < MIN_TOKEN_PREFIX_LENGTH || prefix.length > MAX_TOKEN_PREFIX_LENGTH) {
          throw new errors_1.ErrInvalidTokenIdentifier("The identifier is not valid. The prefix does not have the right length");
        }
      }
      ensureTokenTickerValidity(ticker) {
        const MIN_TICKER_LENGTH = 3;
        const MAX_TICKER_LENGTH = 10;
        if (ticker.length < MIN_TICKER_LENGTH || ticker.length > MAX_TICKER_LENGTH) {
          throw new errors_1.ErrInvalidTokenIdentifier(`The token ticker should be between ${MIN_TICKER_LENGTH} and ${MAX_TICKER_LENGTH} characters`);
        }
        if (!ticker.match(/^[a-zA-Z0-9]+$/)) {
          throw new errors_1.ErrInvalidTokenIdentifier("The token ticker should only contain alphanumeric characters");
        }
        if (!(ticker == ticker.toUpperCase())) {
          throw new errors_1.ErrInvalidTokenIdentifier("The token ticker should be upper case");
        }
      }
    };
    exports2.TokenComputer = TokenComputer;
    function decodeUnsignedNumber(arg) {
      return arg.readUIntBE(0, arg.length);
    }
    var TokenPayment = class extends TokenTransfer {
      constructor(tokenIdentifier, nonce, amountAsBigInteger, numDecimals) {
        super({
          tokenIdentifier,
          nonce,
          amountAsBigInteger,
          numDecimals
        });
      }
    };
    exports2.TokenPayment = TokenPayment;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/resources.js
var require_resources = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/resources.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.gatherAllEvents = exports2.findEventsByFirstTopic = exports2.findEventsByIdentifier = exports2.findEventsByPredicate = exports2.SmartContractCallOutcome = exports2.TransactionOutcome = exports2.SmartContractResult = exports2.TransactionLogs = exports2.TransactionEvent = void 0;
    var TransactionEvent = class {
      constructor(init) {
        this.address = "";
        this.identifier = "";
        this.topics = [];
        this.dataItems = [];
        Object.assign(this, init);
      }
    };
    exports2.TransactionEvent = TransactionEvent;
    var TransactionLogs = class {
      constructor(init) {
        this.address = "";
        this.events = [];
        Object.assign(this, init);
      }
    };
    exports2.TransactionLogs = TransactionLogs;
    var SmartContractResult = class {
      constructor(init) {
        this.sender = "";
        this.receiver = "";
        this.data = new Uint8Array();
        this.logs = new TransactionLogs({});
        Object.assign(this, init);
      }
    };
    exports2.SmartContractResult = SmartContractResult;
    var TransactionOutcome = class {
      constructor(init) {
        this.directSmartContractCallOutcome = new SmartContractCallOutcome({});
        this.smartContractResults = [];
        this.logs = new TransactionLogs({});
        Object.assign(this, init);
      }
    };
    exports2.TransactionOutcome = TransactionOutcome;
    var SmartContractCallOutcome = class {
      constructor(init) {
        this.function = "";
        this.returnDataParts = [];
        this.returnMessage = "";
        this.returnCode = "";
        Object.assign(this, init);
      }
    };
    exports2.SmartContractCallOutcome = SmartContractCallOutcome;
    function findEventsByPredicate(transactionOutcome, predicate) {
      return gatherAllEvents(transactionOutcome).filter(predicate);
    }
    exports2.findEventsByPredicate = findEventsByPredicate;
    function findEventsByIdentifier(transactionOutcome, identifier) {
      return findEventsByPredicate(transactionOutcome, (event) => event.identifier == identifier);
    }
    exports2.findEventsByIdentifier = findEventsByIdentifier;
    function findEventsByFirstTopic(transactionOutcome, topic) {
      return findEventsByPredicate(transactionOutcome, (event) => {
        var _a;
        return ((_a = event.topics[0]) == null ? void 0 : _a.toString()) == topic;
      });
    }
    exports2.findEventsByFirstTopic = findEventsByFirstTopic;
    function gatherAllEvents(transactionOutcome) {
      const allEvents = [];
      allEvents.push(...transactionOutcome.logs.events);
      for (const item of transactionOutcome.smartContractResults) {
        allEvents.push(...item.logs.events);
      }
      return allEvents;
    }
    exports2.gatherAllEvents = gatherAllEvents;
  }
});

// node_modules/@multiversx/sdk-core/out/converters/transactionsConverter.js
var require_transactionsConverter = __commonJS({
  "node_modules/@multiversx/sdk-core/out/converters/transactionsConverter.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionsConverter = void 0;
    var address_1 = require_address();
    var smartcontracts_1 = require_smartcontracts();
    var transaction_1 = require_transaction();
    var resources_1 = require_resources();
    var TransactionsConverter = class {
      transactionToPlainObject(transaction) {
        const plainObject = {
          nonce: Number(transaction.nonce),
          value: transaction.value.toString(),
          receiver: transaction.receiver,
          sender: transaction.sender,
          senderUsername: this.toBase64OrUndefined(transaction.senderUsername),
          receiverUsername: this.toBase64OrUndefined(transaction.receiverUsername),
          gasPrice: Number(transaction.gasPrice),
          gasLimit: Number(transaction.gasLimit),
          data: this.toBase64OrUndefined(transaction.data),
          chainID: transaction.chainID.valueOf(),
          version: transaction.version,
          options: transaction.options == 0 ? void 0 : transaction.options,
          relayer: transaction.relayer.isEmpty() ? void 0 : transaction.relayer.toBech32(),
          guardian: transaction.guardian ? transaction.guardian : void 0,
          signature: this.toHexOrUndefined(transaction.signature),
          guardianSignature: this.toHexOrUndefined(transaction.guardianSignature),
          relayerSignature: this.toHexOrUndefined(transaction.relayerSignature)
        };
        return plainObject;
      }
      toBase64OrUndefined(value) {
        return value && value.length ? Buffer.from(value).toString("base64") : void 0;
      }
      toHexOrUndefined(value) {
        return value && value.length ? Buffer.from(value).toString("hex") : void 0;
      }
      plainObjectToTransaction(object) {
        const transaction = new transaction_1.Transaction({
          nonce: BigInt(object.nonce),
          value: BigInt(object.value || ""),
          receiver: object.receiver,
          relayer: object.relayer ? address_1.Address.newFromBech32(object.relayer) : address_1.Address.empty(),
          receiverUsername: this.bufferFromBase64(object.receiverUsername).toString(),
          sender: object.sender,
          senderUsername: this.bufferFromBase64(object.senderUsername).toString(),
          guardian: object.guardian,
          gasPrice: BigInt(object.gasPrice),
          gasLimit: BigInt(object.gasLimit),
          data: this.bufferFromBase64(object.data),
          chainID: String(object.chainID),
          version: Number(object.version),
          options: Number(object.options),
          signature: this.bufferFromHex(object.signature),
          guardianSignature: this.bufferFromHex(object.guardianSignature),
          relayerSignature: this.bufferFromHex(object.relayerSignature)
        });
        return transaction;
      }
      bufferFromBase64(value) {
        return Buffer.from(value || "", "base64");
      }
      bufferFromHex(value) {
        return Buffer.from(value || "", "hex");
      }
      /**
       * @deprecated Where {@link TransactionOutcome} was needed (throughout the SDK), pass the {@link ITransactionOnNetwork} object instead.
       *
       * Summarizes the outcome of a transaction on the network, and maps it to the "standard" resources (according to the sdk-specs).
       *
       * In the future, this converter function will become obsolete,
       * as the impedance mismatch between the network components and the "core" components will be reduced.
       */
      transactionOnNetworkToOutcome(transactionOnNetwork) {
        const legacyResultsParser = new smartcontracts_1.ResultsParser();
        const callOutcomeBundle = legacyResultsParser.parseUntypedOutcome(transactionOnNetwork);
        const callOutcome = new resources_1.SmartContractCallOutcome({
          function: transactionOnNetwork.function,
          returnCode: callOutcomeBundle.returnCode.toString(),
          returnMessage: callOutcomeBundle.returnMessage,
          returnDataParts: callOutcomeBundle.values
        });
        const contractResults = transactionOnNetwork.contractResults.items.map((result) => this.smartContractResultOnNetworkToSmartContractResult(result));
        const logs = new resources_1.TransactionLogs({
          address: transactionOnNetwork.logs.address.bech32(),
          events: transactionOnNetwork.logs.events.map((event) => this.eventOnNetworkToEvent(event))
        });
        return new resources_1.TransactionOutcome({
          logs,
          smartContractResults: contractResults,
          directSmartContractCallOutcome: callOutcome
        });
      }
      smartContractResultOnNetworkToSmartContractResult(resultOnNetwork) {
        return new resources_1.SmartContractResult({
          sender: resultOnNetwork.sender.bech32(),
          receiver: resultOnNetwork.receiver.bech32(),
          data: Buffer.from(resultOnNetwork.data),
          logs: new resources_1.TransactionLogs({
            address: resultOnNetwork.logs.address.bech32(),
            events: resultOnNetwork.logs.events.map((event) => this.eventOnNetworkToEvent(event))
          })
        });
      }
      eventOnNetworkToEvent(eventOnNetwork) {
        var _a, _b;
        const legacyData = ((_a = eventOnNetwork.dataPayload) == null ? void 0 : _a.valueOf()) || Buffer.from(eventOnNetwork.data || "");
        const dataItems = ((_b = eventOnNetwork.additionalData) == null ? void 0 : _b.map((data) => Buffer.from(data.valueOf()))) || [];
        if (dataItems.length === 0) {
          if (legacyData.length) {
            dataItems.push(Buffer.from(legacyData));
          }
        }
        return new resources_1.TransactionEvent({
          address: eventOnNetwork.address.bech32(),
          identifier: eventOnNetwork.identifier,
          topics: eventOnNetwork.topics.map((topic) => Buffer.from(topic.hex(), "hex")),
          dataItems
        });
      }
    };
    exports2.TransactionsConverter = TransactionsConverter;
  }
});

// node_modules/@multiversx/sdk-core/out/hash.js
var require_hash = __commonJS({
  "node_modules/@multiversx/sdk-core/out/hash.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = void 0;
    var errors = __importStar(require_errors());
    var Hash = class _Hash {
      /**
       * Creates a new Hash object.
       *
       * @param hash The hash, as a Buffer or a hex-encoded string.
       */
      constructor(hash) {
        if (!hash) {
          this.hash = Buffer.from([]);
        } else if (hash instanceof Buffer) {
          this.hash = hash;
        } else if (typeof hash === "string") {
          this.hash = Buffer.from(hash, "hex");
        } else {
          throw new errors.ErrBadType("hash", "buffer | string", hash);
        }
      }
      static empty() {
        return new _Hash(Buffer.from([]));
      }
      /**
       * Returns whether the hash is empty (not computed).
       */
      isEmpty() {
        return this.hash.length == 0;
      }
      toString() {
        return this.hex();
      }
      hex() {
        return this.hash.toString("hex");
      }
      valueOf() {
        return this.hash;
      }
    };
    exports2.Hash = Hash;
  }
});

// node_modules/@multiversx/sdk-core/out/networkParams.js
var require_networkParams = __commonJS({
  "node_modules/@multiversx/sdk-core/out/networkParams.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionOptions = exports2.TransactionVersion = void 0;
    var constants_1 = require_constants();
    var errors = __importStar(require_errors());
    var TransactionVersion = class _TransactionVersion {
      /**
       * Creates a TransactionVersion object given a value.
       */
      constructor(value) {
        value = Number(value);
        if (value < 1) {
          throw new errors.ErrTransactionVersionInvalid(value);
        }
        this.value = value;
      }
      /**
       * Creates a TransactionVersion object with the default version setting
       */
      static withDefaultVersion() {
        return new _TransactionVersion(constants_1.TRANSACTION_VERSION_DEFAULT);
      }
      /**
       * Creates a TransactionVersion object with the VERSION setting for enabling options
       */
      static withTxOptions() {
        return new _TransactionVersion(constants_1.TRANSACTION_VERSION_DEFAULT);
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.TransactionVersion = TransactionVersion;
    var TransactionOptions = class _TransactionOptions {
      /**
       * Creates a TransactionOptions from a numeric value.
       */
      constructor(value) {
        value = Number(value);
        if (value < 0) {
          throw new errors.ErrTransactionOptionsInvalid(value);
        }
        this.value = value;
      }
      /**
       * Creates a TransactionOptions object with the default options.
       */
      static withDefaultOptions() {
        return new _TransactionOptions(constants_1.TRANSACTION_OPTIONS_DEFAULT);
      }
      /**
       * Creates a TransactionOptions object from a set of options.
       */
      static withOptions(options) {
        let value = 0;
        if (options.hashSign) {
          value |= constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
        }
        if (options.guarded) {
          value |= constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
        }
        return new _TransactionOptions(value);
      }
      /**
       * Returns true if the "hash sign" option is set.
       */
      isWithHashSign() {
        return (this.value & constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN) == constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      /**
       * Returns true if the "guarded transaction" option is set.
       */
      isWithGuardian() {
        return (this.value & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) == constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
      }
      /**
       * Sets the "hash sign" option.
       */
      setWithHashSign() {
        this.value |= constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      /**
       * Sets the "guarded transaction" option.
       */
      setWithGuardian() {
        this.value |= constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.TransactionOptions = TransactionOptions;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = require_index_minimal();
  }
});

// node_modules/@multiversx/sdk-core/out/proto/compiled.js
var require_compiled = __commonJS({
  "node_modules/@multiversx/sdk-core/out/proto/compiled.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal2());
    })(exports2, function($protobuf) {
      "use strict";
      var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.proto = function() {
        var proto = {};
        proto.Transaction = function() {
          function Transaction(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Transaction.prototype.Nonce = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Transaction.prototype.Value = $util.newBuffer([]);
          Transaction.prototype.RcvAddr = $util.newBuffer([]);
          Transaction.prototype.RcvUserName = $util.newBuffer([]);
          Transaction.prototype.SndAddr = $util.newBuffer([]);
          Transaction.prototype.SndUserName = $util.newBuffer([]);
          Transaction.prototype.GasPrice = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Transaction.prototype.GasLimit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Transaction.prototype.Data = $util.newBuffer([]);
          Transaction.prototype.ChainID = $util.newBuffer([]);
          Transaction.prototype.Version = 0;
          Transaction.prototype.Signature = $util.newBuffer([]);
          Transaction.prototype.Options = 0;
          Transaction.prototype.GuardianAddr = $util.newBuffer([]);
          Transaction.prototype.GuardianSignature = $util.newBuffer([]);
          Transaction.prototype.Relayer = $util.newBuffer([]);
          Transaction.prototype.RelayerSignature = $util.newBuffer([]);
          Transaction.create = function create(properties) {
            return new Transaction(properties);
          };
          Transaction.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.Nonce != null && Object.hasOwnProperty.call(message, "Nonce"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).uint64(message.Nonce);
            if (message.Value != null && Object.hasOwnProperty.call(message, "Value"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).bytes(message.Value);
            if (message.RcvAddr != null && Object.hasOwnProperty.call(message, "RcvAddr"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).bytes(message.RcvAddr);
            if (message.RcvUserName != null && Object.hasOwnProperty.call(message, "RcvUserName"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).bytes(message.RcvUserName);
            if (message.SndAddr != null && Object.hasOwnProperty.call(message, "SndAddr"))
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).bytes(message.SndAddr);
            if (message.SndUserName != null && Object.hasOwnProperty.call(message, "SndUserName"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).bytes(message.SndUserName);
            if (message.GasPrice != null && Object.hasOwnProperty.call(message, "GasPrice"))
              writer.uint32(
                /* id 7, wireType 0 =*/
                56
              ).uint64(message.GasPrice);
            if (message.GasLimit != null && Object.hasOwnProperty.call(message, "GasLimit"))
              writer.uint32(
                /* id 8, wireType 0 =*/
                64
              ).uint64(message.GasLimit);
            if (message.Data != null && Object.hasOwnProperty.call(message, "Data"))
              writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).bytes(message.Data);
            if (message.ChainID != null && Object.hasOwnProperty.call(message, "ChainID"))
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).bytes(message.ChainID);
            if (message.Version != null && Object.hasOwnProperty.call(message, "Version"))
              writer.uint32(
                /* id 11, wireType 0 =*/
                88
              ).uint32(message.Version);
            if (message.Signature != null && Object.hasOwnProperty.call(message, "Signature"))
              writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).bytes(message.Signature);
            if (message.Options != null && Object.hasOwnProperty.call(message, "Options"))
              writer.uint32(
                /* id 13, wireType 0 =*/
                104
              ).uint32(message.Options);
            if (message.GuardianAddr != null && Object.hasOwnProperty.call(message, "GuardianAddr"))
              writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).bytes(message.GuardianAddr);
            if (message.GuardianSignature != null && Object.hasOwnProperty.call(message, "GuardianSignature"))
              writer.uint32(
                /* id 15, wireType 2 =*/
                122
              ).bytes(message.GuardianSignature);
            if (message.Relayer != null && Object.hasOwnProperty.call(message, "Relayer"))
              writer.uint32(
                /* id 16, wireType 2 =*/
                130
              ).bytes(message.Relayer);
            if (message.RelayerSignature != null && Object.hasOwnProperty.call(message, "RelayerSignature"))
              writer.uint32(
                /* id 17, wireType 2 =*/
                138
              ).bytes(message.RelayerSignature);
            return writer;
          };
          Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.proto.Transaction();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.Nonce = reader.uint64();
                  break;
                }
                case 2: {
                  message.Value = reader.bytes();
                  break;
                }
                case 3: {
                  message.RcvAddr = reader.bytes();
                  break;
                }
                case 4: {
                  message.RcvUserName = reader.bytes();
                  break;
                }
                case 5: {
                  message.SndAddr = reader.bytes();
                  break;
                }
                case 6: {
                  message.SndUserName = reader.bytes();
                  break;
                }
                case 7: {
                  message.GasPrice = reader.uint64();
                  break;
                }
                case 8: {
                  message.GasLimit = reader.uint64();
                  break;
                }
                case 9: {
                  message.Data = reader.bytes();
                  break;
                }
                case 10: {
                  message.ChainID = reader.bytes();
                  break;
                }
                case 11: {
                  message.Version = reader.uint32();
                  break;
                }
                case 12: {
                  message.Signature = reader.bytes();
                  break;
                }
                case 13: {
                  message.Options = reader.uint32();
                  break;
                }
                case 14: {
                  message.GuardianAddr = reader.bytes();
                  break;
                }
                case 15: {
                  message.GuardianSignature = reader.bytes();
                  break;
                }
                case 16: {
                  message.Relayer = reader.bytes();
                  break;
                }
                case 17: {
                  message.RelayerSignature = reader.bytes();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.Nonce != null && message.hasOwnProperty("Nonce")) {
              if (!$util.isInteger(message.Nonce) && !(message.Nonce && $util.isInteger(message.Nonce.low) && $util.isInteger(message.Nonce.high)))
                return "Nonce: integer|Long expected";
            }
            if (message.Value != null && message.hasOwnProperty("Value")) {
              if (!(message.Value && typeof message.Value.length === "number" || $util.isString(message.Value)))
                return "Value: buffer expected";
            }
            if (message.RcvAddr != null && message.hasOwnProperty("RcvAddr")) {
              if (!(message.RcvAddr && typeof message.RcvAddr.length === "number" || $util.isString(message.RcvAddr)))
                return "RcvAddr: buffer expected";
            }
            if (message.RcvUserName != null && message.hasOwnProperty("RcvUserName")) {
              if (!(message.RcvUserName && typeof message.RcvUserName.length === "number" || $util.isString(message.RcvUserName)))
                return "RcvUserName: buffer expected";
            }
            if (message.SndAddr != null && message.hasOwnProperty("SndAddr")) {
              if (!(message.SndAddr && typeof message.SndAddr.length === "number" || $util.isString(message.SndAddr)))
                return "SndAddr: buffer expected";
            }
            if (message.SndUserName != null && message.hasOwnProperty("SndUserName")) {
              if (!(message.SndUserName && typeof message.SndUserName.length === "number" || $util.isString(message.SndUserName)))
                return "SndUserName: buffer expected";
            }
            if (message.GasPrice != null && message.hasOwnProperty("GasPrice")) {
              if (!$util.isInteger(message.GasPrice) && !(message.GasPrice && $util.isInteger(message.GasPrice.low) && $util.isInteger(message.GasPrice.high)))
                return "GasPrice: integer|Long expected";
            }
            if (message.GasLimit != null && message.hasOwnProperty("GasLimit")) {
              if (!$util.isInteger(message.GasLimit) && !(message.GasLimit && $util.isInteger(message.GasLimit.low) && $util.isInteger(message.GasLimit.high)))
                return "GasLimit: integer|Long expected";
            }
            if (message.Data != null && message.hasOwnProperty("Data")) {
              if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                return "Data: buffer expected";
            }
            if (message.ChainID != null && message.hasOwnProperty("ChainID")) {
              if (!(message.ChainID && typeof message.ChainID.length === "number" || $util.isString(message.ChainID)))
                return "ChainID: buffer expected";
            }
            if (message.Version != null && message.hasOwnProperty("Version")) {
              if (!$util.isInteger(message.Version))
                return "Version: integer expected";
            }
            if (message.Signature != null && message.hasOwnProperty("Signature")) {
              if (!(message.Signature && typeof message.Signature.length === "number" || $util.isString(message.Signature)))
                return "Signature: buffer expected";
            }
            if (message.Options != null && message.hasOwnProperty("Options")) {
              if (!$util.isInteger(message.Options))
                return "Options: integer expected";
            }
            if (message.GuardianAddr != null && message.hasOwnProperty("GuardianAddr")) {
              if (!(message.GuardianAddr && typeof message.GuardianAddr.length === "number" || $util.isString(message.GuardianAddr)))
                return "GuardianAddr: buffer expected";
            }
            if (message.GuardianSignature != null && message.hasOwnProperty("GuardianSignature")) {
              if (!(message.GuardianSignature && typeof message.GuardianSignature.length === "number" || $util.isString(message.GuardianSignature)))
                return "GuardianSignature: buffer expected";
            }
            if (message.Relayer != null && message.hasOwnProperty("Relayer")) {
              if (!(message.Relayer && typeof message.Relayer.length === "number" || $util.isString(message.Relayer)))
                return "Relayer: buffer expected";
            }
            if (message.RelayerSignature != null && message.hasOwnProperty("RelayerSignature")) {
              if (!(message.RelayerSignature && typeof message.RelayerSignature.length === "number" || $util.isString(message.RelayerSignature)))
                return "RelayerSignature: buffer expected";
            }
            return null;
          };
          Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Transaction)
              return object;
            var message = new $root.proto.Transaction();
            if (object.Nonce != null) {
              if ($util.Long)
                (message.Nonce = $util.Long.fromValue(object.Nonce)).unsigned = true;
              else if (typeof object.Nonce === "string")
                message.Nonce = parseInt(object.Nonce, 10);
              else if (typeof object.Nonce === "number")
                message.Nonce = object.Nonce;
              else if (typeof object.Nonce === "object")
                message.Nonce = new $util.LongBits(object.Nonce.low >>> 0, object.Nonce.high >>> 0).toNumber(true);
            }
            if (object.Value != null) {
              if (typeof object.Value === "string")
                $util.base64.decode(object.Value, message.Value = $util.newBuffer($util.base64.length(object.Value)), 0);
              else if (object.Value.length >= 0)
                message.Value = object.Value;
            }
            if (object.RcvAddr != null) {
              if (typeof object.RcvAddr === "string")
                $util.base64.decode(object.RcvAddr, message.RcvAddr = $util.newBuffer($util.base64.length(object.RcvAddr)), 0);
              else if (object.RcvAddr.length >= 0)
                message.RcvAddr = object.RcvAddr;
            }
            if (object.RcvUserName != null) {
              if (typeof object.RcvUserName === "string")
                $util.base64.decode(object.RcvUserName, message.RcvUserName = $util.newBuffer($util.base64.length(object.RcvUserName)), 0);
              else if (object.RcvUserName.length >= 0)
                message.RcvUserName = object.RcvUserName;
            }
            if (object.SndAddr != null) {
              if (typeof object.SndAddr === "string")
                $util.base64.decode(object.SndAddr, message.SndAddr = $util.newBuffer($util.base64.length(object.SndAddr)), 0);
              else if (object.SndAddr.length >= 0)
                message.SndAddr = object.SndAddr;
            }
            if (object.SndUserName != null) {
              if (typeof object.SndUserName === "string")
                $util.base64.decode(object.SndUserName, message.SndUserName = $util.newBuffer($util.base64.length(object.SndUserName)), 0);
              else if (object.SndUserName.length >= 0)
                message.SndUserName = object.SndUserName;
            }
            if (object.GasPrice != null) {
              if ($util.Long)
                (message.GasPrice = $util.Long.fromValue(object.GasPrice)).unsigned = true;
              else if (typeof object.GasPrice === "string")
                message.GasPrice = parseInt(object.GasPrice, 10);
              else if (typeof object.GasPrice === "number")
                message.GasPrice = object.GasPrice;
              else if (typeof object.GasPrice === "object")
                message.GasPrice = new $util.LongBits(object.GasPrice.low >>> 0, object.GasPrice.high >>> 0).toNumber(true);
            }
            if (object.GasLimit != null) {
              if ($util.Long)
                (message.GasLimit = $util.Long.fromValue(object.GasLimit)).unsigned = true;
              else if (typeof object.GasLimit === "string")
                message.GasLimit = parseInt(object.GasLimit, 10);
              else if (typeof object.GasLimit === "number")
                message.GasLimit = object.GasLimit;
              else if (typeof object.GasLimit === "object")
                message.GasLimit = new $util.LongBits(object.GasLimit.low >>> 0, object.GasLimit.high >>> 0).toNumber(true);
            }
            if (object.Data != null) {
              if (typeof object.Data === "string")
                $util.base64.decode(object.Data, message.Data = $util.newBuffer($util.base64.length(object.Data)), 0);
              else if (object.Data.length >= 0)
                message.Data = object.Data;
            }
            if (object.ChainID != null) {
              if (typeof object.ChainID === "string")
                $util.base64.decode(object.ChainID, message.ChainID = $util.newBuffer($util.base64.length(object.ChainID)), 0);
              else if (object.ChainID.length >= 0)
                message.ChainID = object.ChainID;
            }
            if (object.Version != null)
              message.Version = object.Version >>> 0;
            if (object.Signature != null) {
              if (typeof object.Signature === "string")
                $util.base64.decode(object.Signature, message.Signature = $util.newBuffer($util.base64.length(object.Signature)), 0);
              else if (object.Signature.length >= 0)
                message.Signature = object.Signature;
            }
            if (object.Options != null)
              message.Options = object.Options >>> 0;
            if (object.GuardianAddr != null) {
              if (typeof object.GuardianAddr === "string")
                $util.base64.decode(object.GuardianAddr, message.GuardianAddr = $util.newBuffer($util.base64.length(object.GuardianAddr)), 0);
              else if (object.GuardianAddr.length >= 0)
                message.GuardianAddr = object.GuardianAddr;
            }
            if (object.GuardianSignature != null) {
              if (typeof object.GuardianSignature === "string")
                $util.base64.decode(object.GuardianSignature, message.GuardianSignature = $util.newBuffer($util.base64.length(object.GuardianSignature)), 0);
              else if (object.GuardianSignature.length >= 0)
                message.GuardianSignature = object.GuardianSignature;
            }
            if (object.Relayer != null) {
              if (typeof object.Relayer === "string")
                $util.base64.decode(object.Relayer, message.Relayer = $util.newBuffer($util.base64.length(object.Relayer)), 0);
              else if (object.Relayer.length >= 0)
                message.Relayer = object.Relayer;
            }
            if (object.RelayerSignature != null) {
              if (typeof object.RelayerSignature === "string")
                $util.base64.decode(object.RelayerSignature, message.RelayerSignature = $util.newBuffer($util.base64.length(object.RelayerSignature)), 0);
              else if (object.RelayerSignature.length >= 0)
                message.RelayerSignature = object.RelayerSignature;
            }
            return message;
          };
          Transaction.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.Nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.Nonce = options.longs === String ? "0" : 0;
              if (options.bytes === String)
                object.Value = "";
              else {
                object.Value = [];
                if (options.bytes !== Array)
                  object.Value = $util.newBuffer(object.Value);
              }
              if (options.bytes === String)
                object.RcvAddr = "";
              else {
                object.RcvAddr = [];
                if (options.bytes !== Array)
                  object.RcvAddr = $util.newBuffer(object.RcvAddr);
              }
              if (options.bytes === String)
                object.RcvUserName = "";
              else {
                object.RcvUserName = [];
                if (options.bytes !== Array)
                  object.RcvUserName = $util.newBuffer(object.RcvUserName);
              }
              if (options.bytes === String)
                object.SndAddr = "";
              else {
                object.SndAddr = [];
                if (options.bytes !== Array)
                  object.SndAddr = $util.newBuffer(object.SndAddr);
              }
              if (options.bytes === String)
                object.SndUserName = "";
              else {
                object.SndUserName = [];
                if (options.bytes !== Array)
                  object.SndUserName = $util.newBuffer(object.SndUserName);
              }
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.GasPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.GasPrice = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.GasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.GasLimit = options.longs === String ? "0" : 0;
              if (options.bytes === String)
                object.Data = "";
              else {
                object.Data = [];
                if (options.bytes !== Array)
                  object.Data = $util.newBuffer(object.Data);
              }
              if (options.bytes === String)
                object.ChainID = "";
              else {
                object.ChainID = [];
                if (options.bytes !== Array)
                  object.ChainID = $util.newBuffer(object.ChainID);
              }
              object.Version = 0;
              if (options.bytes === String)
                object.Signature = "";
              else {
                object.Signature = [];
                if (options.bytes !== Array)
                  object.Signature = $util.newBuffer(object.Signature);
              }
              object.Options = 0;
              if (options.bytes === String)
                object.GuardianAddr = "";
              else {
                object.GuardianAddr = [];
                if (options.bytes !== Array)
                  object.GuardianAddr = $util.newBuffer(object.GuardianAddr);
              }
              if (options.bytes === String)
                object.GuardianSignature = "";
              else {
                object.GuardianSignature = [];
                if (options.bytes !== Array)
                  object.GuardianSignature = $util.newBuffer(object.GuardianSignature);
              }
              if (options.bytes === String)
                object.Relayer = "";
              else {
                object.Relayer = [];
                if (options.bytes !== Array)
                  object.Relayer = $util.newBuffer(object.Relayer);
              }
              if (options.bytes === String)
                object.RelayerSignature = "";
              else {
                object.RelayerSignature = [];
                if (options.bytes !== Array)
                  object.RelayerSignature = $util.newBuffer(object.RelayerSignature);
              }
            }
            if (message.Nonce != null && message.hasOwnProperty("Nonce"))
              if (typeof message.Nonce === "number")
                object.Nonce = options.longs === String ? String(message.Nonce) : message.Nonce;
              else
                object.Nonce = options.longs === String ? $util.Long.prototype.toString.call(message.Nonce) : options.longs === Number ? new $util.LongBits(message.Nonce.low >>> 0, message.Nonce.high >>> 0).toNumber(true) : message.Nonce;
            if (message.Value != null && message.hasOwnProperty("Value"))
              object.Value = options.bytes === String ? $util.base64.encode(message.Value, 0, message.Value.length) : options.bytes === Array ? Array.prototype.slice.call(message.Value) : message.Value;
            if (message.RcvAddr != null && message.hasOwnProperty("RcvAddr"))
              object.RcvAddr = options.bytes === String ? $util.base64.encode(message.RcvAddr, 0, message.RcvAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.RcvAddr) : message.RcvAddr;
            if (message.RcvUserName != null && message.hasOwnProperty("RcvUserName"))
              object.RcvUserName = options.bytes === String ? $util.base64.encode(message.RcvUserName, 0, message.RcvUserName.length) : options.bytes === Array ? Array.prototype.slice.call(message.RcvUserName) : message.RcvUserName;
            if (message.SndAddr != null && message.hasOwnProperty("SndAddr"))
              object.SndAddr = options.bytes === String ? $util.base64.encode(message.SndAddr, 0, message.SndAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.SndAddr) : message.SndAddr;
            if (message.SndUserName != null && message.hasOwnProperty("SndUserName"))
              object.SndUserName = options.bytes === String ? $util.base64.encode(message.SndUserName, 0, message.SndUserName.length) : options.bytes === Array ? Array.prototype.slice.call(message.SndUserName) : message.SndUserName;
            if (message.GasPrice != null && message.hasOwnProperty("GasPrice"))
              if (typeof message.GasPrice === "number")
                object.GasPrice = options.longs === String ? String(message.GasPrice) : message.GasPrice;
              else
                object.GasPrice = options.longs === String ? $util.Long.prototype.toString.call(message.GasPrice) : options.longs === Number ? new $util.LongBits(message.GasPrice.low >>> 0, message.GasPrice.high >>> 0).toNumber(true) : message.GasPrice;
            if (message.GasLimit != null && message.hasOwnProperty("GasLimit"))
              if (typeof message.GasLimit === "number")
                object.GasLimit = options.longs === String ? String(message.GasLimit) : message.GasLimit;
              else
                object.GasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.GasLimit) : options.longs === Number ? new $util.LongBits(message.GasLimit.low >>> 0, message.GasLimit.high >>> 0).toNumber(true) : message.GasLimit;
            if (message.Data != null && message.hasOwnProperty("Data"))
              object.Data = options.bytes === String ? $util.base64.encode(message.Data, 0, message.Data.length) : options.bytes === Array ? Array.prototype.slice.call(message.Data) : message.Data;
            if (message.ChainID != null && message.hasOwnProperty("ChainID"))
              object.ChainID = options.bytes === String ? $util.base64.encode(message.ChainID, 0, message.ChainID.length) : options.bytes === Array ? Array.prototype.slice.call(message.ChainID) : message.ChainID;
            if (message.Version != null && message.hasOwnProperty("Version"))
              object.Version = message.Version;
            if (message.Signature != null && message.hasOwnProperty("Signature"))
              object.Signature = options.bytes === String ? $util.base64.encode(message.Signature, 0, message.Signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.Signature) : message.Signature;
            if (message.Options != null && message.hasOwnProperty("Options"))
              object.Options = message.Options;
            if (message.GuardianAddr != null && message.hasOwnProperty("GuardianAddr"))
              object.GuardianAddr = options.bytes === String ? $util.base64.encode(message.GuardianAddr, 0, message.GuardianAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.GuardianAddr) : message.GuardianAddr;
            if (message.GuardianSignature != null && message.hasOwnProperty("GuardianSignature"))
              object.GuardianSignature = options.bytes === String ? $util.base64.encode(message.GuardianSignature, 0, message.GuardianSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.GuardianSignature) : message.GuardianSignature;
            if (message.Relayer != null && message.hasOwnProperty("Relayer"))
              object.Relayer = options.bytes === String ? $util.base64.encode(message.Relayer, 0, message.Relayer.length) : options.bytes === Array ? Array.prototype.slice.call(message.Relayer) : message.Relayer;
            if (message.RelayerSignature != null && message.hasOwnProperty("RelayerSignature"))
              object.RelayerSignature = options.bytes === String ? $util.base64.encode(message.RelayerSignature, 0, message.RelayerSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.RelayerSignature) : message.RelayerSignature;
            return object;
          };
          Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Transaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Transaction";
          };
          return Transaction;
        }();
        return proto;
      }();
      return $root;
    });
  }
});

// node_modules/@multiversx/sdk-core/out/proto/serializer.js
var require_serializer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/proto/serializer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtoSerializer = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var address_1 = require_address();
    var constants_1 = require_constants();
    var errors = __importStar(require_errors());
    var utils_1 = require_utils();
    var ProtoSerializer = class {
      /**
       * Serializes a Transaction object to a Buffer. Handles low-level conversion logic and field-mappings as well.
       */
      serializeTransaction(transaction) {
        const proto = require_compiled().proto;
        const protoTransaction = this.convertToProtoMessage(transaction);
        const encoded = proto.Transaction.encode(protoTransaction).finish();
        const buffer = Buffer.from(encoded);
        return buffer;
      }
      convertToProtoMessage(transaction) {
        var _a;
        const proto = require_compiled().proto;
        const receiverPubkey = new address_1.Address(transaction.receiver).getPublicKey();
        const senderPubkey = new address_1.Address(transaction.sender).getPublicKey();
        let protoTransaction = new proto.Transaction({
          // mx-chain-go's serializer handles nonce == 0 differently, thus we treat 0 as "undefined".
          Nonce: Number(transaction.nonce) ? Number(transaction.nonce) : void 0,
          Value: this.serializeTransactionValue(transaction.value),
          RcvAddr: receiverPubkey,
          RcvUserName: transaction.receiverUsername ? Buffer.from(transaction.receiverUsername).toString("base64") : void 0,
          SndAddr: senderPubkey,
          SndUserName: transaction.senderUsername ? Buffer.from(transaction.senderUsername).toString("base64") : void 0,
          GasPrice: Number(transaction.gasPrice),
          GasLimit: Number(transaction.gasLimit),
          Data: transaction.data.length == 0 ? null : transaction.data,
          ChainID: Buffer.from(transaction.chainID),
          Version: transaction.version,
          Signature: transaction.signature
        });
        if (transaction.options !== constants_1.TRANSACTION_OPTIONS_DEFAULT) {
          protoTransaction.Options = transaction.options;
        }
        if (this.isGuardedTransaction(transaction)) {
          protoTransaction.GuardianAddr = new address_1.Address(transaction.guardian).getPublicKey();
          protoTransaction.GuardianSignature = transaction.guardianSignature;
        }
        if (this.isRelayedTransaction(transaction)) {
          protoTransaction.Relayer = (_a = transaction.relayer) == null ? void 0 : _a.getPublicKey();
          protoTransaction.RelayerSignature = transaction.relayerSignature;
        }
        return protoTransaction;
      }
      isRelayedTransaction(transaction) {
        return !transaction.relayer.isEmpty();
      }
      /**
       * Custom serialization, compatible with mx-chain-go.
       */
      serializeTransactionValue(transactionValue) {
        let value = new bignumber_js_1.default(transactionValue.toString());
        if (value.isZero()) {
          return Buffer.from([0, 0]);
        }
        let buffer = utils_1.bigIntToBuffer(value);
        buffer = Buffer.concat([Buffer.from([0]), buffer]);
        return buffer;
      }
      isGuardedTransaction(transaction) {
        const hasGuardian = transaction.guardian.length > 0;
        const hasGuardianSignature = transaction.guardianSignature.length > 0;
        return this.isWithGuardian(transaction) && hasGuardian && hasGuardianSignature;
      }
      isWithGuardian(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) == constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
      }
      deserializeTransaction(_buffer) {
        throw new errors.ErrUnsupportedOperation("deserializeTransaction");
      }
    };
    exports2.ProtoSerializer = ProtoSerializer;
  }
});

// node_modules/@multiversx/sdk-core/out/proto/index.js
var require_proto = __commonJS({
  "node_modules/@multiversx/sdk-core/out/proto/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_serializer(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/transactionComputer.js
var require_transactionComputer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionComputer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionComputer = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var constants_1 = require_constants();
    var errors = __importStar(require_errors());
    var proto_1 = require_proto();
    var transaction_1 = require_transaction();
    var createTransactionHasher = require_blake2b2();
    var createKeccakHash = require_js();
    var TRANSACTION_HASH_LENGTH = 32;
    var TransactionComputer = class {
      constructor() {
      }
      computeTransactionFee(transaction, networkConfig) {
        const moveBalanceGas = BigInt(networkConfig.MinGasLimit + transaction.data.length * networkConfig.GasPerDataByte);
        if (moveBalanceGas > transaction.gasLimit) {
          throw new errors.ErrNotEnoughGas(parseInt(transaction.gasLimit.toString(), 10));
        }
        const gasPrice = transaction.gasPrice;
        const feeForMove = moveBalanceGas * gasPrice;
        if (moveBalanceGas === transaction.gasLimit) {
          return feeForMove;
        }
        const diff = transaction.gasLimit - moveBalanceGas;
        const modifiedGasPrice = BigInt(new bignumber_js_1.default(gasPrice.toString()).multipliedBy(new bignumber_js_1.default(networkConfig.GasPriceModifier)).toFixed(0));
        const processingFee = diff * modifiedGasPrice;
        return feeForMove + processingFee;
      }
      computeBytesForSigning(transaction) {
        this.ensureValidTransactionFields(transaction);
        const plainTransaction = this.toPlainObject(transaction);
        const serialized = JSON.stringify(plainTransaction);
        return new Uint8Array(Buffer.from(serialized));
      }
      computeBytesForVerifying(transaction) {
        const isTxSignedByHash = this.hasOptionsSetForHashSigning(transaction);
        if (isTxSignedByHash) {
          return this.computeHashForSigning(transaction);
        }
        return this.computeBytesForSigning(transaction);
      }
      computeHashForSigning(transaction) {
        const plainTransaction = this.toPlainObject(transaction);
        const signable = Buffer.from(JSON.stringify(plainTransaction));
        return createKeccakHash("keccak256").update(signable).digest();
      }
      computeTransactionHash(transaction) {
        const serializer = new proto_1.ProtoSerializer();
        const buffer = serializer.serializeTransaction(new transaction_1.Transaction(transaction));
        const hash = createTransactionHasher(TRANSACTION_HASH_LENGTH).update(buffer).digest("hex");
        return Buffer.from(hash, "hex");
      }
      hasOptionsSetForGuardedTransaction(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) == constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
      }
      hasOptionsSetForHashSigning(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN) == constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      applyGuardian(transaction, guardian) {
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
          transaction.version = constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS;
        }
        transaction.options = transaction.options | constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
        transaction.guardian = guardian;
      }
      isRelayedV3Transaction(transaction) {
        return !transaction.relayer.isEmpty();
      }
      applyOptionsForHashSigning(transaction) {
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
          transaction.version = constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS;
        }
        transaction.options = transaction.options | constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      toPlainObject(transaction, withSignature) {
        var _a, _b;
        let obj = {
          nonce: Number(transaction.nonce),
          value: transaction.value.toString(),
          receiver: transaction.receiver,
          sender: transaction.sender,
          senderUsername: this.toBase64OrUndefined(transaction.senderUsername),
          receiverUsername: this.toBase64OrUndefined(transaction.receiverUsername),
          gasPrice: Number(transaction.gasPrice),
          gasLimit: Number(transaction.gasLimit),
          data: this.toBase64OrUndefined(transaction.data)
        };
        if (withSignature) {
          obj.signature = this.toHexOrUndefined(transaction.signature);
        }
        obj.chainID = transaction.chainID;
        obj.version = transaction.version;
        obj.options = transaction.options ? transaction.options : void 0;
        obj.guardian = transaction.guardian ? transaction.guardian : void 0;
        obj.relayer = ((_a = transaction.relayer) == null ? void 0 : _a.isEmpty()) ? void 0 : (_b = transaction.relayer) == null ? void 0 : _b.toBech32();
        return obj;
      }
      toHexOrUndefined(value) {
        return value && value.length ? Buffer.from(value).toString("hex") : void 0;
      }
      toBase64OrUndefined(value) {
        return value && value.length ? Buffer.from(value).toString("base64") : void 0;
      }
      ensureValidTransactionFields(transaction) {
        if (!transaction.chainID.length) {
          throw new errors.ErrBadUsage("The `chainID` field is not set");
        }
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
          if (this.hasOptionsSetForGuardedTransaction(transaction) || this.hasOptionsSetForHashSigning(transaction)) {
            throw new errors.ErrBadUsage(`Non-empty transaction options requires transaction version >= ${constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS}`);
          }
        }
      }
    };
    exports2.TransactionComputer = TransactionComputer;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionPayload.js
var require_transactionPayload = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionPayload.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionPayload = void 0;
    var TransactionPayload = class _TransactionPayload {
      /**
       * Creates a TransactionPayload from a utf-8 string or from a buffer.
       */
      constructor(data) {
        this.data = Buffer.from(data || []);
      }
      /**
       * Creates a TransactionPayload from a base-64 encoded string.
       */
      static fromEncoded(encoded) {
        if (!encoded) {
          return new _TransactionPayload("");
        }
        let decoded = Buffer.from(encoded, "base64").toString();
        return new _TransactionPayload(decoded);
      }
      /**
       * Returns whether the "data" is void.
       */
      isEmpty() {
        return this.data.length == 0;
      }
      /**
       * Returns the base-64 representation of the data.
       */
      encoded() {
        return this.data.toString("base64");
      }
      /**
       * Returns the data as a buffer.
       */
      valueOf() {
        return this.data;
      }
      toString() {
        return this.data.toString();
      }
      getEncodedArguments() {
        return this.toString().split("@");
      }
      getRawArguments() {
        return this.getEncodedArguments().map((argument) => Buffer.from(argument, "hex"));
      }
      /**
       * Returns the length of the data.
       */
      length() {
        return Buffer.from(this.data).length;
      }
    };
    exports2.TransactionPayload = TransactionPayload;
  }
});

// node_modules/@multiversx/sdk-core/out/transaction.js
var require_transaction = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transaction.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionHash = exports2.Transaction = void 0;
    var bignumber_js_1 = require_bignumber();
    var address_1 = require_address();
    var constants_1 = require_constants();
    var transactionsConverter_1 = require_transactionsConverter();
    var hash_1 = require_hash();
    var networkParams_1 = require_networkParams();
    var signature_1 = require_signature();
    var transactionComputer_1 = require_transactionComputer();
    var transactionPayload_1 = require_transactionPayload();
    var Transaction = class {
      /**
       * Creates a new Transaction object.
       */
      constructor(options) {
        var _a, _b, _c, _d, _e;
        this.nonce = BigInt(((_a = options.nonce) == null ? void 0 : _a.valueOf()) || 0n);
        this.value = options.value ? BigInt(new bignumber_js_1.BigNumber(options.value.toString()).toFixed(0)) : 0n;
        this.sender = this.addressAsBech32(options.sender);
        this.receiver = this.addressAsBech32(options.receiver);
        this.senderUsername = options.senderUsername || "";
        this.receiverUsername = options.receiverUsername || "";
        this.gasPrice = BigInt(((_b = options.gasPrice) == null ? void 0 : _b.valueOf()) || constants_1.TRANSACTION_MIN_GAS_PRICE);
        this.gasLimit = BigInt(options.gasLimit.valueOf());
        this.data = ((_c = options.data) == null ? void 0 : _c.valueOf()) || new Uint8Array();
        this.chainID = options.chainID.valueOf();
        this.version = Number(((_d = options.version) == null ? void 0 : _d.valueOf()) || constants_1.TRANSACTION_VERSION_DEFAULT);
        this.options = Number(((_e = options.options) == null ? void 0 : _e.valueOf()) || constants_1.TRANSACTION_OPTIONS_DEFAULT);
        this.guardian = options.guardian ? this.addressAsBech32(options.guardian) : "";
        this.relayer = options.relayer ? options.relayer : address_1.Address.empty();
        this.signature = options.signature || Buffer.from([]);
        this.guardianSignature = options.guardianSignature || Buffer.from([]);
        this.relayerSignature = options.relayerSignature || Buffer.from([]);
      }
      addressAsBech32(address) {
        return typeof address === "string" ? address : address.bech32();
      }
      /**
       * Legacy method, use the "nonce" property instead.
       */
      getNonce() {
        return Number(this.nonce);
      }
      /**
       * Legacy method, use the "nonce" property instead.
       * Sets the account sequence number of the sender. Must be done prior signing.
       */
      setNonce(nonce) {
        this.nonce = BigInt(nonce.valueOf());
      }
      /**
       * Legacy method, use the "value" property instead.
       */
      getValue() {
        return this.value;
      }
      /**
       * Legacy method, use the "value" property instead.
       */
      setValue(value) {
        this.value = BigInt(value.toString());
      }
      /**
       * Legacy method, use the "sender" property instead.
       */
      getSender() {
        return address_1.Address.fromBech32(this.sender);
      }
      /**
       * Legacy method, use the "sender" property instead.
       */
      setSender(sender) {
        this.sender = typeof sender === "string" ? sender : sender.bech32();
      }
      /**
       * Legacy method, use the "receiver" property instead.
       */
      getReceiver() {
        return address_1.Address.fromBech32(this.receiver);
      }
      /**
       * Legacy method, use the "senderUsername" property instead.
       */
      getSenderUsername() {
        return this.senderUsername;
      }
      /**
       * Legacy method, use the "senderUsername" property instead.
       */
      setSenderUsername(senderUsername) {
        this.senderUsername = senderUsername;
      }
      /**
       * Legacy method, use the "receiverUsername" property instead.
       */
      getReceiverUsername() {
        return this.receiverUsername;
      }
      /**
       * Legacy method, use the "receiverUsername" property instead.
       */
      setReceiverUsername(receiverUsername) {
        this.receiverUsername = receiverUsername;
      }
      /**
       * Legacy method, use the "guardian" property instead.
       */
      getGuardian() {
        return new address_1.Address(this.guardian);
      }
      /**
       * Legacy method, use the "gasPrice" property instead.
       */
      getGasPrice() {
        return Number(this.gasPrice);
      }
      /**
       * Legacy method, use the "gasPrice" property instead.
       */
      setGasPrice(gasPrice) {
        this.gasPrice = BigInt(gasPrice.valueOf());
      }
      /**
       * Legacy method, use the "gasLimit" property instead.
       */
      getGasLimit() {
        return Number(this.gasLimit);
      }
      /**
       * Legacy method, use the "gasLimit" property instead.
       */
      setGasLimit(gasLimit) {
        this.gasLimit = BigInt(gasLimit.valueOf());
      }
      /**
       * Legacy method, use the "data" property instead.
       */
      getData() {
        return new transactionPayload_1.TransactionPayload(Buffer.from(this.data));
      }
      /**
       * Legacy method, use the "chainID" property instead.
       */
      getChainID() {
        return this.chainID;
      }
      /**
       * Legacy method, use the "chainID" property instead.
       */
      setChainID(chainID) {
        this.chainID = chainID.valueOf();
      }
      /**
       * Legacy method, use the "version" property instead.
       */
      getVersion() {
        return new networkParams_1.TransactionVersion(this.version);
      }
      /**
       * Legacy method, use the "version" property instead.
       */
      setVersion(version) {
        this.version = version.valueOf();
      }
      /**
       * Legacy method, use the "options" property instead.
       */
      getOptions() {
        return new networkParams_1.TransactionOptions(this.options.valueOf());
      }
      /**
       * Legacy method, use the "options" property instead.
       *
       * Question for review: check how the options are set by sdk-dapp, wallet, ledger, extension.
       */
      setOptions(options) {
        this.options = options.valueOf();
      }
      /**
       * Legacy method, use the "signature" property instead.
       */
      getSignature() {
        return Buffer.from(this.signature);
      }
      /**
       * Legacy method, use the "guardianSignature" property instead.
       */
      getGuardianSignature() {
        return Buffer.from(this.guardianSignature);
      }
      /**
       * Legacy method, use the "guardian" property instead.
       */
      setGuardian(guardian) {
        this.guardian = typeof guardian === "string" ? guardian : guardian.bech32();
      }
      /**
       * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
       */
      getHash() {
        return TransactionHash.compute(this);
      }
      /**
       * Legacy method, use "TransactionComputer.computeBytesForSigning()" instead.
       * Serializes a transaction to a sequence of bytes, ready to be signed.
       * This function is called internally by signers.
       */
      serializeForSigning() {
        const computer = new transactionComputer_1.TransactionComputer();
        const bytes = computer.computeBytesForSigning(this);
        return Buffer.from(bytes);
      }
      /**
       * Checks the integrity of the guarded transaction
       */
      isGuardedTransaction() {
        const hasGuardian = this.guardian.length > 0;
        const hasGuardianSignature = this.guardianSignature.length > 0;
        return this.getOptions().isWithGuardian() && hasGuardian && hasGuardianSignature;
      }
      /**
       * Legacy method, use "TransactionsConverter.transactionToPlainObject()" instead.
       *
       * Converts the transaction object into a ready-to-serialize, plain JavaScript object.
       * This function is called internally within the signing procedure.
       */
      toPlainObject() {
        const converter = new transactionsConverter_1.TransactionsConverter();
        return converter.transactionToPlainObject(this);
      }
      /**
       * Legacy method, use "TransactionsConverter.plainObjectToTransaction()" instead.
       * Converts a plain object transaction into a Transaction Object.
       *
       * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()
       */
      static fromPlainObject(plainObjectTransaction) {
        const converter = new transactionsConverter_1.TransactionsConverter();
        return converter.plainObjectToTransaction(plainObjectTransaction);
      }
      /**
       * Legacy method, use the "signature" property instead.
       * Applies the signature on the transaction.
       *
       * @param signature The signature, as computed by a signer.
       */
      applySignature(signature) {
        this.signature = signature_1.interpretSignatureAsBuffer(signature);
      }
      /**
       * Legacy method, use the "guardianSignature" property instead.
       * Applies the guardian signature on the transaction.
       *
       * @param guardianSignature The signature, as computed by a signer.
       */
      applyGuardianSignature(guardianSignature) {
        this.guardianSignature = signature_1.interpretSignatureAsBuffer(guardianSignature);
      }
      /**
       * Converts a transaction to a ready-to-broadcast object.
       * Called internally by the network provider.
       */
      toSendable() {
        return this.toPlainObject();
      }
      /**
       * Legacy method, use "TransactionComputer.computeTransactionFee()" instead.
       *
       * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties
       * @param networkConfig {@link NetworkConfig}
       */
      computeFee(networkConfig) {
        const computer = new transactionComputer_1.TransactionComputer();
        const fee = computer.computeTransactionFee(this, networkConfig);
        return new bignumber_js_1.BigNumber(fee.toString());
      }
    };
    exports2.Transaction = Transaction;
    var TransactionHash = class _TransactionHash extends hash_1.Hash {
      constructor(hash) {
        super(hash);
      }
      /**
       * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
       * Computes the hash of a transaction.
       */
      static compute(transaction) {
        const computer = new transactionComputer_1.TransactionComputer();
        const hash = computer.computeTransactionHash(transaction);
        return new _TransactionHash(Buffer.from(hash).toString("hex"));
      }
    };
    exports2.TransactionHash = TransactionHash;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionBuilder.js
var require_transactionBuilder = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionBuilder.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionBuilder = void 0;
    var constants_1 = require_constants();
    var transaction_1 = require_transaction();
    var transactionPayload_1 = require_transactionPayload();
    var TransactionBuilder = class {
      constructor(options) {
        this.config = options.config;
        this.sender = options.sender;
        this.receiver = options.receiver;
        this.dataParts = options.dataParts;
        this.providedGasLimit = options.gasLimit;
        this.addDataMovementGas = options.addDataMovementGas;
        this.amount = options.amount;
      }
      computeGasLimit(payload) {
        if (!this.addDataMovementGas) {
          return this.providedGasLimit;
        }
        const dataMovementGas = this.config.minGasLimit + this.config.gasLimitPerByte * BigInt(payload.length());
        const gasLimit = dataMovementGas + this.providedGasLimit;
        return gasLimit;
      }
      buildTransactionPayload() {
        const data = this.dataParts.join(constants_1.ARGUMENTS_SEPARATOR);
        return new transactionPayload_1.TransactionPayload(data);
      }
      build() {
        const data = this.buildTransactionPayload();
        const gasLimit = this.computeGasLimit(data);
        return new transaction_1.Transaction({
          sender: this.sender.bech32(),
          receiver: this.receiver.bech32(),
          gasLimit,
          value: this.amount || 0n,
          data: data.valueOf(),
          chainID: this.config.chainID
        });
      }
    };
    exports2.TransactionBuilder = TransactionBuilder;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/delegationTransactionsFactory.js
var require_delegationTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/delegationTransactionsFactory.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DelegationTransactionsFactory = void 0;
    var address_1 = require_address();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var transactionBuilder_1 = require_transactionBuilder();
    var DelegationTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
        this.argSerializer = new smartcontracts_1.ArgSerializer();
        this.delegationManagerAddress = address_1.Address.fromHex(constants_1.DELEGATION_MANAGER_SC_ADDRESS_HEX, this.config.addressHrp);
      }
      createTransactionForNewDelegationContract(options) {
        const dataParts = [
          "createNewDelegationContract",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.BigUIntValue(options.totalDelegationCap),
            new smartcontracts_1.BigUIntValue(options.serviceFee)
          ])
        ];
        const executionGasLimit = this.config.gasLimitCreateDelegationContract + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.delegationManagerAddress,
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true,
          amount: options.amount
        }).build();
      }
      createTransactionForAddingNodes(options) {
        if (options.publicKeys.length !== options.signedMessages.length) {
          throw new errors_1.Err("The number of public keys should match the number of signed messages");
        }
        const signedMessagesAsTypedValues = options.signedMessages.map((message) => new smartcontracts_1.BytesValue(Buffer.from(message)));
        const messagesAsStrings = this.argSerializer.valuesToStrings(signedMessagesAsTypedValues);
        const numNodes = options.publicKeys.length;
        const dataParts = ["addNodes"];
        for (let i = 0; i < numNodes; i++) {
          dataParts.push(...[options.publicKeys[i].hex(), messagesAsStrings[i]]);
        }
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: this.computeExecutionGasLimitForNodesManagement(numNodes),
          addDataMovementGas: true
        }).build();
      }
      createTransactionForRemovingNodes(options) {
        const dataParts = ["removeNodes"];
        for (const key of options.publicKeys) {
          dataParts.push(key.hex());
        }
        const numNodes = options.publicKeys.length;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: this.computeExecutionGasLimitForNodesManagement(numNodes),
          addDataMovementGas: true
        }).build();
      }
      createTransactionForStakingNodes(options) {
        let dataParts = ["stakeNodes"];
        for (const key of options.publicKeys) {
          dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const additionalGasForAllNodes = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode;
        const executionGasLimit = additionalGasForAllNodes + this.config.gasLimitStake + this.config.gasLimitDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnbondingNodes(options) {
        let dataParts = ["unBondNodes"];
        for (const key of options.publicKeys) {
          dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const executionGasLimit = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode + this.config.gasLimitUnbond + this.config.gasLimitDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnstakingNodes(options) {
        let dataParts = ["unStakeNodes"];
        for (const key of options.publicKeys) {
          dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const executionGasLimit = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode + this.config.gasLimitUnstake + this.config.gasLimitDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnjailingNodes(options) {
        const dataParts = ["unJailNodes"];
        for (const key of options.publicKeys) {
          dataParts.push(key.hex());
        }
        const numNodes = options.publicKeys.length;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: this.computeExecutionGasLimitForNodesManagement(numNodes),
          addDataMovementGas: true,
          amount: options.amount
        }).build();
      }
      createTransactionForChangingServiceFee(options) {
        const dataParts = [
          "changeServiceFee",
          this.argSerializer.valuesToStrings([new smartcontracts_1.BigUIntValue(options.serviceFee)])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForModifyingDelegationCap(options) {
        const dataParts = [
          "modifyTotalDelegationCap",
          this.argSerializer.valuesToStrings([new smartcontracts_1.BigUIntValue(options.delegationCap)])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingAutomaticActivation(options) {
        const dataParts = ["setAutomaticActivation", this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("true")])[0]];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnsettingAutomaticActivation(options) {
        const dataParts = ["setAutomaticActivation", this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("false")])[0]];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingCapCheckOnRedelegateRewards(options) {
        const dataParts = [
          "setCheckCapOnReDelegateRewards",
          this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("true")])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnsettingCapCheckOnRedelegateRewards(options) {
        const dataParts = [
          "setCheckCapOnReDelegateRewards",
          this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("false")])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingMetadata(options) {
        const dataParts = [
          "setMetaData",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.name),
            new smartcontracts_1.StringValue(options.website),
            new smartcontracts_1.StringValue(options.identifier)
          ])
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      computeExecutionGasLimitForNodesManagement(numNodes) {
        const additionalGasForAllNodes = this.config.additionalGasLimitPerValidatorNode * BigInt(numNodes);
        return this.config.gasLimitDelegationOperations + additionalGasForAllNodes;
      }
    };
    exports2.DelegationTransactionsFactory = DelegationTransactionsFactory;
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/relayedTransactionsFactory.js
var require_relayedTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/relayedTransactionsFactory.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayedTransactionsFactory = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var address_1 = require_address();
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var transaction_1 = require_transaction();
    var JSONbig = require_json_bigint();
    var RelayedTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
      }
      createRelayedV1Transaction(options) {
        if (!options.innerTransaction.gasLimit) {
          throw new errors_1.ErrInvalidInnerTransaction("The gas limit is not set for the inner transaction");
        }
        if (!options.innerTransaction.signature.length) {
          throw new errors_1.ErrInvalidInnerTransaction("The inner transaction is not signed");
        }
        const serializedTransaction = this.prepareInnerTransactionForRelayedV1(options.innerTransaction);
        const data = `relayedTx@${Buffer.from(serializedTransaction).toString("hex")}`;
        const additionalGasForDataLength = this.config.gasLimitPerByte * BigInt(data.length);
        const gasLimit = this.config.minGasLimit + additionalGasForDataLength + options.innerTransaction.gasLimit;
        return new transaction_1.Transaction({
          chainID: this.config.chainID,
          sender: options.relayerAddress.bech32(),
          receiver: options.innerTransaction.sender,
          gasLimit,
          data: Buffer.from(data)
        });
      }
      createRelayedV2Transaction(options) {
        if (options.innerTransaction.gasLimit) {
          throw new errors_1.ErrInvalidInnerTransaction("The gas limit should not be set for the inner transaction");
        }
        if (!options.innerTransaction.signature.length) {
          throw new errors_1.ErrInvalidInnerTransaction("The inner transaction is not signed");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
          new smartcontracts_1.AddressValue(address_1.Address.fromBech32(options.innerTransaction.receiver)),
          new smartcontracts_1.U64Value(new bignumber_js_1.default(options.innerTransaction.nonce.toString())),
          new smartcontracts_1.BytesValue(Buffer.from(options.innerTransaction.data)),
          new smartcontracts_1.BytesValue(Buffer.from(options.innerTransaction.signature))
        ]);
        const data = `relayedTxV2@${argumentsString}`;
        const additionalGasForDataLength = this.config.gasLimitPerByte * BigInt(data.length);
        const gasLimit = options.innerTransactionGasLimit + this.config.minGasLimit + additionalGasForDataLength;
        return new transaction_1.Transaction({
          sender: options.relayerAddress.bech32(),
          receiver: options.innerTransaction.sender,
          value: 0n,
          gasLimit,
          chainID: this.config.chainID,
          data: Buffer.from(data),
          version: options.innerTransaction.version,
          options: options.innerTransaction.options
        });
      }
      prepareInnerTransactionForRelayedV1(innerTransaction) {
        const txObject = {
          nonce: innerTransaction.nonce,
          sender: address_1.Address.newFromBech32(innerTransaction.sender).getPublicKey().toString("base64"),
          receiver: address_1.Address.newFromBech32(innerTransaction.receiver).getPublicKey().toString("base64"),
          value: innerTransaction.value,
          gasPrice: innerTransaction.gasPrice,
          gasLimit: innerTransaction.gasLimit,
          data: Buffer.from(innerTransaction.data).toString("base64"),
          signature: Buffer.from(innerTransaction.signature).toString("base64"),
          chainID: Buffer.from(innerTransaction.chainID).toString("base64"),
          version: innerTransaction.version,
          options: innerTransaction.options.valueOf() == 0 ? void 0 : innerTransaction.options,
          guardian: innerTransaction.guardian ? address_1.Address.newFromBech32(innerTransaction.guardian).getPublicKey().toString("base64") : void 0,
          guardianSignature: innerTransaction.guardianSignature.length ? Buffer.from(innerTransaction.guardianSignature).toString("base64") : void 0,
          sndUserName: innerTransaction.senderUsername ? Buffer.from(innerTransaction.senderUsername).toString("base64") : void 0,
          rcvUserName: innerTransaction.receiverUsername ? Buffer.from(innerTransaction.receiverUsername).toString("base64") : void 0
        };
        return JSONbig.stringify(txObject);
      }
    };
    exports2.RelayedTransactionsFactory = RelayedTransactionsFactory;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenManagementTransactionsFactory.js
var require_tokenManagementTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenManagementTransactionsFactory.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenManagementTransactionsFactory = void 0;
    var address_1 = require_address();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var logger_1 = require_logger();
    var smartcontracts_1 = require_smartcontracts();
    var transactionBuilder_1 = require_transactionBuilder();
    var TokenManagementTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
        this.argSerializer = new smartcontracts_1.ArgSerializer();
        this.trueAsString = "true";
        this.falseAsString = "false";
        this.esdtContractAddress = address_1.Address.fromHex(constants_1.ESDT_CONTRACT_ADDRESS_HEX, this.config.addressHrp);
      }
      createTransactionForIssuingFungible(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.BigUIntValue(options.initialSupply),
          new smartcontracts_1.BigUIntValue(options.numDecimals),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["issue", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForIssuingSemiFungible(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canTransferNFTCreateRole"),
          new smartcontracts_1.StringValue(this.boolToString(options.canTransferNFTCreateRole)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["issueSemiFungible", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForIssuingNonFungible(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canTransferNFTCreateRole"),
          new smartcontracts_1.StringValue(this.boolToString(options.canTransferNFTCreateRole)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["issueNonFungible", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForRegisteringMetaESDT(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.BigUIntValue(options.numDecimals),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canTransferNFTCreateRole"),
          new smartcontracts_1.StringValue(this.boolToString(options.canTransferNFTCreateRole)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["registerMetaESDT", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForRegisteringAndSettingRoles(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const dataParts = [
          "registerAndSetAllRoles",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenName),
            new smartcontracts_1.StringValue(options.tokenTicker),
            new smartcontracts_1.StringValue(options.tokenType),
            new smartcontracts_1.BigUIntValue(options.numDecimals)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForSettingBurnRoleGlobally(options) {
        const dataParts = [
          "setBurnRoleGlobally",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitToggleBurnRoleGlobally,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnsettingBurnRoleGlobally(options) {
        const dataParts = [
          "unsetBurnRoleGlobally",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitToggleBurnRoleGlobally,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingSpecialRoleOnFungibleToken(options) {
        const args = [new smartcontracts_1.StringValue(options.tokenIdentifier), new smartcontracts_1.AddressValue(options.user)];
        options.addRoleLocalMint ? args.push(new smartcontracts_1.StringValue("ESDTRoleLocalMint")) : 0;
        options.addRoleLocalBurn ? args.push(new smartcontracts_1.StringValue("ESDTRoleLocalBurn")) : 0;
        options.addRoleESDTTransferRole ? args.push(new smartcontracts_1.StringValue("ESDTTransferRole")) : 0;
        const dataParts = ["setSpecialRole", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitSetSpecialRole,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingSpecialRoleOnSemiFungibleToken(options) {
        const args = [new smartcontracts_1.StringValue(options.tokenIdentifier), new smartcontracts_1.AddressValue(options.user)];
        options.addRoleNFTCreate ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTCreate")) : 0;
        options.addRoleNFTBurn ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTBurn")) : 0;
        options.addRoleNFTAddQuantity ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTAddQuantity")) : 0;
        options.addRoleESDTTransferRole ? args.push(new smartcontracts_1.StringValue("ESDTTransferRole")) : 0;
        options.addRoleESDTModifyCreator ? args.push(new smartcontracts_1.StringValue("ESDTRoleModifyCreator")) : 0;
        const dataParts = ["setSpecialRole", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitSetSpecialRole,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingSpecialRoleOnMetaESDT(options) {
        return this.createTransactionForSettingSpecialRoleOnSemiFungibleToken(options);
      }
      createTransactionForSettingSpecialRoleOnNonFungibleToken(options) {
        const args = [new smartcontracts_1.StringValue(options.tokenIdentifier), new smartcontracts_1.AddressValue(options.user)];
        options.addRoleNFTCreate ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTCreate")) : 0;
        options.addRoleNFTBurn ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTBurn")) : 0;
        options.addRoleNFTUpdateAttributes ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTUpdateAttributes")) : 0;
        options.addRoleNFTAddURI ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTAddURI")) : 0;
        options.addRoleESDTTransferRole ? args.push(new smartcontracts_1.StringValue("ESDTTransferRole")) : 0;
        options.addRoleESDTModifyCreator ? args.push(new smartcontracts_1.StringValue("ESDTRoleModifyCreator")) : 0;
        options.addRoleNFTRecreate ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTRecreate")) : 0;
        options.addRoleESDTSetNewURI ? args.push(new smartcontracts_1.StringValue("ESDTRoleSetNewURI")) : 0;
        options.addRoleESDTModifyRoyalties ? args.push(new smartcontracts_1.StringValue("ESDTRoleModifyRoyalties")) : 0;
        const dataParts = ["setSpecialRole", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitSetSpecialRole,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForCreatingNFT(options) {
        const dataParts = [
          "ESDTNFTCreate",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.initialQuantity),
            new smartcontracts_1.StringValue(options.name),
            new smartcontracts_1.BigUIntValue(options.royalties),
            new smartcontracts_1.StringValue(options.hash),
            new smartcontracts_1.BytesValue(Buffer.from(options.attributes)),
            ...options.uris.map((uri) => new smartcontracts_1.StringValue(uri))
          ])
        ];
        const nftData = options.name + options.hash + options.attributes + options.uris.join("");
        const storageGasLimit = this.config.gasLimitStorePerByte + BigInt(nftData.length);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftCreate + storageGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForPausing(options) {
        const dataParts = ["pause", ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitPausing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnpausing(options) {
        const dataParts = [
          "unPause",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitPausing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForFreezing(options) {
        const dataParts = [
          "freeze",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.AddressValue(options.user)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitFreezing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnfreezing(options) {
        const dataParts = [
          "UnFreeze",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.AddressValue(options.user)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitFreezing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForWiping(options) {
        const dataParts = [
          "wipe",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.AddressValue(options.user)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitWiping,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForLocalMint(options) {
        const dataParts = [
          "ESDTLocalMint",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.supplyToMint)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtLocalMint,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForLocalBurning(options) {
        const dataParts = [
          "ESDTLocalBurn",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.supplyToBurn)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtLocalBurn,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUpdatingAttributes(options) {
        const dataParts = [
          "ESDTNFTUpdateAttributes",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            new smartcontracts_1.BytesValue(Buffer.from(options.attributes))
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftUpdateAttributes,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForAddingQuantity(options) {
        const dataParts = [
          "ESDTNFTAddQuantity",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            new smartcontracts_1.BigUIntValue(options.quantityToAdd)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftAddQuantity,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForBurningQuantity(options) {
        const dataParts = [
          "ESDTNFTBurn",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            new smartcontracts_1.BigUIntValue(options.quantityToBurn)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftBurn,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForModifyingRoyalties(options) {
        const dataParts = [
          "ESDTModifyRoyalties",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            new smartcontracts_1.BigUIntValue(options.newRoyalties)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtModifyRoyalties,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingNewUris(options) {
        if (!options.newUris.length) {
          throw new errors_1.ErrBadUsage("No URIs provided");
        }
        const dataParts = [
          "ESDTSetNewURIs",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            ...options.newUris.map((uri) => new smartcontracts_1.StringValue(uri))
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitSetNewUris,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForModifyingCreator(options) {
        const dataParts = [
          "ESDTModifyCreator",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtModifyCreator,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUpdatingMetadata(options) {
        const dataParts = [
          "ESDTMetaDataUpdate",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            ...options.newTokenName ? [new smartcontracts_1.StringValue(options.newTokenName)] : [],
            ...options.newRoyalties ? [new smartcontracts_1.BigUIntValue(options.newRoyalties)] : [],
            ...options.newHash ? [new smartcontracts_1.StringValue(options.newHash)] : [],
            ...options.newAttributes ? [new smartcontracts_1.BytesValue(Buffer.from(options.newAttributes))] : [],
            ...options.newUris ? options.newUris.map((uri) => new smartcontracts_1.StringValue(uri)) : []
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtMetadataUpdate,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForMetadataRecreate(options) {
        const dataParts = [
          "ESDTMetaDataRecreate",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            ...options.newTokenName ? [new smartcontracts_1.StringValue(options.newTokenName)] : [],
            ...options.newRoyalties ? [new smartcontracts_1.BigUIntValue(options.newRoyalties)] : [],
            ...options.newHash ? [new smartcontracts_1.StringValue(options.newHash)] : [],
            ...options.newAttributes ? [new smartcontracts_1.BytesValue(Buffer.from(options.newAttributes))] : [],
            ...options.newUris ? options.newUris.map((uri) => new smartcontracts_1.StringValue(uri)) : []
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitNftMetadataRecreate,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForChangingTokenToDynamic(options) {
        const dataParts = [
          "changeToDynamic",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitNftChangeToDynamic,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUpdatingTokenId(options) {
        const dataParts = [
          "updateTokenID",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitUpdateTokenId,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForRegisteringDynamicToken(options) {
        const dataParts = [
          "registerDynamic",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenName),
            new smartcontracts_1.StringValue(options.tokenTicker),
            new smartcontracts_1.StringValue(options.tokenType)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitRegisterDynamic,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForRegisteringDynamicAndSettingRoles(options) {
        const dataParts = [
          "registerAndSetAllRolesDynamic",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenName),
            new smartcontracts_1.StringValue(options.tokenTicker),
            new smartcontracts_1.StringValue(options.tokenType)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.esdtContractAddress,
          dataParts,
          gasLimit: this.config.gasLimitRegisterDynamic,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      notifyAboutUnsettingBurnRoleGlobally() {
        logger_1.Logger.info(`
==========
IMPORTANT!
==========
You are about to issue (register) a new token. This will set the role "ESDTRoleBurnForAll" (globally).
Once the token is registered, you can unset this role by calling "unsetBurnRoleGlobally" (in a separate transaction).`);
      }
      boolToString(value) {
        if (value) {
          return this.trueAsString;
        }
        return this.falseAsString;
      }
    };
    exports2.TokenManagementTransactionsFactory = TokenManagementTransactionsFactory;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionsFactoryConfig.js
var require_transactionsFactoryConfig = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionsFactoryConfig.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionsFactoryConfig = void 0;
    var config_1 = require_config();
    var TransactionsFactoryConfig = class {
      constructor(options) {
        this.chainID = options.chainID;
        this.addressHrp = config_1.LibraryConfig.DefaultAddressHrp;
        this.minGasLimit = 50000n;
        this.gasLimitPerByte = 1500n;
        this.gasLimitIssue = 60000000n;
        this.gasLimitToggleBurnRoleGlobally = 60000000n;
        this.gasLimitEsdtLocalMint = 300000n;
        this.gasLimitEsdtLocalBurn = 300000n;
        this.gasLimitSetSpecialRole = 60000000n;
        this.gasLimitPausing = 60000000n;
        this.gasLimitFreezing = 60000000n;
        this.gasLimitWiping = 60000000n;
        this.gasLimitEsdtNftCreate = 3000000n;
        this.gasLimitEsdtNftUpdateAttributes = 1000000n;
        this.gasLimitEsdtNftAddQuantity = 1000000n;
        this.gasLimitEsdtNftBurn = 1000000n;
        this.gasLimitStorePerByte = 10000n;
        this.issueCost = 50000000000000000n;
        this.gasLimitEsdtModifyRoyalties = 60000000n;
        this.gasLimitEsdtModifyCreator = 60000000n;
        this.gasLimitEsdtMetadataUpdate = 60000000n;
        this.gasLimitSetNewUris = 60000000n;
        this.gasLimitNftMetadataRecreate = 60000000n;
        this.gasLimitNftChangeToDynamic = 60000000n;
        this.gasLimitUpdateTokenId = 60000000n;
        this.gasLimitRegisterDynamic = 60000000n;
        this.gasLimitStake = 5000000n;
        this.gasLimitUnstake = 5000000n;
        this.gasLimitUnbond = 5000000n;
        this.gasLimitCreateDelegationContract = 50000000n;
        this.gasLimitDelegationOperations = 1000000n;
        this.additionalGasLimitPerValidatorNode = 6000000n;
        this.additionalGasLimitForDelegationOperations = 10000000n;
        this.gasLimitSaveKeyValue = 100000n;
        this.gasLimitPersistPerByte = 1000n;
        this.gasLimitSetGuardian = 250000n;
        this.gasLimitGuardAccount = 250000n;
        this.gasLimitUnguardAccount = 250000n;
        this.gasLimitESDTTransfer = 200000n;
        this.gasLimitESDTNFTTransfer = 200000n;
        this.gasLimitMultiESDTNFTTransfer = 200000n;
        this.gasLimitClaimDeveloperRewards = 6000000n;
        this.gasLimitChangeOwnerAddress = 6000000n;
      }
    };
    exports2.TransactionsFactoryConfig = TransactionsFactoryConfig;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenTransfersDataBuilder.js
var require_tokenTransfersDataBuilder = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenTransfersDataBuilder.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenTransfersDataBuilder = void 0;
    var argSerializer_1 = require_argSerializer();
    var typesystem_1 = require_typesystem();
    var tokens_1 = require_tokens();
    var TokenTransfersDataBuilder = class {
      constructor() {
        this.tokenComputer = new tokens_1.TokenComputer();
        this.argsSerializer = new argSerializer_1.ArgSerializer();
      }
      buildDataPartsForESDTTransfer(transfer) {
        const args = this.argsSerializer.valuesToStrings([
          new typesystem_1.TokenIdentifierValue(transfer.token.identifier),
          new typesystem_1.BigUIntValue(transfer.amount)
        ]);
        return ["ESDTTransfer", ...args];
      }
      buildDataPartsForSingleESDTNFTTransfer(transfer, receiver) {
        const token = transfer.token;
        const identifier = this.tokenComputer.extractIdentifierFromExtendedIdentifier(token.identifier);
        const args = this.argsSerializer.valuesToStrings([
          new typesystem_1.TokenIdentifierValue(identifier),
          new typesystem_1.BigUIntValue(token.nonce),
          new typesystem_1.BigUIntValue(transfer.amount),
          new typesystem_1.AddressValue(receiver)
        ]);
        return ["ESDTNFTTransfer", ...args];
      }
      buildDataPartsForMultiESDTNFTTransfer(receiver, transfers) {
        const argsTyped = [new typesystem_1.AddressValue(receiver), new typesystem_1.U32Value(transfers.length)];
        for (const transfer of transfers) {
          const identifier = this.tokenComputer.extractIdentifierFromExtendedIdentifier(transfer.token.identifier);
          argsTyped.push(...[
            new typesystem_1.TokenIdentifierValue(identifier),
            new typesystem_1.BigUIntValue(transfer.token.nonce),
            new typesystem_1.BigUIntValue(transfer.amount)
          ]);
        }
        const args = this.argsSerializer.valuesToStrings(argsTyped);
        return ["MultiESDTNFTTransfer", ...args];
      }
    };
    exports2.TokenTransfersDataBuilder = TokenTransfersDataBuilder;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/transferTransactionsFactory.js
var require_transferTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/transferTransactionsFactory.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransferTransactionsFactory = void 0;
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var tokens_1 = require_tokens();
    var transaction_1 = require_transaction();
    var transactionPayload_1 = require_transactionPayload();
    var tokenTransfersDataBuilder_1 = require_tokenTransfersDataBuilder();
    var transactionBuilder_1 = require_transactionBuilder();
    var ADDITIONAL_GAS_FOR_ESDT_TRANSFER = 1e5;
    var ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER = 8e5;
    var TransferTransactionsFactory = class {
      /**
       * Should be instantiated using `Config`.
       * Instantiating this class using GasEstimator represents the legacy version of this class.
       * The legacy version contains methods like `createEGLDTransfer`, `createESDTTransfer`, `createESDTNFTTransfer` and `createMultiESDTNFTTransfer`.
       * This was done in order to minimize breaking changes in client code.
       */
      constructor(options) {
        if (this.isGasEstimator(options)) {
          this.gasEstimator = options;
        } else {
          this.config = options.config;
          this.tokenComputer = new tokens_1.TokenComputer();
          this.tokenTransfersDataBuilder = new tokenTransfersDataBuilder_1.TokenTransfersDataBuilder();
        }
      }
      isGasEstimator(options) {
        return typeof options === "object" && typeof options.forEGLDTransfer === "function" && typeof options.forESDTTransfer === "function" && typeof options.forESDTNFTTransfer === "function" && typeof options.forMultiESDTNFTTransfer === "function";
      }
      isGasEstimatorDefined() {
        return this.gasEstimator !== void 0;
      }
      ensureConfigIsDefined() {
        if (this.config === void 0) {
          throw new errors_1.Err("'config' is not defined");
        }
      }
      createTransactionForNativeTokenTransfer(options) {
        this.ensureConfigIsDefined();
        const data = options.data || new Uint8Array();
        return new transaction_1.Transaction({
          sender: options.sender.bech32(),
          receiver: options.receiver.bech32(),
          chainID: this.config.chainID,
          gasLimit: this.computeGasForMoveBalance(this.config, data),
          data,
          value: options.nativeAmount
        });
      }
      createTransactionForESDTTokenTransfer(options) {
        this.ensureConfigIsDefined();
        const numberOfTransfers = options.tokenTransfers.length;
        if (numberOfTransfers === 0) {
          throw new errors_1.ErrBadUsage("No token transfer has been provided");
        }
        if (numberOfTransfers === 1) {
          return this.createSingleESDTTransferTransaction(options);
        }
        const { dataParts, extraGasForTransfer } = this.buildMultiESDTNFTTransferData(options.tokenTransfers, options.receiver);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: extraGasForTransfer,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForTransfer(options) {
        var _a;
        const nativeAmount = options.nativeAmount ?? 0n;
        let tokenTransfers = options.tokenTransfers ? [...options.tokenTransfers] : [];
        const numberOfTokens = tokenTransfers.length;
        if (numberOfTokens && ((_a = options.data) == null ? void 0 : _a.length)) {
          throw new errors_1.ErrBadUsage("Can't set data field when sending esdt tokens");
        }
        if (nativeAmount && numberOfTokens === 0 || options.data) {
          return this.createTransactionForNativeTokenTransfer({
            sender: options.sender,
            receiver: options.receiver,
            nativeAmount,
            data: options.data
          });
        }
        const nativeTransfer = nativeAmount ? tokens_1.TokenTransfer.newFromEgldAmount(nativeAmount) : void 0;
        if (nativeTransfer) {
          tokenTransfers.push(nativeTransfer);
        }
        return this.createTransactionForESDTTokenTransfer({
          sender: options.sender,
          receiver: options.receiver,
          tokenTransfers
        });
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForNativeTokenTransfer} instead.
       */
      createEGLDTransfer(args) {
        var _a;
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create an EGLD transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForNativeTokenTransfer` method.");
        }
        const dataLength = ((_a = args.data) == null ? void 0 : _a.length()) || 0;
        const estimatedGasLimit = this.gasEstimator.forEGLDTransfer(dataLength);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          value: args.value,
          receiver: args.receiver,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: args.data,
          chainID: args.chainID
        });
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForESDTTokenTransfer} instead.
       */
      createESDTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create an ESDT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
          // The token identifier
          smartcontracts_1.BytesValue.fromUTF8(args.tokenTransfer.tokenIdentifier),
          // The transfered amount
          new smartcontracts_1.BigUIntValue(args.tokenTransfer.valueOf())
        ]);
        const data = `ESDTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forESDTTransfer(dataLength);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          receiver: args.receiver,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: transactionPayload,
          chainID: args.chainID
        });
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForESDTTokenTransfer} instead.
       */
      createESDTNFTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create an ESDTNFT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
          // The token identifier
          smartcontracts_1.BytesValue.fromUTF8(args.tokenTransfer.tokenIdentifier),
          // The nonce of the token
          new smartcontracts_1.U64Value(args.tokenTransfer.nonce),
          // The transferred quantity
          new smartcontracts_1.BigUIntValue(args.tokenTransfer.valueOf()),
          // The destination address
          new smartcontracts_1.AddressValue(args.destination)
        ]);
        const data = `ESDTNFTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forESDTNFTTransfer(dataLength);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          receiver: args.sender,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: transactionPayload,
          chainID: args.chainID
        });
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForESDTTokenTransfer} instead.
       */
      createMultiESDTNFTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create a MultiESDTNFT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const parts = [
          // The destination address
          new smartcontracts_1.AddressValue(args.destination),
          // Number of tokens
          new smartcontracts_1.U16Value(args.tokenTransfers.length)
        ];
        for (const payment of args.tokenTransfers) {
          parts.push(...[
            // The token identifier
            smartcontracts_1.BytesValue.fromUTF8(payment.tokenIdentifier),
            // The nonce of the token
            new smartcontracts_1.U64Value(payment.nonce),
            // The transfered quantity
            new smartcontracts_1.BigUIntValue(payment.valueOf())
          ]);
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString(parts);
        const data = `MultiESDTNFTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forMultiESDTNFTTransfer(dataLength, args.tokenTransfers.length);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          receiver: args.sender,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: transactionPayload,
          chainID: args.chainID
        });
      }
      createSingleESDTTransferTransaction(options) {
        this.ensureConfigIsDefined();
        const transfer = options.tokenTransfers[0];
        const { dataParts, extraGasForTransfer, receiver } = this.buildTransferData(transfer, options);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver,
          dataParts,
          gasLimit: extraGasForTransfer,
          addDataMovementGas: true
        }).build();
      }
      buildTransferData(transfer, options) {
        let dataParts = [];
        let extraGasForTransfer;
        let receiver = options.receiver;
        if (this.tokenComputer.isFungible(transfer.token)) {
          if (transfer.token.identifier === constants_1.EGLD_IDENTIFIER_FOR_MULTI_ESDTNFT_TRANSFER) {
            ({ dataParts, extraGasForTransfer } = this.buildMultiESDTNFTTransferData([transfer], receiver));
            receiver = options.sender;
          } else {
            ({ dataParts, extraGasForTransfer } = this.buildESDTTransferData(transfer));
          }
        } else {
          ({ dataParts, extraGasForTransfer } = this.buildSingleESDTNFTTransferData(transfer, receiver));
          receiver = options.sender;
        }
        return { dataParts, extraGasForTransfer, receiver };
      }
      buildMultiESDTNFTTransferData(transfer, receiver) {
        return {
          dataParts: this.tokenTransfersDataBuilder.buildDataPartsForMultiESDTNFTTransfer(receiver, transfer),
          extraGasForTransfer: this.config.gasLimitMultiESDTNFTTransfer * BigInt(transfer.length) + BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER)
        };
      }
      buildESDTTransferData(transfer) {
        return {
          dataParts: this.tokenTransfersDataBuilder.buildDataPartsForESDTTransfer(transfer),
          extraGasForTransfer: this.config.gasLimitESDTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_TRANSFER)
        };
      }
      buildSingleESDTNFTTransferData(transfer, receiver) {
        return {
          dataParts: this.tokenTransfersDataBuilder.buildDataPartsForSingleESDTNFTTransfer(transfer, receiver),
          extraGasForTransfer: this.config.gasLimitESDTNFTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER)
        };
      }
      computeGasForMoveBalance(config, data) {
        return config.minGasLimit + config.gasLimitPerByte * BigInt(data.length);
      }
    };
    exports2.TransferTransactionsFactory = TransferTransactionsFactory;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/accountTransactionsFactory.js
var require_accountTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/accountTransactionsFactory.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccountTransactionsFactory = void 0;
    var address_1 = require_address();
    var transactionBuilder_1 = require_transactionBuilder();
    var AccountTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
      }
      createTransactionForSavingKeyValue(options) {
        const functionName = "SaveKeyValue";
        const keyValueParts = this.computeDataPartsForSavingKeyValue(options.keyValuePairs);
        const dataParts = [functionName, ...keyValueParts];
        const extraGas = this.computeExtraGasForSavingKeyValue(options.keyValuePairs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: extraGas,
          addDataMovementGas: true
        }).build();
      }
      computeExtraGasForSavingKeyValue(keyValuePairs) {
        let extraGas = 0n;
        keyValuePairs.forEach((value, key) => {
          extraGas += this.config.gasLimitPersistPerByte * BigInt(key.length + value.length) + this.config.gasLimitStorePerByte * BigInt(value.length);
        });
        return extraGas + this.config.gasLimitSaveKeyValue;
      }
      computeDataPartsForSavingKeyValue(keyValuePairs) {
        const dataParts = [];
        keyValuePairs.forEach((value, key) => {
          dataParts.push(...[Buffer.from(key).toString("hex"), Buffer.from(value).toString("hex")]);
        });
        return dataParts;
      }
      createTransactionForSettingGuardian(options) {
        const dataParts = [
          "SetGuardian",
          address_1.Address.fromBech32(options.guardianAddress.bech32()).toHex(),
          Buffer.from(options.serviceID).toString("hex")
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitSetGuardian,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForGuardingAccount(options) {
        const dataParts = ["GuardAccount"];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitGuardAccount,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnguardingAccount(options) {
        const dataParts = ["UnGuardAccount"];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitUnguardAccount,
          addDataMovementGas: true
        }).build();
      }
    };
    exports2.AccountTransactionsFactory = AccountTransactionsFactory;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/index.js
var require_transactionsFactories = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_delegationTransactionsFactory(), exports2);
    __exportStar(require_relayedTransactionsFactory(), exports2);
    __exportStar(require_smartContractTransactionsFactory(), exports2);
    __exportStar(require_tokenManagementTransactionsFactory(), exports2);
    __exportStar(require_transactionsFactoryConfig(), exports2);
    __exportStar(require_transferTransactionsFactory(), exports2);
    __exportStar(require_accountTransactionsFactory(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/interactionChecker.js
var require_interactionChecker = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/interactionChecker.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractionChecker = void 0;
    var errors = __importStar(require_errors());
    var bignumber_js_1 = __importDefault(require_bignumber());
    var InteractionChecker = class {
      checkInteraction(interaction, definition) {
        this.checkPayable(interaction, definition);
        this.checkArguments(interaction, definition);
      }
      checkPayable(interaction, definition) {
        let hasValue = !new bignumber_js_1.default(interaction.getValue().toString()).isZero();
        let isPayableInEGLD = definition.modifiers.isPayableInEGLD();
        if (hasValue && !isPayableInEGLD) {
          throw new errors.ErrContractInteraction("cannot send EGLD value to non-payable");
        }
      }
      checkArguments(interaction, definition) {
        let formalArguments = definition.input;
        let actualArguments = interaction.getArguments();
        let numFormalArguments = formalArguments.length;
        let numActualArguments = actualArguments.length;
        if (numFormalArguments != numActualArguments) {
          throw new errors.ErrContractInteraction(`bad arguments, expected: ${numFormalArguments}, got: ${numActualArguments}`);
        }
        for (let i = 0; i < numFormalArguments; i++) {
          let expectedType = formalArguments[i].type;
          let argument = actualArguments[i];
          let actualType = argument.getType();
          let ok = expectedType.isAssignableFrom(actualType);
          if (!ok) {
            throw new errors.ErrContractInteraction(`type mismatch at index ${i}, expected: ${expectedType}, got: ${actualType}`);
          }
        }
      }
    };
    exports2.InteractionChecker = InteractionChecker;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/query.js
var require_query = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Query = void 0;
    var address_1 = require_address();
    var argSerializer_1 = require_argSerializer();
    var Query = class {
      constructor(obj) {
        this.caller = obj.caller || address_1.Address.empty();
        this.address = obj.address;
        this.func = obj.func;
        this.args = obj.args || [];
        this.value = obj.value || 0;
      }
      getEncodedArguments() {
        return new argSerializer_1.ArgSerializer().valuesToStrings(this.args);
      }
    };
    exports2.Query = Query;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/interaction.js
var require_interaction = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/interaction.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Interaction = void 0;
    var address_1 = require_address();
    var compatibility_1 = require_compatibility();
    var constants_1 = require_constants();
    var tokens_1 = require_tokens();
    var transactionsFactories_1 = require_transactionsFactories();
    var interactionChecker_1 = require_interactionChecker();
    var query_1 = require_query();
    var Interaction = class {
      constructor(contract, func, args) {
        this.nonce = 0;
        this.value = "0";
        this.gasLimit = 0;
        this.gasPrice = void 0;
        this.chainID = "";
        this.querent = address_1.Address.empty();
        this.sender = address_1.Address.empty();
        this.version = constants_1.TRANSACTION_VERSION_DEFAULT;
        this.contract = contract;
        this.function = func;
        this.args = args;
        this.tokenTransfers = [];
      }
      getContractAddress() {
        return this.contract.getAddress();
      }
      getFunction() {
        return this.function;
      }
      getEndpoint() {
        return this.contract.getEndpoint(this.function);
      }
      getArguments() {
        return this.args;
      }
      getValue() {
        return this.value;
      }
      getTokenTransfers() {
        return this.tokenTransfers;
      }
      getGasLimit() {
        return this.gasLimit;
      }
      getExplicitReceiver() {
        return this.explicitReceiver;
      }
      buildTransaction() {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(this.sender, "'sender' of interaction", "use interaction.withSender()");
        const factoryConfig = new transactionsFactories_1.TransactionsFactoryConfig({ chainID: this.chainID.valueOf() });
        const factory = new transactionsFactories_1.SmartContractTransactionsFactory({
          config: factoryConfig
        });
        const transaction = factory.createTransactionForExecute({
          sender: this.sender,
          contract: this.contract.getAddress(),
          function: this.function.valueOf(),
          gasLimit: BigInt(this.gasLimit.valueOf()),
          arguments: this.args,
          nativeTransferAmount: BigInt(this.value.toString()),
          tokenTransfers: this.tokenTransfers
        });
        transaction.chainID = this.chainID.valueOf();
        transaction.nonce = BigInt(this.nonce.valueOf());
        transaction.version = this.version;
        if (this.gasPrice) {
          transaction.gasPrice = BigInt(this.gasPrice.valueOf());
        }
        return transaction;
      }
      buildQuery() {
        return new query_1.Query({
          address: this.contract.getAddress(),
          func: this.function,
          args: this.args,
          // Value will be set using "withValue()".
          value: this.value,
          caller: this.querent
        });
      }
      withValue(value) {
        this.value = value;
        return this;
      }
      withSingleESDTTransfer(transfer) {
        this.tokenTransfers = [transfer].map((transfer2) => new tokens_1.TokenTransfer(transfer2));
        return this;
      }
      withSingleESDTNFTTransfer(transfer) {
        this.tokenTransfers = [transfer].map((transfer2) => new tokens_1.TokenTransfer(transfer2));
        return this;
      }
      withMultiESDTNFTTransfer(transfers) {
        this.tokenTransfers = transfers.map((transfer) => new tokens_1.TokenTransfer(transfer));
        return this;
      }
      withGasLimit(gasLimit) {
        this.gasLimit = gasLimit;
        return this;
      }
      withGasPrice(gasPrice) {
        this.gasPrice = gasPrice;
        return this;
      }
      withNonce(nonce) {
        this.nonce = nonce;
        return this;
      }
      useThenIncrementNonceOf(account) {
        return this.withNonce(account.getNonceThenIncrement());
      }
      withChainID(chainID) {
        this.chainID = chainID;
        return this;
      }
      withSender(sender) {
        this.sender = sender;
        return this;
      }
      withVersion(version) {
        this.version = version;
        return this;
      }
      /**
       * Sets the "caller" field on contract queries.
       */
      withQuerent(querent) {
        this.querent = querent;
        return this;
      }
      withExplicitReceiver(receiver) {
        this.explicitReceiver = receiver;
        return this;
      }
      /**
       * To perform custom checking, extend {@link Interaction} and override this method.
       */
      check() {
        new interactionChecker_1.InteractionChecker().checkInteraction(this, this.getEndpoint());
        return this;
      }
    };
    exports2.Interaction = Interaction;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/interface.js
var require_interface = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/interface.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/argumentErrorContext.js
var require_argumentErrorContext = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/argumentErrorContext.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArgumentErrorContext = void 0;
    var errors_1 = require_errors();
    var ArgumentErrorContext = class {
      constructor(endpointName, argumentIndex, parameterDefinition) {
        this.endpointName = endpointName;
        this.argumentIndex = argumentIndex;
        this.parameterDefinition = parameterDefinition;
      }
      throwError(specificError) {
        throw new errors_1.ErrInvalidArgument(`Error when converting arguments for endpoint (endpoint name: ${this.endpointName}, argument index: ${this.argumentIndex}, name: ${this.parameterDefinition.name}, type: ${this.parameterDefinition.type})
Nested error: ${specificError}`);
      }
      convertError(native, typeName) {
        this.throwError(`Can't convert argument (argument: ${native}, type ${typeof native}), wanted type: ${typeName})`);
      }
      unhandledType(functionName, type) {
        this.throwError(`Unhandled type (function: ${functionName}, type: ${type})`);
      }
      guardSameLength(native, valueTypes) {
        native = native || [];
        if (native.length != valueTypes.length) {
          this.throwError(`Incorrect composite type length: have ${native.length}, expected ${valueTypes.length} (argument: ${native})`);
        }
      }
      guardHasField(native, fieldName) {
        native = native || {};
        if (!(fieldName in native)) {
          this.throwError(`Struct argument does not contain a field named "${fieldName}" (argument: ${JSON.stringify(native)})`);
        }
      }
    };
    exports2.ArgumentErrorContext = ArgumentErrorContext;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/nativeSerializer.js
var require_nativeSerializer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/nativeSerializer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NativeSerializer = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var address_1 = require_address();
    var errors_1 = require_errors();
    var utils_codec_1 = require_utils_codec();
    var argumentErrorContext_1 = require_argumentErrorContext();
    var typesystem_1 = require_typesystem();
    var NativeSerializer;
    (function(NativeSerializer2) {
      function nativeToTypedValues(args, endpoint) {
        args = args || [];
        checkArgumentsCardinality(args, endpoint);
        if (hasNonCountedVariadicParameter(endpoint)) {
          args = repackNonCountedVariadicParameters(args, endpoint);
        } else {
        }
        let parameters = endpoint.input;
        let values = [];
        for (let i = 0; i < parameters.length; i++) {
          let parameter = parameters[i];
          let errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i, parameter);
          let value = convertToTypedValue(args[i], parameter.type, errorContext);
          values.push(value);
        }
        return values;
      }
      NativeSerializer2.nativeToTypedValues = nativeToTypedValues;
      function checkArgumentsCardinality(args, endpoint) {
        const { min, max } = getArgumentsCardinality(endpoint.input);
        if (!(min <= args.length && args.length <= max)) {
          throw new errors_1.ErrInvalidArgument(`Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`);
        }
      }
      function hasNonCountedVariadicParameter(endpoint) {
        const lastParameter = endpoint.input[endpoint.input.length - 1];
        return (lastParameter == null ? void 0 : lastParameter.type) instanceof typesystem_1.VariadicType && !lastParameter.type.isCounted;
      }
      function repackNonCountedVariadicParameters(args, endpoint) {
        const lastEndpointParamIndex = endpoint.input.length - 1;
        const argAtIndex = args[lastEndpointParamIndex];
        if (argAtIndex == null ? void 0 : argAtIndex.belongsToTypesystem) {
          const isVariadicValue = argAtIndex.hasClassOrSuperclass(typesystem_1.VariadicValue.ClassName);
          if (!isVariadicValue) {
            throw new errors_1.ErrInvalidArgument(`Wrong argument type for endpoint ${endpoint.name}: typed value provided; expected variadic type, have ${argAtIndex.getClassName()}`);
          }
        } else {
          args[lastEndpointParamIndex] = args.slice(lastEndpointParamIndex);
        }
        return args;
      }
      function getArgumentsCardinality(parameters) {
        let reversed = [...parameters].reverse();
        let min = parameters.length;
        let max = parameters.length;
        let variadic = false;
        if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {
          max = Infinity;
          variadic = true;
        }
        for (let parameter of reversed) {
          if (parameter.type.getCardinality().isSingular()) {
            break;
          }
          min -= 1;
        }
        return { min, max, variadic };
      }
      NativeSerializer2.getArgumentsCardinality = getArgumentsCardinality;
      function convertToTypedValue(value, type, errorContext) {
        if (value && typesystem_1.isTyped(value)) {
          return value;
        }
        if (type instanceof typesystem_1.OptionType) {
          return toOptionValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.OptionalType) {
          return toOptionalValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.VariadicType) {
          return toVariadicValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.CompositeType) {
          return toCompositeValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.TupleType) {
          return toTupleValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.StructType) {
          return toStructValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.ListType) {
          return toListValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.PrimitiveType) {
          return toPrimitive(value, type, errorContext);
        }
        if (type instanceof typesystem_1.EnumType) {
          return toEnumValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.ExplicitEnumType) {
          return toExplicitEnumValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.ManagedDecimalType) {
          return toManagedDecimal(value, type, errorContext);
        }
        errorContext.throwError(`convertToTypedValue: unhandled type ${type}`);
      }
      function toOptionValue(native, type, errorContext) {
        if (native == null) {
          return typesystem_1.OptionValue.newMissing();
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return typesystem_1.OptionValue.newProvided(converted);
      }
      function toOptionalValue(native, type, errorContext) {
        if (native == null) {
          return new typesystem_1.OptionalValue(type);
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return new typesystem_1.OptionalValue(type, converted);
      }
      function toVariadicValue(native, type, errorContext) {
        if (type.isCounted) {
          throw new errors_1.ErrInvalidArgument(`Counted variadic arguments must be explicitly typed. E.g. use "VariadicValue.fromItemsCounted()" or "new VariadicValue()"`);
        }
        if (native == null) {
          native = [];
        }
        if (native.map === void 0) {
          errorContext.convertError(native, "Variadic");
        }
        let converted = native.map(function(item) {
          return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.VariadicValue(type, converted);
      }
      function toListValue(native, type, errorContext) {
        if (native.map === void 0) {
          errorContext.convertError(native, "List");
        }
        let converted = native.map(function(item) {
          return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.List(type, converted);
      }
      function toCompositeValue(native, type, errorContext) {
        let typedValues = [];
        let typeParameters = type.getTypeParameters();
        errorContext.guardSameLength(native, typeParameters);
        for (let i = 0; i < typeParameters.length; i++) {
          typedValues.push(convertToTypedValue(native[i], typeParameters[i], errorContext));
        }
        return new typesystem_1.CompositeValue(type, typedValues);
      }
      function toTupleValue(native, type, errorContext) {
        let typedValues = [];
        const fields = type.getFieldsDefinitions();
        errorContext.guardSameLength(native, fields);
        for (let i = 0; i < fields.length; i++) {
          typedValues.push(convertToTypedValue(native[i], fields[i].type, errorContext));
        }
        return typesystem_1.Tuple.fromItems(typedValues);
      }
      function toStructValue(native, type, errorContext) {
        let structFieldValues = [];
        const fields = type.getFieldsDefinitions();
        for (let i = 0; i < fields.length; i++) {
          const fieldName = fields[i].name;
          errorContext.guardHasField(native, fieldName);
          const fieldNativeValue = native[fieldName];
          const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);
          structFieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));
        }
        return new typesystem_1.Struct(type, structFieldValues);
      }
      function toPrimitive(native, type, errorContext) {
        if (type instanceof typesystem_1.NumericalType) {
          const number = new bignumber_js_1.default(native);
          return convertNumericalType(number, type, errorContext);
        }
        if (type instanceof typesystem_1.BytesType) {
          return convertNativeToBytesValue(native, errorContext);
        }
        if (type instanceof typesystem_1.AddressType) {
          return new typesystem_1.AddressValue(convertNativeToAddress(native, errorContext));
        }
        if (type instanceof typesystem_1.BooleanType) {
          const boolValue = native.toString().toLowerCase() === "true" || native.toString() === "1";
          return new typesystem_1.BooleanValue(boolValue);
        }
        if (type instanceof typesystem_1.TokenIdentifierType) {
          return new typesystem_1.TokenIdentifierValue(convertNativeToString(native, errorContext));
        }
        errorContext.throwError(`(function: toPrimitive) unsupported type ${type}`);
      }
      function toEnumValue(native, type, errorContext) {
        if (typeof native === "number") {
          return typesystem_1.EnumValue.fromDiscriminant(type, native);
        }
        if (typeof native === "string") {
          return typesystem_1.EnumValue.fromName(type, native);
        }
        if (typeof native === "object") {
          errorContext.guardHasField(native, "name");
          const variant = type.getVariantByName(native.name);
          errorContext.guardHasField(native, "fields");
          const nativeFields = native.fields;
          const fieldValues = [];
          const fields = variant.getFieldsDefinitions();
          for (let i = 0; i < fields.length; i++) {
            const fieldName = fields[i].name;
            errorContext.guardHasField(nativeFields, fieldName);
            const fieldNativeValue = nativeFields[fieldName];
            const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);
            fieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));
          }
          return new typesystem_1.EnumValue(type, variant, fieldValues);
        }
        errorContext.throwError(`(function: toEnumValue) unsupported native type ${typeof native}`);
      }
      function toExplicitEnumValue(native, type, errorContext) {
        if (typeof native === "string") {
          return typesystem_1.ExplicitEnumValue.fromName(type, native);
        }
        if (typeof native === "object") {
          errorContext.guardHasField(native, "name");
          const variant = type.getVariantByName(native.name);
          return new typesystem_1.ExplicitEnumValue(type, variant);
        }
        errorContext.throwError(`(function: toExplicitEnumValue) unsupported native type ${typeof native}`);
      }
      function toManagedDecimal(native, type, errorContext) {
        if (typeof native === "object") {
          return new typesystem_1.ManagedDecimalValue(native[0], native[1], type.isVariable());
        }
        errorContext.throwError(`(function: toManagedDecimal) unsupported native type ${typeof native}`);
      }
      function convertNativeToBytesValue(native, errorContext) {
        const innerValue = native.valueOf();
        if (native === void 0) {
          errorContext.convertError(native, "BytesValue");
        }
        if (native instanceof Buffer) {
          return new typesystem_1.BytesValue(native);
        }
        if (typeof native === "string") {
          return typesystem_1.BytesValue.fromUTF8(native);
        }
        if (innerValue instanceof Buffer) {
          return new typesystem_1.BytesValue(innerValue);
        }
        if (typeof innerValue === "number") {
          return typesystem_1.BytesValue.fromHex(utils_codec_1.numberToPaddedHex(innerValue));
        }
        errorContext.convertError(native, "BytesValue");
      }
      function convertNativeToString(native, errorContext) {
        if (native === void 0) {
          errorContext.convertError(native, "Buffer");
        }
        if (native instanceof Buffer) {
          return native.toString();
        }
        if (typeof native === "string") {
          return native;
        }
        errorContext.convertError(native, "Buffer");
      }
      function convertNativeToAddress(native, errorContext) {
        if (native.bech32) {
          return native;
        }
        if (native.getAddress) {
          return native.getAddress();
        }
        switch (native.constructor) {
          case Buffer:
          case String:
            return new address_1.Address(native);
          default:
            errorContext.convertError(native, "Address");
        }
      }
      NativeSerializer2.convertNativeToAddress = convertNativeToAddress;
      function convertNumericalType(number, type, errorContext) {
        switch (type.constructor) {
          case typesystem_1.U8Type:
            return new typesystem_1.U8Value(number);
          case typesystem_1.I8Type:
            return new typesystem_1.I8Value(number);
          case typesystem_1.U16Type:
            return new typesystem_1.U16Value(number);
          case typesystem_1.I16Type:
            return new typesystem_1.I16Value(number);
          case typesystem_1.U32Type:
            return new typesystem_1.U32Value(number);
          case typesystem_1.I32Type:
            return new typesystem_1.I32Value(number);
          case typesystem_1.U64Type:
            return new typesystem_1.U64Value(number);
          case typesystem_1.I64Type:
            return new typesystem_1.I64Value(number);
          case typesystem_1.BigUIntType:
            return new typesystem_1.BigUIntValue(number);
          case typesystem_1.BigIntType:
            return new typesystem_1.BigIntValue(number);
          default:
            errorContext.unhandledType("convertNumericalType", type);
        }
      }
    })(NativeSerializer = exports2.NativeSerializer || (exports2.NativeSerializer = {}));
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/transactionPayloadBuilders.js
var require_transactionPayloadBuilders = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/transactionPayloadBuilders.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractCallPayloadBuilder = exports2.ContractUpgradePayloadBuilder = exports2.ContractDeployPayloadBuilder = void 0;
    var constants_1 = require_constants();
    var transactionPayload_1 = require_transactionPayload();
    var utils_1 = require_utils2();
    var argSerializer_1 = require_argSerializer();
    var ContractDeployPayloadBuilder = class {
      constructor() {
        this.code = null;
        this.codeMetadata = "";
        this.arguments = [];
      }
      /**
       * Sets the code of the Smart Contract.
       */
      setCode(code) {
        this.code = code;
        return this;
      }
      /**
       * Sets the code metadata of the Smart Contract.
       */
      setCodeMetadata(codeMetadata) {
        this.codeMetadata = codeMetadata;
        return this;
      }
      /**
       * Adds constructor (`init`) arguments.
       */
      addInitArg(arg) {
        this.arguments.push(arg);
        return this;
      }
      /**
       * Sets constructor (`init`) arguments.
       */
      setInitArgs(args) {
        this.arguments = args;
        return this;
      }
      /**
       * Builds the {@link TransactionPayload}.
       */
      build() {
        utils_1.guardValueIsSet("code", this.code);
        let code = this.code.toString();
        let codeMetadata = this.codeMetadata.toString();
        let data = `${code}@${constants_1.WasmVirtualMachine}@${codeMetadata}`;
        data = appendArgumentsToString(data, this.arguments);
        return new transactionPayload_1.TransactionPayload(data);
      }
    };
    exports2.ContractDeployPayloadBuilder = ContractDeployPayloadBuilder;
    var ContractUpgradePayloadBuilder = class {
      constructor() {
        this.code = null;
        this.codeMetadata = "";
        this.arguments = [];
      }
      /**
       * Sets the code of the Smart Contract.
       */
      setCode(code) {
        this.code = code;
        return this;
      }
      /**
       * Sets the code metadata of the Smart Contract.
       */
      setCodeMetadata(codeMetadata) {
        this.codeMetadata = codeMetadata;
        return this;
      }
      /**
       * Adds upgrade (`init`) arguments.
       */
      addInitArg(arg) {
        this.arguments.push(arg);
        return this;
      }
      /**
       * Sets upgrade (`init`) arguments.
       */
      setInitArgs(args) {
        this.arguments = args;
        return this;
      }
      /**
       * Builds the {@link TransactionPayload}.
       */
      build() {
        utils_1.guardValueIsSet("code", this.code);
        let code = this.code.toString();
        let codeMetadata = this.codeMetadata.toString();
        let data = `upgradeContract@${code}@${codeMetadata}`;
        data = appendArgumentsToString(data, this.arguments);
        return new transactionPayload_1.TransactionPayload(data);
      }
    };
    exports2.ContractUpgradePayloadBuilder = ContractUpgradePayloadBuilder;
    var ContractCallPayloadBuilder = class {
      constructor() {
        this.contractFunction = null;
        this.arguments = [];
      }
      /**
       * Sets the function to be called (executed).
       */
      setFunction(contractFunction) {
        this.contractFunction = contractFunction;
        return this;
      }
      /**
       * Adds a function argument.
       */
      addArg(arg) {
        this.arguments.push(arg);
        return this;
      }
      /**
       * Sets the function arguments.
       */
      setArgs(args) {
        this.arguments = args;
        return this;
      }
      /**
       * Builds the {@link TransactionPayload}.
       */
      build() {
        utils_1.guardValueIsSet("calledFunction", this.contractFunction);
        let data = this.contractFunction.toString();
        data = appendArgumentsToString(data, this.arguments);
        return new transactionPayload_1.TransactionPayload(data);
      }
    };
    exports2.ContractCallPayloadBuilder = ContractCallPayloadBuilder;
    function appendArgumentsToString(to, values) {
      let { argumentsString, count } = new argSerializer_1.ArgSerializer().valuesToString(values);
      if (count == 0) {
        return to;
      }
      return `${to}@${argumentsString}`;
    }
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/index.js
var require_smartcontracts = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_argSerializer(), exports2);
    __exportStar(require_code(), exports2);
    __exportStar(require_codec(), exports2);
    __exportStar(require_codeMetadata(), exports2);
    __exportStar(require_function(), exports2);
    __exportStar(require_interaction(), exports2);
    __exportStar(require_interactionChecker(), exports2);
    __exportStar(require_interface(), exports2);
    __exportStar(require_nativeSerializer(), exports2);
    __exportStar(require_query(), exports2);
    __exportStar(require_resultsParser(), exports2);
    __exportStar(require_returnCode(), exports2);
    __exportStar(require_smartContract(), exports2);
    __exportStar(require_transactionPayloadBuilders(), exports2);
    __exportStar(require_typesystem(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/smartContractTransactionsFactory.js
var require_smartContractTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/smartContractTransactionsFactory.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartContractTransactionsFactory = void 0;
    var address_1 = require_address();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var logger_1 = require_logger();
    var smartcontracts_1 = require_smartcontracts();
    var nativeSerializer_1 = require_nativeSerializer();
    var typesystem_1 = require_typesystem();
    var tokens_1 = require_tokens();
    var utils_codec_1 = require_utils_codec();
    var tokenTransfersDataBuilder_1 = require_tokenTransfersDataBuilder();
    var transactionBuilder_1 = require_transactionBuilder();
    var SmartContractTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
        this.abi = options.abi;
        this.tokenComputer = new tokens_1.TokenComputer();
        this.dataArgsBuilder = new tokenTransfersDataBuilder_1.TokenTransfersDataBuilder();
        this.contractDeployAddress = address_1.Address.fromHex(constants_1.CONTRACT_DEPLOY_ADDRESS_HEX, this.config.addressHrp);
      }
      createTransactionForDeploy(options) {
        var _a;
        const nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        const isUpgradeable = options.isUpgradeable ?? true;
        const isReadable = options.isReadable ?? true;
        const isPayable = options.isPayable ?? false;
        const isPayableBySmartContract = options.isPayableBySmartContract ?? true;
        const args = options.arguments || [];
        const metadata = new smartcontracts_1.CodeMetadata(isUpgradeable, isReadable, isPayable, isPayableBySmartContract);
        const dataParts = [utils_codec_1.byteArrayToHex(options.bytecode), utils_codec_1.byteArrayToHex(constants_1.VM_TYPE_WASM_VM), metadata.toString()];
        const endpoint = (_a = this.abi) == null ? void 0 : _a.constructorDefinition;
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: this.contractDeployAddress,
          dataParts,
          gasLimit: options.gasLimit,
          addDataMovementGas: false,
          amount: nativeTransferAmount
        }).build();
      }
      createTransactionForExecute(options) {
        var _a;
        const args = options.arguments || [];
        let tokenTransfers = options.tokenTransfers ? [...options.tokenTransfers] : [];
        let nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        let numberOfTokens = tokenTransfers.length;
        if (nativeTransferAmount && numberOfTokens) {
          tokenTransfers.push(tokens_1.TokenTransfer.newFromEgldAmount(nativeTransferAmount));
          nativeTransferAmount = 0n;
          numberOfTokens++;
        }
        let receiver = options.contract;
        let dataParts = [];
        if (numberOfTokens === 1) {
          const transfer = tokenTransfers[0];
          if (this.tokenComputer.isFungible(transfer.token)) {
            dataParts = this.dataArgsBuilder.buildDataPartsForESDTTransfer(transfer);
          } else {
            dataParts = this.dataArgsBuilder.buildDataPartsForSingleESDTNFTTransfer(transfer, receiver);
            receiver = options.sender;
          }
        } else if (numberOfTokens > 1) {
          dataParts = this.dataArgsBuilder.buildDataPartsForMultiESDTNFTTransfer(receiver, tokenTransfers);
          receiver = options.sender;
        }
        dataParts.push(dataParts.length ? utils_codec_1.utf8ToHex(options.function) : options.function);
        const endpoint = (_a = this.abi) == null ? void 0 : _a.getEndpoint(options.function);
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver,
          dataParts,
          gasLimit: options.gasLimit,
          addDataMovementGas: false,
          amount: nativeTransferAmount
        }).build();
      }
      createTransactionForUpgrade(options) {
        const nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        const isUpgradeable = options.isUpgradeable ?? true;
        const isReadable = options.isReadable ?? true;
        const isPayable = options.isPayable ?? false;
        const isPayableBySmartContract = options.isPayableBySmartContract ?? true;
        const args = options.arguments || [];
        const metadata = new smartcontracts_1.CodeMetadata(isUpgradeable, isReadable, isPayable, isPayableBySmartContract);
        const dataParts = ["upgradeContract", utils_codec_1.byteArrayToHex(options.bytecode), metadata.toString()];
        const endpoint = this.getEndpointForUpgrade();
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.contract,
          dataParts,
          gasLimit: options.gasLimit,
          addDataMovementGas: false,
          amount: nativeTransferAmount
        }).build();
      }
      getEndpointForUpgrade() {
        if (!this.abi) {
          return void 0;
        }
        if (this.abi.upgradeConstructorDefinition) {
          return this.abi.upgradeConstructorDefinition;
        }
        try {
          return this.abi.getEndpoint("upgrade");
        } catch (error) {
          logger_1.Logger.warn("In the ABI, cannot find the 'upgrade' endpoint definition. Will use the constructor definition (fallback).");
          return this.abi.constructorDefinition;
        }
      }
      createTransactionForClaimingDeveloperRewards(options) {
        const dataParts = ["ClaimDeveloperRewards"];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.contract,
          dataParts,
          gasLimit: this.config.gasLimitClaimDeveloperRewards,
          addDataMovementGas: false
        }).build();
      }
      createTransactionForChangingOwnerAddress(options) {
        const dataParts = ["ChangeOwnerAddress", address_1.Address.fromBech32(options.newOwner.bech32()).toHex()];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.contract,
          dataParts,
          gasLimit: this.config.gasLimitChangeOwnerAddress,
          addDataMovementGas: false
        }).build();
      }
      argsToDataParts(args, endpoint) {
        if (endpoint) {
          const typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args, endpoint);
          return new smartcontracts_1.ArgSerializer().valuesToStrings(typedArgs);
        }
        if (this.areArgsOfTypedValue(args)) {
          return new smartcontracts_1.ArgSerializer().valuesToStrings(args);
        }
        throw new errors_1.Err("Can't convert args to TypedValues");
      }
      areArgsOfTypedValue(args) {
        return args.every((arg) => typesystem_1.isTyped(arg));
      }
    };
    exports2.SmartContractTransactionsFactory = SmartContractTransactionsFactory;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/smartContract.js
var require_smartContract = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/smartContract.js"(exports2) {
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartContract = void 0;
    var address_1 = require_address();
    var compatibility_1 = require_compatibility();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var smartContractTransactionsFactory_1 = require_smartContractTransactionsFactory();
    var transactionsFactoryConfig_1 = require_transactionsFactoryConfig();
    var utils_1 = require_utils2();
    var codeMetadata_1 = require_codeMetadata();
    var function_1 = require_function();
    var interaction_1 = require_interaction();
    var nativeSerializer_1 = require_nativeSerializer();
    var query_1 = require_query();
    var SmartContract = class {
      /**
       * Create a SmartContract object by providing its address on the Network.
       */
      constructor(options = {}) {
        this.address = address_1.Address.empty();
        this.methodsExplicit = {};
        this.methods = {};
        this.address = options.address || address_1.Address.empty();
        this.abi = options.abi;
        if (this.abi) {
          this.setupMethods();
        }
      }
      setupMethods() {
        let contract = this;
        let abi = this.getAbi();
        for (const definition of abi.getEndpoints()) {
          let functionName = definition.name;
          this.methodsExplicit[functionName] = function(args) {
            let func = new function_1.ContractFunction(functionName);
            let interaction = new interaction_1.Interaction(contract, func, args || []);
            return interaction;
          };
          this.methods[functionName] = function(args) {
            let func = new function_1.ContractFunction(functionName);
            let typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args || [], definition);
            let interaction = new interaction_1.Interaction(contract, func, typedArgs || []);
            return interaction;
          };
        }
      }
      /**
       * Sets the address, as on Network.
       */
      setAddress(address) {
        this.address = address;
      }
      /**
       * Gets the address, as on Network.
       */
      getAddress() {
        return this.address;
      }
      getAbi() {
        utils_1.guardValueIsSet("abi", this.abi);
        return this.abi;
      }
      getEndpoint(name) {
        return this.getAbi().getEndpoint(name);
      }
      /**
       * Creates a {@link Transaction} for deploying the Smart Contract to the Network.
       */
      deploy({ deployer, code, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(deployer, "'deployer' of SmartContract.deploy()", "pass the actual address to deploy()");
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
          config,
          abi: this.abi
        });
        const bytecode = Buffer.from(code.toString(), "hex");
        const metadataAsJson = this.getMetadataPropertiesAsObject(codeMetadata);
        const transaction = factory.createTransactionForDeploy({
          sender: deployer,
          bytecode,
          gasLimit: BigInt(gasLimit.valueOf()),
          arguments: initArguments,
          isUpgradeable: metadataAsJson.upgradeable,
          isReadable: metadataAsJson.readable,
          isPayable: metadataAsJson.payable,
          isPayableBySmartContract: metadataAsJson.payableBySc
        });
        transaction.setChainID(chainID);
        transaction.setValue(value ?? 0);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
      }
      getMetadataPropertiesAsObject(codeMetadata) {
        let metadata;
        if (codeMetadata) {
          metadata = codeMetadata_1.CodeMetadata.fromBytes(Buffer.from(codeMetadata.toString(), "hex"));
        } else {
          metadata = new codeMetadata_1.CodeMetadata();
        }
        const metadataAsJson = metadata.toJSON();
        return metadataAsJson;
      }
      /**
       * Creates a {@link Transaction} for upgrading the Smart Contract on the Network.
       */
      upgrade({ caller, code, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(caller, "'caller' of SmartContract.upgrade()", "pass the actual address to upgrade()");
        this.ensureHasAddress();
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
          config,
          abi: this.abi
        });
        const bytecode = Uint8Array.from(Buffer.from(code.toString(), "hex"));
        const metadataAsJson = this.getMetadataPropertiesAsObject(codeMetadata);
        const transaction = factory.createTransactionForUpgrade({
          sender: caller,
          contract: this.getAddress(),
          bytecode,
          gasLimit: BigInt(gasLimit.valueOf()),
          arguments: initArguments,
          isUpgradeable: metadataAsJson.upgradeable,
          isReadable: metadataAsJson.readable,
          isPayable: metadataAsJson.payable,
          isPayableBySmartContract: metadataAsJson.payableBySc
        });
        transaction.setChainID(chainID);
        transaction.setValue(value ?? 0);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
      }
      /**
       * Creates a {@link Transaction} for calling (a function of) the Smart Contract.
       */
      call({ func, args, value, gasLimit, receiver, gasPrice, chainID, caller }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(caller, "'caller' of SmartContract.call()", "pass the actual address to call()");
        this.ensureHasAddress();
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
          config,
          abi: this.abi
        });
        args = args || [];
        value = value || 0;
        const transaction = factory.createTransactionForExecute({
          sender: caller,
          contract: receiver ? receiver : this.getAddress(),
          function: func.toString(),
          gasLimit: BigInt(gasLimit.valueOf()),
          arguments: args
        });
        transaction.setChainID(chainID);
        transaction.setValue(value);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
      }
      createQuery({ func, args, value, caller }) {
        this.ensureHasAddress();
        return new query_1.Query({
          address: this.getAddress(),
          func,
          args,
          value,
          caller
        });
      }
      ensureHasAddress() {
        if (!this.getAddress().bech32()) {
          throw new errors_1.ErrContractHasNoAddress();
        }
      }
      /**
       * Computes the address of a Smart Contract.
       * The address is computed deterministically, from the address of the owner and the nonce of the deployment transaction.
       *
       * @param owner The owner of the Smart Contract
       * @param nonce The owner nonce used for the deployment transaction
       */
      static computeAddress(owner, nonce) {
        const deployer = address_1.Address.fromBech32(owner.bech32());
        const addressComputer = new address_1.AddressComputer();
        return addressComputer.computeContractAddress(deployer, BigInt(nonce.valueOf()));
      }
    };
    exports2.SmartContract = SmartContract;
  }
});

export {
  require_tokens,
  require_networkParams,
  require_transactionComputer,
  require_transactionPayload,
  require_transaction,
  require_json_bigint,
  require_transactionsFactories,
  require_smartContract,
  require_smartcontracts,
  require_resources,
  require_transactionsConverter
};
//# sourceMappingURL=chunk-UHKY3R7I.js.map
