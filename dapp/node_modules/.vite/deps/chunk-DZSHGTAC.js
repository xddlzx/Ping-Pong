"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  A,
  A2,
  N2 as N,
  T as T2,
  d2 as d,
  d3 as d2,
  f3 as f4,
  i as i2,
  l2 as l4,
  p2,
  p3,
  t2 as t,
  u2 as u4,
  y as y2
} from "./chunk-6OCHV4EV.js";
import {
  f as f5,
  g as g4
} from "./chunk-EN76Z23Y.js";
import {
  bignumber_default
} from "./chunk-LOZL6BFA.js";
import {
  D,
  I,
  m as m2
} from "./chunk-UF3DAKWQ.js";
import {
  f as f3,
  l as l3,
  m,
  x as x2
} from "./chunk-L7SBMHDO.js";
import {
  d as d3
} from "./chunk-KMSODH52.js";
import {
  G,
  o as o2
} from "./chunk-36Z5UFBK.js";
import {
  c as c2,
  u as u5
} from "./chunk-T74HIW6S.js";
import {
  c,
  f as f2,
  g2 as g,
  g3 as g2,
  g4 as g3,
  j2 as j,
  k2 as k,
  l2 as l,
  l3 as l2,
  p4 as p,
  q,
  u3,
  x2 as x,
  y
} from "./chunk-DODOUSNB.js";
import {
  e,
  w
} from "./chunk-TILBIW7H.js";
import {
  H,
  T2 as T,
  U2 as U,
  a3 as a,
  i2 as i,
  require_lib,
  require_out as require_out2,
  u as u2
} from "./chunk-HXV3SQ6S.js";
import {
  f,
  o,
  u
} from "./chunk-EKHLTR53.js";
import {
  Q
} from "./chunk-N7F464ZJ.js";
import {
  Dr,
  Et,
  W,
  v,
  xt,
  yt
} from "./chunk-5CKZHQYH.js";
import {
  require_react
} from "./chunk-IRELMTUJ.js";
import {
  require_out
} from "./chunk-5HSAGO3O.js";
import {
  __toESM,
  require_dist
} from "./chunk-UOCZJ3B4.js";

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-PIZOI42D.js
var import_dist = __toESM(require_dist());
var $;
var m3 = Dr(() => {
  v();
  x();
  $ = (n4) => {
    let t6 = new URLSearchParams(n4).toString(), { pathname: o6, hash: r } = f2(), c9 = t6 ? `?${t6}` : "", i8 = o6 ? `${o6}${c9}${r}` : "./";
    setTimeout(() => {
      window == null || window.history.replaceState({}, document == null ? void 0 : document.title, i8);
    });
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-N4YFXMKQ.js
var import_dist2 = __toESM(require_dist());
var p4;
var y3;
var u6 = Dr(() => {
  v();
  m3();
  e();
  p4 = { search: w() ? window.location.search : "", removeParams: [] }, y3 = (g11, e3 = p4) => {
    var o6;
    let r = {}, P2 = w() ? window.location.search : "", s3 = (o6 = e3.search) != null ? o6 : P2;
    if (s3) {
      let a10 = s3 ? new URLSearchParams(s3) : [];
      r = Object.fromEntries(a10);
    }
    let t6 = {};
    return g11.forEach((a10) => {
      t6[a10] = r[a10], delete r[a10];
    }), e3.removeParams != null && Object.keys(r).forEach((a10) => {
      var n4, c9;
      let [d11] = a10.split("[");
      (((n4 = e3.removeParams) == null ? void 0 : n4.includes(a10)) || ((c9 = e3.removeParams) == null ? void 0 : c9.includes(d11))) && delete r[a10];
    }), { remainingParams: t6, params: r, clearNavigationHistory: () => $(r) };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-P3EO43BR.js
var import_dist3 = __toESM(require_dist());
var import_qs = __toESM(require_lib());
var N2;
var w2 = Dr(() => {
  v();
  m3();
  e();
  u6();
  N2 = ({ removeParams: a10, search: r }) => {
    let n4 = w() ? window.location.search : "", e3 = r != null ? r : n4;
    if (!e3) return {};
    let c9 = import_qs.default.parse(e3.replace("?", "")), l10 = Object.keys(c9).filter((p15) => !a10.includes(p15)), { remainingParams: o6 } = y3(l10, { search: r, removeParams: a10 });
    return $(o6), o6;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-PUOBJCBI.js
var import_dist4 = __toESM(require_dist());
var import_sdk_web_wallet_provider = __toESM(require_out2());
var R;
var i3 = Dr(() => {
  v();
  T();
  w2();
  R = ({ transaction: e3, search: s3 }) => N2({ removeParams: [...Object.keys(e3), import_sdk_web_wallet_provider.WALLET_PROVIDER_CALLBACK_PARAM, H, a], search: s3 });
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-XNFCZFZP.js
var import_dist5 = __toESM(require_dist());
function d4({ tokenId: n4, erdLabel: r }) {
  return Boolean(n4 && n4 !== r);
}
var o3 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-QS2KXUIF.js
var import_dist6 = __toESM(require_dist());
function U2(a10) {
  let e3 = Object.getPrototypeOf(a10).toPlainObject != null ? a10 : D(a10), n4 = xt(yt({}, e3.toPlainObject()), { hash: e3.getHash().hex(), senderUsername: e3.getSenderUsername().valueOf(), receiverUsername: e3.getReceiverUsername().valueOf(), status: "pending" });
  return G({ data: n4.data, onlySetGuardian: true }) && (delete n4.senderUsername, delete n4.receiverUsername), n4;
}
var d5 = Dr(() => {
  v();
  m2();
  Q();
  o2();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-LAFL3AAH.js
var import_dist7 = __toESM(require_dist());
function g6(t6, e3) {
  let n4 = new URLSearchParams(t6), r = Object.fromEntries(n4);
  return { nextUrlParams: new URLSearchParams(yt(yt({}, r), e3)).toString(), params: r };
}
function x3({ callbackUrl: t6, urlParams: e3 = {} }) {
  let n4 = t6;
  if (Object.entries(e3).length > 0) try {
    let { search: r, origin: a10, pathname: l10, hash: m8 } = new URL(t6), u16 = xt(yt({}, e3), { [a]: p5 }), { nextUrlParams: U3 } = g6(r, u16);
    n4 = `${a10}${l10}?${U3}${m8}`;
  } catch (r) {
    return console.error("Unable to construct URL from: ", t6, r), n4;
  }
  return n4;
}
var p5;
var y4 = Dr(() => {
  v();
  T();
  p5 = "3.1.6";
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-3WKKYGRU.js
var import_dist8 = __toESM(require_dist());
var h;
var A3;
var l5 = Dr(() => {
  v();
  T();
  h = (r) => {
    let e3 = W.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    if (r.slice(0, e3.length).equals(e3)) return true;
    let s3 = W.Buffer.alloc(32).fill(0);
    return r.equals(s3);
  }, A3 = (r) => {
    try {
      let a10 = parseInt("11", 2), s3 = parseInt("01", 2), o6 = W.Buffer.from(r, "hex"), c9 = o6[31];
      if (h(o6)) return i;
      let n4 = c9 & a10;
      return n4 > 3 - 1 && (n4 = c9 & s3), n4;
    } catch (e3) {
      return -1;
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-GNQ52MZT.js
var import_dist9 = __toESM(require_dist());
var import_out = __toESM(require_out());
function T3({ receiverAddress: i8, senderShard: e3, senderAddress: s3 }) {
  try {
    let n4 = new import_out.Address(i8), t6 = A3(n4.pubkey());
    if (e3 == null && s3 != null) {
      let c9 = new import_out.Address(s3);
      return A3(c9) === t6;
    }
    return t6 === e3;
  } catch (n4) {
    return false;
  }
}
var u7 = Dr(() => {
  v();
  l5();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-YOYRVDJG.js
var import_dist10 = __toESM(require_dist());
var y5;
var p6 = Dr(() => {
  v();
  u7();
  N();
  y5 = (e3, u16 = 1) => e3 != null && e3.length ? e3.reduce((n4, { receiver: m8, data: r }) => {
    let o6 = A2({ receiver: m8, data: r != null ? r : "" });
    return o6 == null ? n4 : n4 && T3({ receiverAddress: o6, senderShard: u16 });
  }, true) : true;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-VSPND6ZN.js
var import_dist11 = __toESM(require_dist());
var import_react = __toESM(require_react());
var h2;
var m4 = Dr(() => {
  v();
  f();
  h2 = ["create", "localMint", "ESDTLocalMint", "addQuantity", "burn", "localBurn", "ESDTLocalBurn", "wipe", "writeLog", "signalError"];
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-NLU2B6MT.js
var import_dist12 = __toESM(require_dist());
var c4;
var l6 = Dr(() => {
  v();
  c4 = (t6, g11 = 4) => `${t6.substring(0, Math.floor(t6.length / g11))}...${t6.substring(t6.length - Math.ceil(t6.length / g11))}`;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-AQQ7Q6DO.js
var import_dist13 = __toESM(require_dist());
var y6;
var p7 = Dr(() => {
  v();
  f();
  y6 = (r) => {
    var e3, n4;
    switch (r.name) {
      case "transfer":
        return ["Transfer", { token: (e3 = r.arguments) == null ? void 0 : e3.transfers }, "to", { address: (n4 = r.arguments) == null ? void 0 : n4.receiver }];
      default:
        return [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-2W6QR4IJ.js
var import_dist14 = __toESM(require_dist());
var C;
var A4 = Dr(() => {
  v();
  T();
  f();
  C = (e3) => {
    var r, s3, t6, a10, n4, i8, u16, m8, o6, d11, p15, c9;
    switch (e3.name) {
      case "claimLockedAssets":
        return ["Claim locked assets"];
      case "enterFarm":
      case "enterFarmProxy":
        return ["Enter farm with", { token: (r = e3.arguments) == null ? void 0 : r.transfers }];
      case "enterFarmAndLockRewards":
      case "enterFarmAndLockRewardsProxy":
        return ["Enter farm and lock rewards with", { token: (s3 = e3.arguments) == null ? void 0 : s3.transfers }];
      case "exitFarm":
      case "exitFarmProxy":
        return ["Exit farm with", { token: (t6 = e3.arguments) == null ? void 0 : t6.transfers }];
      case "claimRewards":
      case "claimRewardsProxy":
        return ["Claim rewards", { token: (a10 = e3.arguments) == null ? void 0 : a10.transfers }];
      case "compoundRewards":
      case "compoundRewardsProxy":
        return ["Reinvest rewards", { token: (n4 = e3.arguments) == null ? void 0 : n4.transfers }];
      case "swapTokensFixedInput":
      case "swap":
        return e3.description ? [e3.description] : [];
      case "swapTokensFixedOutput":
        return e3.description ? [e3.description] : [];
      case "addLiquidity":
      case "addLiquidityProxy":
        return ["Added liquidity for", { token: [(i8 = e3.arguments) == null ? void 0 : i8.transfers[0]] }, "and", { token: [(u16 = e3.arguments) == null ? void 0 : u16.transfers[1]] }];
      case "removeLiquidity":
      case "removeLiquidityProxy":
        return ["Removed liquidity with ", { token: (m8 = e3.arguments) == null ? void 0 : m8.transfers }];
      case "mergeLockedAssetTokens":
        let f17 = u2;
        if ((o6 = e3.arguments) != null && o6.transfers) {
          let w6 = e3.arguments.transfers.map(({ value: k5 }) => k5);
          f17 = bignumber_default.sum.apply(null, w6).toString(10);
        }
        return [`Merge ${(d11 = e3.arguments) == null ? void 0 : d11.transfers.length}`, { tokenNoLink: [(p15 = e3.arguments) == null ? void 0 : p15.transfers[0]] }, "positions into a single", { tokenNoLink: [(c9 = e3.arguments) == null ? void 0 : c9.transfers[0]] }, "position of value", { value: f17 }];
      case "wrapEgld":
      case "unwrapEgld":
      default:
        return e3.description ? [e3.description] : [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-LHJJDJM4.js
var import_dist15 = __toESM(require_dist());
var D2;
var w3 = Dr(() => {
  v();
  f();
  D2 = (r) => {
    var e3, a10, t6, d11, p15, s3, v4, m8, i8, n4, o6, g11;
    switch (r.name) {
      case "delegate":
      case "stake":
        return ["Delegate", { egldValue: (e3 = r.arguments) == null ? void 0 : e3.value }, "to staking provider", { providerName: (a10 = r.arguments) == null ? void 0 : a10.providerName, providerAvatar: (t6 = r.arguments) == null ? void 0 : t6.providerAvatar }];
      case "unDelegate":
        return ["Undelegate", { egldValue: (d11 = r.arguments) == null ? void 0 : d11.value }, "from staking provider", { providerName: (p15 = r.arguments) == null ? void 0 : p15.providerName, providerAvatar: (s3 = r.arguments) == null ? void 0 : s3.providerAvatar }];
      case "claimRewards":
        return ["Claim rewards from staking provider", { providerName: (v4 = r.arguments) == null ? void 0 : v4.providerName, providerAvatar: (m8 = r.arguments) == null ? void 0 : m8.providerAvatar }];
      case "reDelegateRewards":
        return ["Redelegate rewards from staking provider", { providerName: (i8 = r.arguments) == null ? void 0 : i8.providerName, providerAvatar: (n4 = r.arguments) == null ? void 0 : n4.providerAvatar }];
      case "withdraw":
        return ["Withdraw from staking provider", { providerName: (o6 = r.arguments) == null ? void 0 : o6.providerName, providerAvatar: (g11 = r.arguments) == null ? void 0 : g11.providerAvatar }];
      default:
        return [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-SSUUG5BL.js
var import_dist16 = __toESM(require_dist());
var k2;
var c5 = Dr(() => {
  v();
  f();
  p7();
  A4();
  w3();
  k2 = (r) => {
    if (!r.arguments) return r.description ? [r.description] : [r.name];
    switch (r.category) {
      case "esdtNft":
        return y6(r);
      case "mex":
        return C(r);
      case "stake":
        return D2(r);
      default:
        return r.description ? [r.description] : [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OY7P7YMY.js
var import_dist17 = __toESM(require_dist());
var f7 = Dr(() => {
  v();
  c5();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BZYEY4V6.js
var import_dist18 = __toESM(require_dist());
var u8;
var i4 = Dr(() => {
  v();
  u8 = (e3) => {
    let n4 = new bignumber_default(e3.gasPrice), o6 = new bignumber_default(e3.gasUsed);
    return n4.times(o6).toString();
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-KCK6EIJZ.js
var import_dist19 = __toESM(require_dist());
var S;
var L = Dr(() => {
  v();
  u();
  S = ({ transaction: e3, direction: n4 }) => {
    var a10;
    let T5 = n4 === "Internal", r = e3.sender;
    if (T5) return { link: (a10 = e3.links.senderLink) != null ? a10 : "", label: "Smart Contract transaction", address: r };
    let i8 = n4 === "Out", t6 = i8 ? e3.links.receiverLink : e3.links.senderLink, s3 = "";
    return n4 === "Self" && e3.receiverAssets ? s3 = e3.receiverAssets.name : (r = i8 ? e3.receiver : e3.sender, s3 = i8 ? "To:" : "From:"), { label: s3, address: r, link: t6 != null ? t6 : "" };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-POG6DTE2.js
var import_dist20 = __toESM(require_dist());
var p8;
var a3 = Dr(() => {
  v();
  Q();
  p8 = (t6) => {
    switch (true) {
      case t6.pendingResults:
        return "Pending (Smart Contract Execution)";
      case t6.status === "reward-reverted":
        return "fail";
      default:
        return t6.status.toString();
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-XK4XOW72.js
var import_dist21 = __toESM(require_dist());
var n;
var o4 = Dr(() => {
  v();
  n = (a10) => W.Buffer.from(String(a10 == null ? void 0 : a10.data), "base64").toString("hex");
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-KLFPAZSS.js
var import_dist22 = __toESM(require_dist());
var u9;
var p9 = Dr(() => {
  v();
  c();
  u9 = (n4, h7) => {
    var e3;
    let { hash: i8 } = f2(), t6 = i8.split("/"), s3 = t6[0] ? t6[0].replace("#", "") : "", g11 = (e3 = t6[1]) != null ? e3 : 0;
    return s3 === h7 && n4.order === Number(g11);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4K4XSAZL.js
var import_dist23 = __toESM(require_dist());
var u10;
var d6 = Dr(() => {
  v();
  f();
  u10 = ({ operation: t6, address: r }) => {
    let i8 = r === t6.sender, n4 = r === t6.receiver, c9 = i8 && n4, a10 = !c9, e3 = "";
    switch (true) {
      case i8:
        e3 = "Out";
        break;
      case n4:
        e3 = "In";
        break;
      case c9:
        e3 = "Self";
        break;
      case a10:
        e3 = "Internal";
        break;
    }
    return { direction: e3 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OF3VHHUR.js
var import_dist24 = __toESM(require_dist());
var d7;
var a4 = Dr(() => {
  v();
  f3();
  d7 = (s3) => {
    let t6 = W.Buffer.from(s3, "base64").toString().split("@");
    return t6.length >= 2 && (t6[0].length > 0 ? t6[0] = m(t6[0]) : t6[1] = m(t6[1])), t6.join("@");
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-JW7ZCUB4.js
var import_dist25 = __toESM(require_dist());
var f8;
var s = Dr(() => {
  v();
  c();
  f8 = (e3) => {
    let { hash: t6 } = f2();
    return t6.substring(0, t6.indexOf("/") > 0 ? t6.indexOf("/") : t6.length).replace("#", "") === e3;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-F5247DFI.js
var import_dist26 = __toESM(require_dist());
var A5;
var g7 = Dr(() => {
  v();
  T();
  A5 = (e3) => {
    let t6 = e3;
    typeof t6 == "string" && t6.includes("Shard") && (t6 = t6.replace("Shard", "").replace(" ", ""));
    let S6 = i.toString() === String(t6).toString() || String(t6) === "metachain", a10 = U.toString() === String(t6).toString();
    return S6 ? "Metachain" : a10 ? "All Shards" : `Shard ${t6}`;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4YKO7ZRM.js
var import_dist27 = __toESM(require_dist());
function d8(e3) {
  return Array.from(/* @__PURE__ */ new Set([...p2(e3), ...f4(e3), A(e3)])).filter((a10) => Boolean(a10));
}
var m5 = Dr(() => {
  v();
  i2();
  l4();
  t();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-Z6MQL4VU.js
var import_dist28 = __toESM(require_dist());
function m6(e3) {
  let t6 = (i8) => e3.status.toLowerCase() === i8.toLowerCase(), s3 = t6("fail") || t6("reward-reverted"), r = t6("success"), o6 = t6("not executed") || t6("invalid"), a10 = t6("pending") || e3.pendingResults;
  return { failed: s3, success: r, invalid: o6, pending: a10 };
}
var u11 = Dr(() => {
  v();
  Q();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-DBZ3PT4K.js
var import_dist29 = __toESM(require_dist());
var import_react2 = __toESM(require_react());
var S2;
var f9 = Dr(() => {
  v();
  u();
  c();
  S2 = () => {
    let { hash: r, pathname: o6 } = f2(), t6 = r.replace("#", ""), s3 = t6 && Object.values(o).includes(t6) ? t6 : "raw", [e3, a10] = (0, import_react2.useState)(t6);
    return (0, import_react2.useEffect)(() => {
      e3 && e3 !== "raw" && (window == null || window.history.replaceState({}, document == null ? void 0 : document.title, `${o6}#${e3}`));
    }, [e3, o6]), { initialDecodeMethod: s3, decodeMethod: e3, setDecodeMethod: a10 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZRD6IVNQ.js
var import_dist31 = __toESM(require_dist());

// node_modules/linkifyjs/dist/linkify.es.js
var import_dist30 = __toESM(require_dist());
var tlds = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kids kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum music mutual mv mw mx my mz na nab nagoya name natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest racing radio re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign vermgensberater vermgensberatung versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw".split(" ");
var utlds = "                                                                                                                                                      ".split(" ");
var assign = function assign2(target, properties) {
  for (var key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t6, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (var k5 in flags) {
    var group = registerGroup(k5, groups);
    if (group.indexOf(t6) < 0) {
      group.push(t6);
    }
  }
}
function flagsForToken(t6, groups) {
  var result = {};
  for (var c9 in groups) {
    if (groups[c9].indexOf(t6) >= 0) {
      result[c9] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go: function go(input) {
    var state = this;
    var nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (var i8 = 0; i8 < state.jr.length; i8++) {
      var regex = state.jr[i8][0];
      var _nextState = state.jr[i8][1];
      if (_nextState && regex.test(input)) {
        return _nextState;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has: function has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta: function ta(inputs, next, flags, groups) {
    for (var i8 = 0; i8 < inputs.length; i8++) {
      this.tt(inputs[i8], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr: function tr(regexp2, next, flags, groups) {
    groups = groups || State.groups;
    var nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp2, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts: function ts(input, next, flags, groups) {
    var state = this;
    var len = input.length;
    if (!len) {
      return state;
    }
    for (var i8 = 0; i8 < len - 1; i8++) {
      state = state.tt(input[i8]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt: function tt(input, next, flags, groups) {
    groups = groups || State.groups;
    var state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    var t6 = next;
    var nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t6) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          var allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t6, allFlags, groups);
        } else if (flags) {
          addToGroups(t6, flags, groups);
        }
      }
      nextState.t = t6;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta2 = function ta3(state, input, next, flags, groups) {
  return state.ta(input, next, flags, groups);
};
var tr2 = function tr3(state, regexp2, next, flags, groups) {
  return state.tr(regexp2, next, flags, groups);
};
var ts2 = function ts3(state, input, next, flags, groups) {
  return state.ts(input, next, flags, groups);
};
var tt2 = function tt3(state, input, next, flags, groups) {
  return state.tt(input, next, flags, groups);
};
var WORD = "WORD";
var UWORD = "UWORD";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL$1 = "NL";
var OPENBRACE = "OPENBRACE";
var OPENBRACKET = "OPENBRACKET";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEBRACE = "CLOSEBRACE";
var CLOSEBRACKET = "CLOSEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var CLOSEPAREN = "CLOSEPAREN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL: NL$1,
  OPENBRACE,
  OPENBRACKET,
  OPENANGLEBRACKET,
  OPENPAREN,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEANGLEBRACKET,
  CLOSEPAREN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/;
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/;
var EMOJI_VARIATION$1 = /\ufe0f/;
var DIGIT = /\d/;
var SPACE = /\s/;
var regexp = Object.freeze({
  __proto__: null,
  ASCII_LETTER,
  LETTER,
  EMOJI,
  EMOJI_VARIATION: EMOJI_VARIATION$1,
  DIGIT,
  SPACE
});
var NL = "\n";
var EMOJI_VARIATION = "";
var EMOJI_JOINER = "";
function init$2(customSchemes) {
  var _tr, _tr2, _tr3, _tr4, _tt, _tr5;
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  var groups = {};
  State.groups = groups;
  var Start = new State();
  tt2(Start, "'", APOSTROPHE);
  tt2(Start, "{", OPENBRACE);
  tt2(Start, "[", OPENBRACKET);
  tt2(Start, "<", OPENANGLEBRACKET);
  tt2(Start, "(", OPENPAREN);
  tt2(Start, "}", CLOSEBRACE);
  tt2(Start, "]", CLOSEBRACKET);
  tt2(Start, ">", CLOSEANGLEBRACKET);
  tt2(Start, ")", CLOSEPAREN);
  tt2(Start, "&", AMPERSAND);
  tt2(Start, "*", ASTERISK);
  tt2(Start, "@", AT);
  tt2(Start, "`", BACKTICK);
  tt2(Start, "^", CARET);
  tt2(Start, ":", COLON);
  tt2(Start, ",", COMMA);
  tt2(Start, "$", DOLLAR);
  tt2(Start, ".", DOT);
  tt2(Start, "=", EQUALS);
  tt2(Start, "!", EXCLAMATION);
  tt2(Start, "-", HYPHEN);
  tt2(Start, "%", PERCENT);
  tt2(Start, "|", PIPE);
  tt2(Start, "+", PLUS);
  tt2(Start, "#", POUND);
  tt2(Start, "?", QUERY);
  tt2(Start, '"', QUOTE);
  tt2(Start, "/", SLASH);
  tt2(Start, ";", SEMI);
  tt2(Start, "~", TILDE);
  tt2(Start, "_", UNDERSCORE);
  tt2(Start, "\\", BACKSLASH);
  var Num = tr2(Start, DIGIT, NUM, (_tr = {}, _tr[numeric] = true, _tr));
  tr2(Num, DIGIT, Num);
  var Word = tr2(Start, ASCII_LETTER, WORD, (_tr2 = {}, _tr2[ascii] = true, _tr2));
  tr2(Word, ASCII_LETTER, Word);
  var UWord = tr2(Start, LETTER, UWORD, (_tr3 = {}, _tr3[alpha] = true, _tr3));
  tr2(UWord, ASCII_LETTER);
  tr2(UWord, LETTER, UWord);
  var Ws = tr2(Start, SPACE, WS, (_tr4 = {}, _tr4[whitespace] = true, _tr4));
  tt2(Start, NL, NL$1, (_tt = {}, _tt[whitespace] = true, _tt));
  tt2(Ws, NL);
  tr2(Ws, SPACE, Ws);
  var Emoji = tr2(Start, EMOJI, EMOJI$1, (_tr5 = {}, _tr5[emoji] = true, _tr5));
  tr2(Emoji, EMOJI, Emoji);
  tt2(Emoji, EMOJI_VARIATION, Emoji);
  var EmojiJoiner = tt2(Emoji, EMOJI_JOINER);
  tr2(EmojiJoiner, EMOJI, Emoji);
  var wordjr = [[ASCII_LETTER, Word]];
  var uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (var i8 = 0; i8 < tlds.length; i8++) {
    fastts(Start, tlds[i8], TLD, WORD, wordjr);
  }
  for (var _i = 0; _i < utlds.length; _i++) {
    fastts(Start, utlds[_i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort(function(a10, b) {
    return a10[0] > b[0] ? 1 : -1;
  });
  for (var _i2 = 0; _i2 < customSchemes.length; _i2++) {
    var _ref, _ref2;
    var sch = customSchemes[_i2][0];
    var optionalSlashSlash = customSchemes[_i2][1];
    var flags = optionalSlashSlash ? (_ref = {}, _ref[scheme] = true, _ref) : (_ref2 = {}, _ref2[slashscheme] = true, _ref2);
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts2(Start, sch, sch, flags);
  }
  ts2(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  var iterable = stringToArray(str.replace(/[A-Z]/g, function(c9) {
    return c9.toLowerCase();
  }));
  var charCount = iterable.length;
  var tokens = [];
  var cursor = 0;
  var charCursor = 0;
  while (charCursor < charCount) {
    var state = start;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  var result = [];
  var len = str.length;
  var index = 0;
  while (index < len) {
    var first = str.charCodeAt(index);
    var second = void 0;
    var char = first < 55296 || first > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t6, defaultt, jr) {
  var next;
  var len = input.length;
  for (var i8 = 0; i8 < len - 1; i8++) {
    var char = input[i8];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t6);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o6, p15) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o7, p16) {
    o7.__proto__ = p16;
    return o7;
  };
  return _setPrototypeOf(o6, p15);
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender2) {
  if (defaultRender2 === void 0) {
    defaultRender2 = null;
  }
  var o6 = assign({}, defaults);
  if (opts) {
    o6 = assign(o6, opts instanceof Options ? opts.o : opts);
  }
  var ignoredTags = o6.ignoreTags;
  var uppercaseIgnoredTags = [];
  for (var i8 = 0; i8 < ignoredTags.length; i8++) {
    uppercaseIgnoredTags.push(ignoredTags[i8].toUpperCase());
  }
  this.o = o6;
  if (defaultRender2) {
    this.defaultRender = defaultRender2;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender: function defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check: function check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get: function get(key, operator, token) {
    var isCallable = operator != null;
    var option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj: function getObj(key, operator, token) {
    var obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render: function render(token) {
    var ir = token.render(this);
    var renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop(val) {
  return val;
}
var options = Object.freeze({
  __proto__: null,
  defaults,
  Options,
  assign
});
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString: function toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref: function toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString: function toFormattedString(options2) {
    var val = this.toString();
    var truncate = options2.get("truncate", val, this);
    var formatted = options2.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref: function toFormattedHref(options2) {
    return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject: function toObject(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject: function toFormattedObject(options2) {
    return {
      type: this.t,
      value: this.toFormattedString(options2),
      isLink: this.isLink,
      href: this.toFormattedHref(options2),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate: function validate(options2) {
    return options2.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render: function render2(options2) {
    var token = this;
    var href = this.toFormattedHref(options2);
    var tagName = options2.get("tagName", href, token);
    var content = this.toFormattedString(options2);
    var attributes = {};
    var className = options2.get("className", href, token);
    var target = options2.get("target", href, token);
    var rel = options2.get("rel", href, token);
    var attrs = options2.getObj("attributes", href, token);
    var eventListeners = options2.getObj("events", href, token);
    attributes.href = href;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  var Token = function(_MultiToken) {
    _inheritsLoose(Token2, _MultiToken);
    function Token2(value, tokens) {
      var _this;
      _this = _MultiToken.call(this, value, tokens) || this;
      _this.t = type;
      return _this;
    }
    return Token2;
  }(MultiToken);
  for (var p15 in props) {
    Token.prototype[p15] = props[p15];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref: function toHref2() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref: function toHref3(scheme2) {
    if (scheme2 === void 0) {
      scheme2 = defaults.defaultProtocol;
    }
    return this.hasProtocol() ? this.v : scheme2 + "://" + this.v;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol: function hasProtocol() {
    var tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var multi = Object.freeze({
  __proto__: null,
  MultiToken,
  Base: MultiToken,
  createTokenClass,
  Email,
  Text,
  Nl,
  Url
});
var makeState = function makeState2(arg) {
  return new State(arg);
};
function init$1(_ref) {
  var groups = _ref.groups;
  var qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  var Start = makeState();
  var Localpart = tt2(Start, TILDE);
  ta2(Localpart, localpartAccepting, Localpart);
  ta2(Localpart, groups.domain, Localpart);
  var Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta2(Start, groups.domain, Domain);
  ta2(Start, groups.scheme, Scheme);
  ta2(Start, groups.slashscheme, SlashScheme);
  ta2(Domain, localpartAccepting, Localpart);
  ta2(Domain, groups.domain, Domain);
  var LocalpartAt = tt2(Domain, AT);
  tt2(Localpart, AT, LocalpartAt);
  var LocalpartDot = tt2(Localpart, DOT);
  ta2(LocalpartDot, localpartAccepting, Localpart);
  ta2(LocalpartDot, groups.domain, Localpart);
  var EmailDomain = makeState();
  ta2(LocalpartAt, groups.domain, EmailDomain);
  ta2(EmailDomain, groups.domain, EmailDomain);
  var EmailDomainDot = tt2(EmailDomain, DOT);
  ta2(EmailDomainDot, groups.domain, EmailDomain);
  var Email$1 = makeState(Email);
  ta2(EmailDomainDot, groups.tld, Email$1);
  ta2(EmailDomainDot, groups.utld, Email$1);
  tt2(LocalpartAt, LOCALHOST, Email$1);
  var EmailDomainHyphen = tt2(EmailDomain, HYPHEN);
  ta2(EmailDomainHyphen, groups.domain, EmailDomain);
  ta2(Email$1, groups.domain, EmailDomain);
  tt2(Email$1, DOT, EmailDomainDot);
  tt2(Email$1, HYPHEN, EmailDomainHyphen);
  var EmailColon = tt2(Email$1, COLON);
  ta2(EmailColon, groups.numeric, Email);
  var DomainHyphen = tt2(Domain, HYPHEN);
  var DomainDot = tt2(Domain, DOT);
  ta2(DomainHyphen, groups.domain, Domain);
  ta2(DomainDot, localpartAccepting, Localpart);
  ta2(DomainDot, groups.domain, Domain);
  var DomainDotTld = makeState(Url);
  ta2(DomainDot, groups.tld, DomainDotTld);
  ta2(DomainDot, groups.utld, DomainDotTld);
  ta2(DomainDotTld, groups.domain, Domain);
  ta2(DomainDotTld, localpartAccepting, Localpart);
  tt2(DomainDotTld, DOT, DomainDot);
  tt2(DomainDotTld, HYPHEN, DomainHyphen);
  tt2(DomainDotTld, AT, LocalpartAt);
  var DomainDotTldColon = tt2(DomainDotTld, COLON);
  var DomainDotTldColonPort = makeState(Url);
  ta2(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  var Url$1 = makeState(Url);
  var UrlNonaccept = makeState();
  ta2(Url$1, qsAccepting, Url$1);
  ta2(Url$1, qsNonAccepting, UrlNonaccept);
  ta2(UrlNonaccept, qsAccepting, Url$1);
  ta2(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt2(DomainDotTld, SLASH, Url$1);
  tt2(DomainDotTldColonPort, SLASH, Url$1);
  var UriPrefix = tt2(Scheme, COLON);
  var SlashSchemeColon = tt2(SlashScheme, COLON);
  var SlashSchemeColonSlash = tt2(SlashSchemeColon, SLASH);
  tt2(SlashSchemeColonSlash, SLASH, UriPrefix);
  ta2(Scheme, groups.domain, Domain);
  tt2(Scheme, DOT, DomainDot);
  tt2(Scheme, HYPHEN, DomainHyphen);
  ta2(SlashScheme, groups.domain, Domain);
  tt2(SlashScheme, DOT, DomainDot);
  tt2(SlashScheme, HYPHEN, DomainHyphen);
  ta2(UriPrefix, groups.domain, Url$1);
  tt2(UriPrefix, SLASH, Url$1);
  var UrlOpenbrace = tt2(Url$1, OPENBRACE);
  var UrlOpenbracket = tt2(Url$1, OPENBRACKET);
  var UrlOpenanglebracket = tt2(Url$1, OPENANGLEBRACKET);
  var UrlOpenparen = tt2(Url$1, OPENPAREN);
  tt2(UrlNonaccept, OPENBRACE, UrlOpenbrace);
  tt2(UrlNonaccept, OPENBRACKET, UrlOpenbracket);
  tt2(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);
  tt2(UrlNonaccept, OPENPAREN, UrlOpenparen);
  tt2(UrlOpenbrace, CLOSEBRACE, Url$1);
  tt2(UrlOpenbracket, CLOSEBRACKET, Url$1);
  tt2(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);
  tt2(UrlOpenparen, CLOSEPAREN, Url$1);
  tt2(UrlOpenbrace, CLOSEBRACE, Url$1);
  var UrlOpenbraceQ = makeState(Url);
  var UrlOpenbracketQ = makeState(Url);
  var UrlOpenanglebracketQ = makeState(Url);
  var UrlOpenparenQ = makeState(Url);
  ta2(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);
  ta2(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparen, qsAccepting, UrlOpenparenQ);
  var UrlOpenbraceSyms = makeState();
  var UrlOpenbracketSyms = makeState();
  var UrlOpenanglebracketSyms = makeState();
  var UrlOpenparenSyms = makeState();
  ta2(UrlOpenbrace, qsNonAccepting);
  ta2(UrlOpenbracket, qsNonAccepting);
  ta2(UrlOpenanglebracket, qsNonAccepting);
  ta2(UrlOpenparen, qsNonAccepting);
  ta2(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);
  ta2(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);
  ta2(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);
  ta2(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);
  ta2(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);
  ta2(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);
  ta2(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);
  ta2(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);
  ta2(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);
  ta2(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);
  tt2(UrlOpenbracketQ, CLOSEBRACKET, Url$1);
  tt2(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);
  tt2(UrlOpenparenQ, CLOSEPAREN, Url$1);
  tt2(UrlOpenbraceQ, CLOSEBRACE, Url$1);
  tt2(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);
  tt2(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);
  tt2(UrlOpenparenSyms, CLOSEPAREN, Url$1);
  tt2(UrlOpenbraceSyms, CLOSEPAREN, Url$1);
  tt2(Start, LOCALHOST, DomainDotTld);
  tt2(Start, NL$1, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run(start, input, tokens) {
  var len = tokens.length;
  var cursor = 0;
  var multis = [];
  var textTokens = [];
  while (cursor < len) {
    var state = start;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (var i8 = 0; i8 < INIT.tokenQueue.length; i8++) {
    INIT.tokenQueue[i8][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (var _i = 0; _i < INIT.pluginQueue.length; _i++) {
    INIT.pluginQueue[_i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && typeof type === "object") {
    if (opts) {
      throw Error("linkifyjs: Invalid link type " + type + "; must be a string");
    }
    opts = type;
    type = null;
  }
  var options2 = new Options(opts);
  var tokens = tokenize(str);
  var filtered = [];
  for (var i8 = 0; i8 < tokens.length; i8++) {
    var token = tokens[i8];
    if (token.isLink && (!type || token.t === type)) {
      filtered.push(token.toFormattedObject(options2));
    }
  }
  return filtered;
}

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZRD6IVNQ.js
var a5;
var T4;
var h3 = Dr(() => {
  v();
  a5 = (s3) => {
    let i8 = find(s3);
    if (!i8.length) return { textWithLinks: s3, hasLinks: false };
    let e3 = s3;
    for (let t6 of i8) {
      let n4 = s3.substring(t6.start, t6.end);
      e3 = e3.replace(n4, t6.value);
    }
    return { textWithLinks: e3, hasLinks: true };
  }, T4 = ({ message: s3, scamInfo: i8, isNsfw: e3, verified: t6, messagePrefix: n4 = "Message hidden due to suspicious content - " }) => {
    var o6;
    if (t6) return { message: "", textWithLinks: "", isSuspicious: false };
    let k5 = `${n4}${(o6 = i8 == null ? void 0 : i8.info) != null ? o6 : "suspicious content"}`, { textWithLinks: u16, hasLinks: c9 } = a5(s3);
    return c9 || e3 || i8 ? { message: k5, textWithLinks: u16, isSuspicious: true } : { message: "", textWithLinks: u16, isSuspicious: false };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BI7MFSOQ.js
var import_dist32 = __toESM(require_dist());
var a6;
var i5;
var h4;
var o5 = Dr(() => {
  v();
  a6 = (n4) => n4.toLowerCase().match(/^[0-9a-f]+$/i), i5 = (n4) => n4.length % 2 === 0, h4 = (n4) => {
    let e3 = [];
    return n4 && !a6(n4) && e3.push(`Invalid Hex characters on argument @${n4}`), n4 && !i5(n4) && e3.push(`Odd number of Hex characters on argument @${n4}`), e3;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4GKSQE2H.js
var import_dist33 = __toESM(require_dist());
var import_out2 = __toESM(require_out());
var A6;
var x4 = Dr(() => {
  v();
  f();
  f5();
  x2();
  A6 = (e3, m8, r) => {
    switch (m8) {
      case "text":
        try {
          return W.Buffer.from(e3, "hex").toString("utf8");
        } catch (t6) {
        }
        return e3;
      case "decimal":
        return e3 !== "" ? new bignumber_default(e3, 16).toString(10) : "";
      case "smart":
        try {
          let t6 = import_out2.Address.fromHex(e3).toString();
          if (g4(t6)) return t6;
        } catch (t6) {
        }
        try {
          let t6 = W.Buffer.from(e3, "hex").toString("utf8");
          if (l3(t6)) return t6;
          {
            if (r && [...r.esdts, ...r.nfts].some((f17) => t6.includes(f17))) return t6;
            let n4 = new bignumber_default(e3, 16);
            return n4.isFinite() ? n4.toString(10) : e3;
          }
        } catch (t6) {
        }
        return e3;
      case "raw":
      default:
        return e3;
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4DAANLRO.js
var import_dist34 = __toESM(require_dist());
var p11;
var f10 = Dr(() => {
  v();
  u();
  x4();
  p11 = ({ parts: e3, decodedParts: n4, identifier: i8 }) => {
    let r = [...n4];
    if (e3[0] === "ESDTNFTTransfer" && e3[2] && (r[2] = A6(e3[2], "decimal")), i8 === "ESDTNFTTransfer" && e3[1]) {
      let a10 = W.Buffer.from(String(e3[1]), "base64");
      r[1] = A6(a10.toString("hex"), "decimal");
    }
    return r;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-MVXGMWHA.js
var import_dist35 = __toESM(require_dist());
var M;
var u13 = Dr(() => {
  v();
  u();
  x4();
  o5();
  f10();
  M = ({ parts: t6, decodeMethod: n4, identifier: g11, display: d11 }) => {
    let r = t6.map((e3, a10) => {
      if (t6.length >= 2 && (a10 === 0 && e3.length < 64 || a10 === 1 && !t6[0])) return /[^a-z0-9]/gi.test(e3) ? A6(e3, n4) : e3;
      {
        let o6 = h4(e3);
        return o6.length && (d11.validationWarnings = Array.from(/* @__PURE__ */ new Set([...d11.validationWarnings, ...o6]))), A6(e3, n4);
      }
    });
    return n4 === "smart" ? p11({ parts: t6, decodedParts: r, identifier: g11 }) : r;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-3G2HCPRQ.js
var import_dist36 = __toESM(require_dist());
var t2 = Dr(() => {
  v();
  x4();
  u13();
  o5();
  f10();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-6P2POR4F.js
var import_dist37 = __toESM(require_dist());
var B;
var P = Dr(() => {
  v();
  f();
  t2();
  B = ({ input: s3, decodeMethod: a10, identifier: d11 }) => {
    let e3 = { displayValue: "", validationWarnings: [] };
    if (!s3.includes("@") && !s3.includes(`
`)) return e3.displayValue = A6(s3, a10), e3;
    if (s3.includes("@")) {
      let r = s3.split("@"), o6 = M({ parts: r, identifier: d11, decodeMethod: a10, display: e3 });
      e3.displayValue = o6.join("@");
    }
    if (s3.includes(`
`)) {
      let r = s3.split(`
`), o6 = r.map((l10) => {
        let D5 = W.Buffer.from(l10, "base64");
        return a10 === "raw" ? l10 : A6(D5.toString("hex"), a10);
      }), y8 = a10 === "smart" ? p11({ parts: r, decodedParts: o6, identifier: d11 }) : o6;
      e3.displayValue = y8.join(`
`);
    }
    return e3;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-KN6D65Z4.js
var import_dist38 = __toESM(require_dist());
var f11 = Dr(() => {
  v();
  P();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-NUDS6AEB.js
var import_dist39 = __toESM(require_dist());
var import_react3 = __toESM(require_react());
var f12;
var M2;
var g8 = Dr(() => {
  v();
  u();
  f11();
  f12 = [{ label: "Raw", value: "raw" }, { label: "Text", value: "text" }, { label: "Decimal", value: "decimal" }, { label: "Smart", value: "smart" }], M2 = ({ value: c9, initialDecodeMethod: e3, setDecodeMethod: a10, identifier: r }) => {
    let [t6, n4] = (0, import_react3.useState)(e3 && Object.values(o).includes(e3) ? e3 : "raw"), { displayValue: l10, validationWarnings: d11 } = B({ input: c9, decodeMethod: t6, identifier: r });
    return (0, import_react3.useEffect)(() => {
      a10 && a10(t6);
    }, [t6]), { displayValue: l10, validationWarnings: d11, setActiveKey: n4, decodeOptions: f12 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-CCK4MBG6.js
var import_dist40 = __toESM(require_dist());
var v3 = Dr(() => {
  v();
  o4();
  p9();
  d6();
  a4();
  s();
  h3();
  g7();
  d();
  d2();
  i4();
  L();
  m5();
  u11();
  a3();
  l6();
  T2();
  f7();
  g8();
  f9();
  m4();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-AAI7OAOT.js
var import_dist41 = __toESM(require_dist());
var x5;
var l8 = Dr(() => {
  v();
  x5 = ({ data: n4, highlight: t6, occurrences: s3, transactionIndex: r }) => {
    let e3 = s3[r] || n4.indexOf(t6), c9 = t6.length, g11 = n4.slice(0, e3), h7 = n4.slice(e3 + c9);
    return { start: g11, end: h7 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-276YS6GD.js
var import_dist42 = __toESM(require_dist());
var c6;
var p12;
var d9;
var u14 = Dr(() => {
  v();
  c2();
  g3();
  c6 = { errorMessage: l, successMessage: u3, processingMessage: p }, p12 = (e3) => e3.transactionsInfo, d9 = u5(p12, (e3, o6) => o6, (e3, o6) => o6 != null && (e3 == null ? void 0 : e3[Number(o6)]) || c6);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-H6BZGL2Y.js
var import_dist43 = __toESM(require_dist());
var i6;
var S3;
var a7 = Dr(() => {
  v();
  c2();
  i6 = (e3) => e3.dappConfig, S3 = u5(i6, (e3) => e3.shouldUseWebViewProvider);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-3MPYMFCZ.js
var import_dist44 = __toESM(require_dist());
var t3;
var A7;
var n2;
var h5;
var k3;
var L2;
var B2;
var C2;
var I2;
var R2;
var q2;
var y7;
var D4;
var f13 = Dr(() => {
  v();
  g3();
  c2();
  t3 = (o6) => o6.account, A7 = u5(t3, (o6) => o6.address), n2 = u5(t3, A7, (o6, e3) => e3 in o6.accounts ? o6.accounts[e3] : g2), h5 = u5(t3, n2, (o6, e3) => {
    let r = o6, { accounts: m8 } = r, S6 = Et(r, ["accounts"]);
    return xt(yt({}, S6), { address: e3.address, account: e3 });
  }), k3 = u5(n2, (o6) => o6.balance), L2 = u5(n2, (o6) => {
    var e3;
    return ((e3 = o6 == null ? void 0 : o6.nonce) == null ? void 0 : e3.valueOf()) || 0;
  }), B2 = u5(t3, (o6) => o6.shard), C2 = u5(t3, (o6) => o6.ledgerAccount), I2 = u5(t3, (o6) => o6.walletConnectAccount), R2 = u5(t3, (o6) => o6.isAccountLoading), q2 = u5(t3, (o6) => o6.accountLoadingError), y7 = u5(t3, (o6) => o6.websocketEvent), D4 = u5(t3, (o6) => o6.websocketBatchEvent);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-C6ERQ4DO.js
var import_dist45 = __toESM(require_dist());
var t4;
var x6;
var I3;
var m7;
var f14;
var u15;
var w4;
var C3;
var R3;
var h6;
var g9 = Dr(() => {
  v();
  f13();
  c2();
  t4 = (o6) => o6.loginInfo, x6 = u5(t4, (o6) => o6.loginMethod), I3 = u5(t4, A7, (o6, i8) => Boolean(i8)), m7 = u5(t4, (o6) => o6.walletConnectLogin), f14 = u5(t4, (o6) => o6.ledgerLogin), u15 = u5(t4, (o6) => o6.walletLogin), w4 = u5(t4, (o6) => o6.isLoginSessionInvalid), C3 = u5(t4, (o6) => o6.tokenLogin), R3 = u5(t4, (o6) => o6.logoutRoute), h6 = u5(t4, (o6) => o6.isWalletConnectV2Initialized);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZHMC3BOL.js
var import_dist46 = __toESM(require_dist());
var a8;
var n3;
var p13;
var c7 = Dr(() => {
  v();
  c2();
  a8 = (t6) => t6.modals, n3 = u5(a8, (t6) => t6.txSubmittedModal), p13 = u5(a8, (t6) => t6.notificationModal);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BQNI2XMA.js
var import_dist47 = __toESM(require_dist());
var t5;
var I4;
var l9;
var f15;
var M3;
var S4 = Dr(() => {
  v();
  c2();
  t5 = (e3) => e3.signedMessageInfo, I4 = u5(t5, (e3) => e3.isSigning), l9 = u5(t5, (e3) => e3.errorMessage), f15 = u5(t5, (e3) => {
    let s3 = Object.keys(e3.signedSessions), o6 = s3.length;
    return e3.signedSessions[s3[o6 - 1]];
  }), M3 = u5(t5, (e3) => {
    let s3 = Object.keys(e3.signedSessions), o6 = s3.length;
    return s3.length > 0 ? s3[o6 - 1] : "";
  });
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-7TW5V77R.js
var import_dist48 = __toESM(require_dist());
var e2;
var p14;
var i7;
var c8 = Dr(() => {
  v();
  c2();
  e2 = (t6) => t6.toasts, p14 = u5(e2, (t6) => t6.customToasts), i7 = u5(e2, (t6) => t6.transactionToasts);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZYJTJW6F.js
var import_dist49 = __toESM(require_dist());
var x7;
var s2 = Dr(() => {
  v();
  x7 = (e3, i8) => {
    let t6 = [], n4 = e3.indexOf(i8, 0);
    for (; n4 >= 0; ) t6.push(n4), n4 = e3.indexOf(i8, n4 + 1);
    return t6;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-MFCDOAOP.js
var import_dist50 = __toESM(require_dist());
function F(s3) {
  let o6 = [], i8 = 0;
  try {
    if ((s3 == null ? void 0 : s3.startsWith("MultiESDTNFTTransfer")) && (s3 == null ? void 0 : s3.includes("@"))) {
      let [, c9, p15, ...e3] = s3 == null ? void 0 : s3.split("@");
      if (c9) {
        let a10 = new bignumber_default(p15, 16).toNumber();
        if (a10 >= Number.MAX_SAFE_INTEGER) return [];
        let n4 = 0;
        for (let r = 0; r < a10; r++) {
          let t6 = { type: "nftTransaction", data: "", receiver: c9 };
          for (let l10 = 0; l10 < 3; l10++) {
            switch (l10) {
              case 0:
                t6.token = m(e3[n4]), t6.data = e3[n4];
                break;
              case 1: {
                let u16 = e3[n4] && e3[n4].length ? e3[n4] : "";
                u16 && u16 !== "00" ? t6.nonce = u16 : t6.type = "esdtTransaction", t6.data = `${t6.data}@${e3[n4]}`;
                break;
              }
              case 2:
                t6.amount = new bignumber_default(e3[n4], 16).toString(10), t6.data = `${t6.data}@${e3[n4]}`;
                break;
              default:
                break;
            }
            i8 = n4 + 1, n4++;
          }
          o6[r] = t6;
        }
        let g11 = o6.length !== a10, h7 = o6.some((r) => x7(r.data, "@").length !== 2), x9 = o6.some((r) => r.data.startsWith("@"));
        if (g11 || h7 || x9) return [];
        if (e3[i8]) {
          let r = e3[i8];
          for (let t6 = i8 + 1; t6 < e3.length; t6++) r += "@" + e3[t6];
          o6[a10] = { type: "scCall", data: r, receiver: c9 };
        }
      }
    }
  } catch (c9) {
    return console.error("failed parsing tx", c9), o6;
  }
  return o6;
}
var N3 = Dr(() => {
  v();
  u();
  f3();
  s2();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-2CBBH2VA.js
var import_dist51 = __toESM(require_dist());
var k4 = Dr(() => {
  v();
  S5();
  l2();
});
var ar;
var w5 = Dr(() => {
  v();
  d10();
  ar = ({ transaction: r, filterBy: t6 }) => {
    if (!r.operations) return [];
    let n4 = u4(r);
    if (n4.length === 0) return [];
    if (!t6) return n4;
    let { action: m8, receiver: i8, sender: y8 } = t6;
    return n4.filter((u16) => !(m8 && u16.action !== m8 || y8 && u16.sender !== y8 || i8 && u16.receiver !== i8));
  };
});
var d10 = Dr(() => {
  v();
  y4();
  A8();
  p6();
  p3();
  y2();
  k4();
  l8();
  o2();
  o3();
  N3();
  d5();
  i3();
  v3();
  g();
  w5();
});
var x8;
var f16;
var br;
var kr;
var g10;
var wr;
var Ar;
var Er;
var Lr;
var Mr;
var hr;
var E = Dr(() => {
  v();
  I();
  d10();
  c2();
  x8 = (r) => r.transactions, f16 = u5(x8, (r) => r.signedTransactions), br = u5(x8, (r) => r.signTransactionsError), kr = u5(x8, (r) => r.signTransactionsCancelMessage), g10 = (r) => (t6) => Object.entries(t6).reduce((n4, [m8, i8]) => (r(i8.status) && (n4[m8] = i8), n4), {}), wr = u5(f16, g10(j)), Ar = u5(f16, g10(k)), Er = u5(f16, g10(q)), Lr = u5(f16, g10(y)), Mr = u5(x8, (r) => {
    var t6;
    return (r == null ? void 0 : r.transactionsToSign) == null ? null : xt(yt({}, r.transactionsToSign), { transactions: ((t6 = r == null ? void 0 : r.transactionsToSign) == null ? void 0 : t6.transactions.map((n4) => D(n4))) || [] });
  }), hr = u5(f16, (r, t6) => t6, (r, t6) => t6 != null ? (r == null ? void 0 : r[t6]) || {} : {});
});
var S5 = Dr(() => {
  v();
  f13();
  a7();
  g9();
  c7();
  d3();
  S4();
  c8();
  u14();
  E();
});
var A8 = Dr(() => {
  v();
  S5();
  l2();
});

export {
  m3 as m,
  y3 as y,
  u6 as u,
  N2 as N,
  w2 as w,
  R,
  i3 as i,
  d4 as d,
  o3 as o,
  U2 as U,
  d5 as d2,
  x3 as x,
  y4 as y2,
  l5 as l,
  u7 as u2,
  y5 as y3,
  p6 as p,
  A5 as A,
  g7 as g,
  d8 as d3,
  m5 as m2,
  m6 as m3,
  u11 as u3,
  B,
  f11 as f,
  x5 as x2,
  l8 as l2,
  d9 as d4,
  i6 as i2,
  S3 as S,
  A7 as A2,
  n2 as n,
  h5 as h,
  L2 as L,
  B2,
  C2 as C,
  R2,
  y7 as y4,
  D4 as D,
  f13 as f2,
  t4 as t,
  x6 as x3,
  I3 as I,
  m7 as m4,
  f14 as f3,
  u15 as u4,
  w4 as w2,
  C3 as C2,
  R3,
  g9 as g2,
  p13 as p2,
  t5 as t2,
  I4 as I2,
  l9 as l3,
  f15 as f4,
  M3 as M,
  p14 as p3,
  i7 as i3,
  c8 as c,
  F,
  N3 as N2,
  d10 as d5,
  f16 as f5,
  br,
  kr,
  wr,
  Ar,
  Er,
  Lr,
  Mr,
  hr,
  S5 as S2
};
//# sourceMappingURL=chunk-DZSHGTAC.js.map
