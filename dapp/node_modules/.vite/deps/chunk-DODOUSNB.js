"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  e,
  w
} from "./chunk-TILBIW7H.js";
import {
  E2 as E,
  T2 as T,
  _,
  f,
  g2 as g,
  import_browserConstants,
  l,
  o2 as o,
  u as u2
} from "./chunk-HXV3SQ6S.js";
import {
  u
} from "./chunk-EKHLTR53.js";
import {
  Q
} from "./chunk-N7F464ZJ.js";
import {
  Dr,
  Ft,
  gt,
  v,
  xt,
  yt
} from "./chunk-5CKZHQYH.js";
import {
  require_out
} from "./chunk-5HSAGO3O.js";
import {
  __commonJS,
  __toESM,
  require_dist
} from "./chunk-UOCZJ3B4.js";

// node_modules/lodash.omit/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.omit/index.js"(exports, module) {
    var import_dist64 = __toESM(require_dist());
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n9, iteratee) {
      var index = -1, result = Array(n9);
      while (++index < n9) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e6) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e6) {
        }
        try {
          return func + "";
        } catch (e6) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var omit = baseRest(function(object, props) {
      if (object == null) {
        return {};
      }
      props = arrayMap(baseFlatten(props, 1), toKey);
      return basePick(object, baseDifference(getAllKeysIn(object), props));
    });
    function stubArray() {
      return [];
    }
    module.exports = omit;
  }
});

// node_modules/redux-persist/lib/storage/getStorage.js
var require_getStorage = __commonJS({
  "node_modules/redux-persist/lib/storage/getStorage.js"(exports) {
    "use strict";
    var import_dist64 = __toESM(require_dist());
    exports.__esModule = true;
    exports.default = getStorage;
    function _typeof3(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    function noop() {
    }
    var noopStorage = {
      getItem: noop,
      setItem: noop,
      removeItem: noop
    };
    function hasStorage(storageType) {
      if ((typeof self === "undefined" ? "undefined" : _typeof3(self)) !== "object" || !(storageType in self)) {
        return false;
      }
      try {
        var storage = self[storageType];
        var testKey = "redux-persist ".concat(storageType, " test");
        storage.setItem(testKey, "test");
        storage.getItem(testKey);
        storage.removeItem(testKey);
      } catch (e6) {
        if (process.env.NODE_ENV !== "production") console.warn("redux-persist ".concat(storageType, " test failed, persistence will be disabled."));
        return false;
      }
      return true;
    }
    function getStorage(type) {
      var storageType = "".concat(type, "Storage");
      if (hasStorage(storageType)) return self[storageType];
      else {
        if (process.env.NODE_ENV !== "production") {
          console.error("redux-persist failed to create sync storage. falling back to noop storage.");
        }
        return noopStorage;
      }
    }
  }
});

// node_modules/redux-persist/lib/storage/createWebStorage.js
var require_createWebStorage = __commonJS({
  "node_modules/redux-persist/lib/storage/createWebStorage.js"(exports) {
    "use strict";
    var import_dist64 = __toESM(require_dist());
    exports.__esModule = true;
    exports.default = createWebStorage;
    var _getStorage = _interopRequireDefault(require_getStorage());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createWebStorage(type) {
      var storage = (0, _getStorage.default)(type);
      return {
        getItem: function getItem(key) {
          return new Promise(function(resolve, reject) {
            resolve(storage.getItem(key));
          });
        },
        setItem: function setItem(key, item) {
          return new Promise(function(resolve, reject) {
            resolve(storage.setItem(key, item));
          });
        },
        removeItem: function removeItem(key) {
          return new Promise(function(resolve, reject) {
            resolve(storage.removeItem(key));
          });
        }
      };
    }
  }
});

// node_modules/redux-persist/lib/storage/index.js
var require_storage = __commonJS({
  "node_modules/redux-persist/lib/storage/index.js"(exports) {
    "use strict";
    var import_dist64 = __toESM(require_dist());
    exports.__esModule = true;
    exports.default = void 0;
    var _createWebStorage = _interopRequireDefault(require_createWebStorage());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = (0, _createWebStorage.default)("local");
    exports.default = _default;
  }
});

// node_modules/redux-persist/lib/storage/session.js
var require_session = __commonJS({
  "node_modules/redux-persist/lib/storage/session.js"(exports) {
    "use strict";
    var import_dist64 = __toESM(require_dist());
    exports.__esModule = true;
    exports.default = void 0;
    var _createWebStorage = _interopRequireDefault(require_createWebStorage());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = (0, _createWebStorage.default)("session");
    exports.default = _default;
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var import_dist64 = __toESM(require_dist());
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle;
  }
});

// node_modules/react-redux/lib/utils/batch.js
var require_batch = __commonJS({
  "node_modules/react-redux/lib/utils/batch.js"(exports) {
    "use strict";
    var import_dist64 = __toESM(require_dist());
    exports.__esModule = true;
    exports.getBatch = exports.setBatch = void 0;
    function defaultNoopBatch(callback) {
      callback();
    }
    var batch = defaultNoopBatch;
    var setBatch = (newBatch) => batch = newBatch;
    exports.setBatch = setBatch;
    var getBatch = () => batch;
    exports.getBatch = getBatch;
  }
});

// node_modules/react-redux/lib/utils/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/react-redux/lib/utils/Subscription.js"(exports) {
    "use strict";
    var import_dist64 = __toESM(require_dist());
    exports.__esModule = true;
    exports.createSubscription = createSubscription;
    var _batch = require_batch();
    function createListenerCollection() {
      const batch = (0, _batch.getBatch)();
      let first = null;
      let last = null;
      return {
        clear() {
          first = null;
          last = null;
        },
        notify() {
          batch(() => {
            let listener2 = first;
            while (listener2) {
              listener2.callback();
              listener2 = listener2.next;
            }
          });
        },
        get() {
          let listeners = [];
          let listener2 = first;
          while (listener2) {
            listeners.push(listener2);
            listener2 = listener2.next;
          }
          return listeners;
        },
        subscribe(callback) {
          let isSubscribed = true;
          let listener2 = last = {
            callback,
            next: null,
            prev: last
          };
          if (listener2.prev) {
            listener2.prev.next = listener2;
          } else {
            first = listener2;
          }
          return function unsubscribe() {
            if (!isSubscribed || first === null) return;
            isSubscribed = false;
            if (listener2.next) {
              listener2.next.prev = listener2.prev;
            } else {
              last = listener2.prev;
            }
            if (listener2.prev) {
              listener2.prev.next = listener2.next;
            } else {
              first = listener2.next;
            }
          };
        }
      };
    }
    var nullListeners = {
      notify() {
      },
      get: () => []
    };
    function createSubscription(store, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;
      function addNestedSub(listener2) {
        trySubscribe();
        return listeners.subscribe(listener2);
      }
      function notifyNestedSubs() {
        listeners.notify();
      }
      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }
      function isSubscribed() {
        return Boolean(unsubscribe);
      }
      function trySubscribe() {
        if (!unsubscribe) {
          unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }
      function tryUnsubscribe() {
        if (unsubscribe) {
          unsubscribe();
          unsubscribe = void 0;
          listeners.clear();
          listeners = nullListeners;
        }
      }
      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe,
        tryUnsubscribe,
        getListeners: () => listeners
      };
      return subscription;
    }
  }
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-RALSJ7UN.js
var import_dist = __toESM(require_dist());
function s() {
  return typeof sessionStorage != "undefined";
}
var o2 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-CHYGQARZ.js
var import_dist2 = __toESM(require_dist());
var t;
var i = Dr(() => {
  v();
  t = ((o9) => (o9.account = "account", o9.dappModal = "dappModal", o9.dappConfig = "dappConfig", o9.loginInfo = "loginInfo", o9.modals = "modals", o9.networkConfig = "networkConfig", o9.signedMessageInfo = "signedMessageInfo", o9.toasts = "toasts", o9.transactions = "transactions", o9.batchTransactions = "batchTransactions", o9.transactionsInfo = "transactionsInfo", o9.transactionsToSign = "transactionsToSign", o9))(t || {});
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-J42ZO72F.js
var import_dist3 = __toESM(require_dist());
function x(e6) {
  let t7 = null;
  if ((e6 == null ? void 0 : e6.statusCode) in E) {
    let s9 = e6 == null ? void 0 : e6.statusCode, { message: r5 } = E[s9];
    t7 = g2.includes(s9) ? d : r5;
  }
  return { errorMessage: t7, defaultErrorMessage: d };
}
var d;
var a;
var c;
var g2;
var i2 = Dr(() => {
  v();
  o();
  d = "Check if the MultiversX app is open on Ledger", a = 28161, c = 28160, g2 = [a, c];
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-6ZGFYJ6T.js
var import_dist4 = __toESM(require_dist());
function m(r5) {
  return r5[Math.floor(Math.random() * r5.length)];
}
var n = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-UGBEFOBM.js
var import_dist5 = __toESM(require_dist());
var u3;
var s2 = Dr(() => {
  v();
  f();
  u3 = (t7) => {
    if (!import_browserConstants.safeWindow.location) return;
    if (!new URL(import_browserConstants.safeWindow.location.href).protocol.startsWith("http")) return import_browserConstants.safeWindow.location.reload();
    import_browserConstants.safeWindow.location.assign(t7);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OWBHRN3S.js
var import_dist6 = __toESM(require_dist());
var f2;
var c2 = Dr(() => {
  v();
  e();
  f2 = () => {
    if (!w()) return { pathname: "", hash: "", origin: "", href: "", search: "" };
    let { location: { pathname: t7, hash: a9, origin: o9, href: e6, search: r5 } } = window;
    return { pathname: t7, hash: a9, origin: o9, href: e6, search: r5 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-7XYHQ72T.js
var import_dist7 = __toESM(require_dist());
var u4;
var e2 = Dr(() => {
  v();
  c2();
  u4 = (t7 = "") => {
    let o9 = f2(), n9 = t7.startsWith("http") || t7.startsWith("www.");
    return !o9.origin || t7.startsWith(o9.origin) || n9 ? t7 : `${o9.origin}/${t7.replace("/", "")}`;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-UORIA4VW.js
var import_dist8 = __toESM(require_dist());
var x2 = Dr(() => {
  v();
  e2();
  p();
  c2();
  s2();
});
var D;
var p = Dr(() => {
  v();
  x2();
  D = () => {
    let { pathname: r5, search: t7, hash: e6 } = f2();
    return `${r5 != null ? r5 : ""}${t7 != null ? t7 : ""}${e6 != null ? e6 : ""}`;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-TGDCWKZH.js
var import_dist9 = __toESM(require_dist());
var i3;
var p2;
var l2;
var u5 = Dr(() => {
  v();
  x2();
  i3 = false, p2 = (e6 = true) => {
    i3 = e6;
  }, l2 = ({ timeout: e6 = 0, url: n9 }) => {
    i3 || setTimeout(() => {
      if (!!window) return u3(n9);
    }, e6);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4CZQ6YQW.js
var import_dist10 = __toESM(require_dist());
function L({ callbackRoute: e6, onLoginRedirect: i11, options: t7 }) {
  let r5 = Boolean(e6), p14 = typeof i11 == "function";
  if (r5 && e6 != null) {
    if (p14) return i11(e6, t7);
    l2({ url: e6, timeout: s3 });
  }
}
var s3;
var f3 = Dr(() => {
  v();
  u5();
  s3 = 200;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-Q2AWPGGC.js
var import_dist11 = __toESM(require_dist());
var p3 = Dr(() => {
  v();
  f3();
  n();
  i2();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-CK75LBHF.js
var import_dist23 = __toESM(require_dist());

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js
var import_dist22 = __toESM(require_dist());

// node_modules/immer/dist/immer.esm.mjs
var import_dist12 = __toESM(require_dist(), 1);
function n3(n9) {
  for (var r5 = arguments.length, t7 = Array(r5 > 1 ? r5 - 1 : 0), e6 = 1; e6 < r5; e6++) t7[e6 - 1] = arguments[e6];
  if ("production" !== process.env.NODE_ENV) {
    var i11 = Y[n9], o9 = i11 ? "function" == typeof i11 ? i11.apply(null, t7) : i11 : "unknown error nr: " + n9;
    throw Error("[Immer] " + o9);
  }
  throw Error("[Immer] minified error nr: " + n9 + (t7.length ? " " + t7.map(function(n10) {
    return "'" + n10 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n9) {
  return !!n9 && !!n9[Q2];
}
function t2(n9) {
  var r5;
  return !!n9 && (function(n10) {
    if (!n10 || "object" != typeof n10) return false;
    var r6 = Object.getPrototypeOf(n10);
    if (null === r6) return true;
    var t7 = Object.hasOwnProperty.call(r6, "constructor") && r6.constructor;
    return t7 === Object || "function" == typeof t7 && Function.toString.call(t7) === Z;
  }(n9) || Array.isArray(n9) || !!n9[L2] || !!(null === (r5 = n9.constructor) || void 0 === r5 ? void 0 : r5[L2]) || s4(n9) || v2(n9));
}
function i4(n9, r5, t7) {
  void 0 === t7 && (t7 = false), 0 === o3(n9) ? (t7 ? Object.keys : nn)(n9).forEach(function(e6) {
    t7 && "symbol" == typeof e6 || r5(e6, n9[e6], n9);
  }) : n9.forEach(function(t8, e6) {
    return r5(e6, t8, n9);
  });
}
function o3(n9) {
  var r5 = n9[Q2];
  return r5 ? r5.i > 3 ? r5.i - 4 : r5.i : Array.isArray(n9) ? 1 : s4(n9) ? 2 : v2(n9) ? 3 : 0;
}
function u6(n9, r5) {
  return 2 === o3(n9) ? n9.has(r5) : Object.prototype.hasOwnProperty.call(n9, r5);
}
function a2(n9, r5) {
  return 2 === o3(n9) ? n9.get(r5) : n9[r5];
}
function f4(n9, r5, t7) {
  var e6 = o3(n9);
  2 === e6 ? n9.set(r5, t7) : 3 === e6 ? n9.add(t7) : n9[r5] = t7;
}
function c3(n9, r5) {
  return n9 === r5 ? 0 !== n9 || 1 / n9 == 1 / r5 : n9 != n9 && r5 != r5;
}
function s4(n9) {
  return X && n9 instanceof Map;
}
function v2(n9) {
  return q && n9 instanceof Set;
}
function p4(n9) {
  return n9.o || n9.t;
}
function l3(n9) {
  if (Array.isArray(n9)) return Array.prototype.slice.call(n9);
  var r5 = rn(n9);
  delete r5[Q2];
  for (var t7 = nn(r5), e6 = 0; e6 < t7.length; e6++) {
    var i11 = t7[e6], o9 = r5[i11];
    false === o9.writable && (o9.writable = true, o9.configurable = true), (o9.get || o9.set) && (r5[i11] = { configurable: true, writable: true, enumerable: o9.enumerable, value: n9[i11] });
  }
  return Object.create(Object.getPrototypeOf(n9), r5);
}
function d2(n9, e6) {
  return void 0 === e6 && (e6 = false), y(n9) || r(n9) || !t2(n9) || (o3(n9) > 1 && (n9.set = n9.add = n9.clear = n9.delete = h), Object.freeze(n9), e6 && i4(n9, function(n10, r5) {
    return d2(r5, true);
  }, true)), n9;
}
function h() {
  n3(2);
}
function y(n9) {
  return null == n9 || "object" != typeof n9 || Object.isFrozen(n9);
}
function b(r5) {
  var t7 = tn[r5];
  return t7 || n3(18, r5), t7;
}
function m2(n9, r5) {
  tn[n9] || (tn[n9] = r5);
}
function _2() {
  return "production" === process.env.NODE_ENV || U || n3(0), U;
}
function j(n9, r5) {
  r5 && (b("Patches"), n9.u = [], n9.s = [], n9.v = r5);
}
function g3(n9) {
  O(n9), n9.p.forEach(S), n9.p = null;
}
function O(n9) {
  n9 === U && (U = n9.l);
}
function w2(n9) {
  return U = { p: [], l: U, h: n9, m: true, _: 0 };
}
function S(n9) {
  var r5 = n9[Q2];
  0 === r5.i || 1 === r5.i ? r5.j() : r5.g = true;
}
function P(r5, e6) {
  e6._ = e6.p.length;
  var i11 = e6.p[0], o9 = void 0 !== r5 && r5 !== i11;
  return e6.h.O || b("ES5").S(e6, r5, o9), o9 ? (i11[Q2].P && (g3(e6), n3(4)), t2(r5) && (r5 = M(e6, r5), e6.l || x3(e6, r5)), e6.u && b("Patches").M(i11[Q2].t, r5, e6.u, e6.s)) : r5 = M(e6, i11, []), g3(e6), e6.u && e6.v(e6.u, e6.s), r5 !== H ? r5 : void 0;
}
function M(n9, r5, t7) {
  if (y(r5)) return r5;
  var e6 = r5[Q2];
  if (!e6) return i4(r5, function(i11, o10) {
    return A(n9, e6, r5, i11, o10, t7);
  }, true), r5;
  if (e6.A !== n9) return r5;
  if (!e6.P) return x3(n9, e6.t, true), e6.t;
  if (!e6.I) {
    e6.I = true, e6.A._--;
    var o9 = 4 === e6.i || 5 === e6.i ? e6.o = l3(e6.k) : e6.o, u13 = o9, a9 = false;
    3 === e6.i && (u13 = new Set(o9), o9.clear(), a9 = true), i4(u13, function(r6, i11) {
      return A(n9, e6, o9, r6, i11, t7, a9);
    }), x3(n9, o9, false), t7 && n9.u && b("Patches").N(e6, t7, n9.u, n9.s);
  }
  return e6.o;
}
function A(e6, i11, o9, a9, c9, s9, v7) {
  if ("production" !== process.env.NODE_ENV && c9 === o9 && n3(5), r(c9)) {
    var p14 = M(e6, c9, s9 && i11 && 3 !== i11.i && !u6(i11.R, a9) ? s9.concat(a9) : void 0);
    if (f4(o9, a9, p14), !r(p14)) return;
    e6.m = false;
  } else v7 && o9.add(c9);
  if (t2(c9) && !y(c9)) {
    if (!e6.h.D && e6._ < 1) return;
    M(e6, c9), i11 && i11.A.l || x3(e6, c9);
  }
}
function x3(n9, r5, t7) {
  void 0 === t7 && (t7 = false), !n9.l && n9.h.D && n9.m && d2(r5, t7);
}
function z(n9, r5) {
  var t7 = n9[Q2];
  return (t7 ? p4(t7) : n9)[r5];
}
function I(n9, r5) {
  if (r5 in n9) for (var t7 = Object.getPrototypeOf(n9); t7; ) {
    var e6 = Object.getOwnPropertyDescriptor(t7, r5);
    if (e6) return e6;
    t7 = Object.getPrototypeOf(t7);
  }
}
function k(n9) {
  n9.P || (n9.P = true, n9.l && k(n9.l));
}
function E2(n9) {
  n9.o || (n9.o = l3(n9.t));
}
function N(n9, r5, t7) {
  var e6 = s4(r5) ? b("MapSet").F(r5, t7) : v2(r5) ? b("MapSet").T(r5, t7) : n9.O ? function(n10, r6) {
    var t8 = Array.isArray(n10), e7 = { i: t8 ? 1 : 0, A: r6 ? r6.A : _2(), P: false, I: false, R: {}, l: r6, t: n10, k: null, o: null, j: null, C: false }, i11 = e7, o9 = en;
    t8 && (i11 = [e7], o9 = on);
    var u13 = Proxy.revocable(i11, o9), a9 = u13.revoke, f13 = u13.proxy;
    return e7.k = f13, e7.j = a9, f13;
  }(r5, t7) : b("ES5").J(r5, t7);
  return (t7 ? t7.A : _2()).p.push(e6), e6;
}
function R(e6) {
  return r(e6) || n3(22, e6), function n9(r5) {
    if (!t2(r5)) return r5;
    var e7, u13 = r5[Q2], c9 = o3(r5);
    if (u13) {
      if (!u13.P && (u13.i < 4 || !b("ES5").K(u13))) return u13.t;
      u13.I = true, e7 = D2(r5, c9), u13.I = false;
    } else e7 = D2(r5, c9);
    return i4(e7, function(r6, t7) {
      u13 && a2(u13.t, r6) === t7 || f4(e7, r6, n9(t7));
    }), 3 === c9 ? new Set(e7) : e7;
  }(e6);
}
function D2(n9, r5) {
  switch (r5) {
    case 2:
      return new Map(n9);
    case 3:
      return Array.from(n9);
  }
  return l3(n9);
}
function F() {
  function t7(n9, r5) {
    var t8 = s9[n9];
    return t8 ? t8.enumerable = r5 : s9[n9] = t8 = { configurable: true, enumerable: r5, get: function() {
      var r6 = this[Q2];
      return "production" !== process.env.NODE_ENV && f13(r6), en.get(r6, n9);
    }, set: function(r6) {
      var t9 = this[Q2];
      "production" !== process.env.NODE_ENV && f13(t9), en.set(t9, n9, r6);
    } }, t8;
  }
  function e6(n9) {
    for (var r5 = n9.length - 1; r5 >= 0; r5--) {
      var t8 = n9[r5][Q2];
      if (!t8.P) switch (t8.i) {
        case 5:
          a9(t8) && k(t8);
          break;
        case 4:
          o9(t8) && k(t8);
      }
    }
  }
  function o9(n9) {
    for (var r5 = n9.t, t8 = n9.k, e7 = nn(t8), i11 = e7.length - 1; i11 >= 0; i11--) {
      var o10 = e7[i11];
      if (o10 !== Q2) {
        var a10 = r5[o10];
        if (void 0 === a10 && !u6(r5, o10)) return true;
        var f14 = t8[o10], s10 = f14 && f14[Q2];
        if (s10 ? s10.t !== a10 : !c3(f14, a10)) return true;
      }
    }
    var v7 = !!r5[Q2];
    return e7.length !== nn(r5).length + (v7 ? 0 : 1);
  }
  function a9(n9) {
    var r5 = n9.k;
    if (r5.length !== n9.t.length) return true;
    var t8 = Object.getOwnPropertyDescriptor(r5, r5.length - 1);
    if (t8 && !t8.get) return true;
    for (var e7 = 0; e7 < r5.length; e7++) if (!r5.hasOwnProperty(e7)) return true;
    return false;
  }
  function f13(r5) {
    r5.g && n3(3, JSON.stringify(p4(r5)));
  }
  var s9 = {};
  m2("ES5", { J: function(n9, r5) {
    var e7 = Array.isArray(n9), i11 = function(n10, r6) {
      if (n10) {
        for (var e8 = Array(r6.length), i12 = 0; i12 < r6.length; i12++) Object.defineProperty(e8, "" + i12, t7(i12, true));
        return e8;
      }
      var o11 = rn(r6);
      delete o11[Q2];
      for (var u13 = nn(o11), a10 = 0; a10 < u13.length; a10++) {
        var f14 = u13[a10];
        o11[f14] = t7(f14, n10 || !!o11[f14].enumerable);
      }
      return Object.create(Object.getPrototypeOf(r6), o11);
    }(e7, n9), o10 = { i: e7 ? 5 : 4, A: r5 ? r5.A : _2(), P: false, I: false, R: {}, l: r5, t: n9, k: i11, o: null, g: false, C: false };
    return Object.defineProperty(i11, Q2, { value: o10, writable: true }), i11;
  }, S: function(n9, t8, o10) {
    o10 ? r(t8) && t8[Q2].A === n9 && e6(n9.p) : (n9.u && function n10(r5) {
      if (r5 && "object" == typeof r5) {
        var t9 = r5[Q2];
        if (t9) {
          var e7 = t9.t, o11 = t9.k, f14 = t9.R, c9 = t9.i;
          if (4 === c9) i4(o11, function(r6) {
            r6 !== Q2 && (void 0 !== e7[r6] || u6(e7, r6) ? f14[r6] || n10(o11[r6]) : (f14[r6] = true, k(t9)));
          }), i4(e7, function(n11) {
            void 0 !== o11[n11] || u6(o11, n11) || (f14[n11] = false, k(t9));
          });
          else if (5 === c9) {
            if (a9(t9) && (k(t9), f14.length = true), o11.length < e7.length) for (var s10 = o11.length; s10 < e7.length; s10++) f14[s10] = false;
            else for (var v7 = e7.length; v7 < o11.length; v7++) f14[v7] = true;
            for (var p14 = Math.min(o11.length, e7.length), l8 = 0; l8 < p14; l8++) o11.hasOwnProperty(l8) || (f14[l8] = true), void 0 === f14[l8] && n10(o11[l8]);
          }
        }
      }
    }(n9.p[0]), e6(n9.p));
  }, K: function(n9) {
    return 4 === n9.i ? o9(n9) : a9(n9);
  } });
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L2 = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q2 = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n9) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n9;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n9) {
  return "Cannot apply patch, path doesn't resolve: " + n9;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n9) {
  return "Unsupported patch operation: " + n9;
}, 18: function(n9) {
  return "The plugin for '" + n9 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n9 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n9) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n9 + "'";
}, 22: function(n9) {
  return "'current' expects a draft, got: " + n9;
}, 23: function(n9) {
  return "'original' expects a draft, got: " + n9;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n9) {
  return Object.getOwnPropertyNames(n9).concat(Object.getOwnPropertySymbols(n9));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n9) {
  var r5 = {};
  return nn(n9).forEach(function(t7) {
    r5[t7] = Object.getOwnPropertyDescriptor(n9, t7);
  }), r5;
};
var tn = {};
var en = { get: function(n9, r5) {
  if (r5 === Q2) return n9;
  var e6 = p4(n9);
  if (!u6(e6, r5)) return function(n10, r6, t7) {
    var e7, i12 = I(r6, t7);
    return i12 ? "value" in i12 ? i12.value : null === (e7 = i12.get) || void 0 === e7 ? void 0 : e7.call(n10.k) : void 0;
  }(n9, e6, r5);
  var i11 = e6[r5];
  return n9.I || !t2(i11) ? i11 : i11 === z(n9.t, r5) ? (E2(n9), n9.o[r5] = N(n9.A.h, i11, n9)) : i11;
}, has: function(n9, r5) {
  return r5 in p4(n9);
}, ownKeys: function(n9) {
  return Reflect.ownKeys(p4(n9));
}, set: function(n9, r5, t7) {
  var e6 = I(p4(n9), r5);
  if (null == e6 ? void 0 : e6.set) return e6.set.call(n9.k, t7), true;
  if (!n9.P) {
    var i11 = z(p4(n9), r5), o9 = null == i11 ? void 0 : i11[Q2];
    if (o9 && o9.t === t7) return n9.o[r5] = t7, n9.R[r5] = false, true;
    if (c3(t7, i11) && (void 0 !== t7 || u6(n9.t, r5))) return true;
    E2(n9), k(n9);
  }
  return n9.o[r5] === t7 && (void 0 !== t7 || r5 in n9.o) || Number.isNaN(t7) && Number.isNaN(n9.o[r5]) || (n9.o[r5] = t7, n9.R[r5] = true), true;
}, deleteProperty: function(n9, r5) {
  return void 0 !== z(n9.t, r5) || r5 in n9.t ? (n9.R[r5] = false, E2(n9), k(n9)) : delete n9.R[r5], n9.o && delete n9.o[r5], true;
}, getOwnPropertyDescriptor: function(n9, r5) {
  var t7 = p4(n9), e6 = Reflect.getOwnPropertyDescriptor(t7, r5);
  return e6 ? { writable: true, configurable: 1 !== n9.i || "length" !== r5, enumerable: e6.enumerable, value: t7[r5] } : e6;
}, defineProperty: function() {
  n3(11);
}, getPrototypeOf: function(n9) {
  return Object.getPrototypeOf(n9.t);
}, setPrototypeOf: function() {
  n3(12);
} };
var on = {};
i4(en, function(n9, r5) {
  on[n9] = function() {
    return arguments[0] = arguments[0][0], r5.apply(this, arguments);
  };
}), on.deleteProperty = function(r5, t7) {
  return "production" !== process.env.NODE_ENV && isNaN(parseInt(t7)) && n3(13), on.set.call(this, r5, t7, void 0);
}, on.set = function(r5, t7, e6) {
  return "production" !== process.env.NODE_ENV && "length" !== t7 && isNaN(parseInt(t7)) && n3(14), en.set.call(this, r5[0], t7, e6, r5[0]);
};
var un = function() {
  function e6(r5) {
    var e7 = this;
    this.O = B, this.D = true, this.produce = function(r6, i12, o9) {
      if ("function" == typeof r6 && "function" != typeof i12) {
        var u13 = i12;
        i12 = r6;
        var a9 = e7;
        return function(n9) {
          var r7 = this;
          void 0 === n9 && (n9 = u13);
          for (var t7 = arguments.length, e8 = Array(t7 > 1 ? t7 - 1 : 0), o10 = 1; o10 < t7; o10++) e8[o10 - 1] = arguments[o10];
          return a9.produce(n9, function(n10) {
            var t8;
            return (t8 = i12).call.apply(t8, [r7, n10].concat(e8));
          });
        };
      }
      var f13;
      if ("function" != typeof i12 && n3(6), void 0 !== o9 && "function" != typeof o9 && n3(7), t2(r6)) {
        var c9 = w2(e7), s9 = N(e7, r6, void 0), v7 = true;
        try {
          f13 = i12(s9), v7 = false;
        } finally {
          v7 ? g3(c9) : O(c9);
        }
        return "undefined" != typeof Promise && f13 instanceof Promise ? f13.then(function(n9) {
          return j(c9, o9), P(n9, c9);
        }, function(n9) {
          throw g3(c9), n9;
        }) : (j(c9, o9), P(f13, c9));
      }
      if (!r6 || "object" != typeof r6) {
        if (void 0 === (f13 = i12(r6)) && (f13 = r6), f13 === H && (f13 = void 0), e7.D && d2(f13, true), o9) {
          var p14 = [], l8 = [];
          b("Patches").M(r6, f13, p14, l8), o9(p14, l8);
        }
        return f13;
      }
      n3(21, r6);
    }, this.produceWithPatches = function(n9, r6) {
      if ("function" == typeof n9) return function(r7) {
        for (var t8 = arguments.length, i13 = Array(t8 > 1 ? t8 - 1 : 0), o10 = 1; o10 < t8; o10++) i13[o10 - 1] = arguments[o10];
        return e7.produceWithPatches(r7, function(r8) {
          return n9.apply(void 0, [r8].concat(i13));
        });
      };
      var t7, i12, o9 = e7.produce(n9, r6, function(n10, r7) {
        t7 = n10, i12 = r7;
      });
      return "undefined" != typeof Promise && o9 instanceof Promise ? o9.then(function(n10) {
        return [n10, t7, i12];
      }) : [o9, t7, i12];
    }, "boolean" == typeof (null == r5 ? void 0 : r5.useProxies) && this.setUseProxies(r5.useProxies), "boolean" == typeof (null == r5 ? void 0 : r5.autoFreeze) && this.setAutoFreeze(r5.autoFreeze);
  }
  var i11 = e6.prototype;
  return i11.createDraft = function(e7) {
    t2(e7) || n3(8), r(e7) && (e7 = R(e7));
    var i12 = w2(this), o9 = N(this, e7, void 0);
    return o9[Q2].C = true, O(i12), o9;
  }, i11.finishDraft = function(r5, t7) {
    var e7 = r5 && r5[Q2];
    "production" !== process.env.NODE_ENV && (e7 && e7.C || n3(9), e7.I && n3(10));
    var i12 = e7.A;
    return j(i12, t7), P(void 0, i12);
  }, i11.setAutoFreeze = function(n9) {
    this.D = n9;
  }, i11.setUseProxies = function(r5) {
    r5 && !B && n3(20), this.O = r5;
  }, i11.applyPatches = function(n9, t7) {
    var e7;
    for (e7 = t7.length - 1; e7 >= 0; e7--) {
      var i12 = t7[e7];
      if (0 === i12.path.length && "replace" === i12.op) {
        n9 = i12.value;
        break;
      }
    }
    e7 > -1 && (t7 = t7.slice(e7 + 1));
    var o9 = b("Patches").$;
    return r(n9) ? o9(n9, t7) : this.produce(n9, function(n10) {
      return o9(n10, t7);
    });
  }, e6;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn;

// node_modules/redux/es/redux.js
var import_dist18 = __toESM(require_dist());

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var import_dist17 = __toESM(require_dist());

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
var import_dist16 = __toESM(require_dist(), 1);

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
var import_dist15 = __toESM(require_dist(), 1);

// node_modules/@babel/runtime/helpers/esm/typeof.js
var import_dist13 = __toESM(require_dist(), 1);
function _typeof(o9) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o10) {
    return typeof o10;
  } : function(o10) {
    return o10 && "function" == typeof Symbol && o10.constructor === Symbol && o10 !== Symbol.prototype ? "symbol" : typeof o10;
  }, _typeof(o9);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
var import_dist14 = __toESM(require_dist(), 1);
function toPrimitive(t7, r5) {
  if ("object" != _typeof(t7) || !t7) return t7;
  var e6 = t7[Symbol.toPrimitive];
  if (void 0 !== e6) {
    var i11 = e6.call(t7, r5 || "default");
    if ("object" != _typeof(i11)) return i11;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r5 ? String : Number)(t7);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t7) {
  var i11 = toPrimitive(t7, "string");
  return "symbol" == _typeof(i11) ? i11 : i11 + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e6, r5, t7) {
  return (r5 = toPropertyKey(r5)) in e6 ? Object.defineProperty(e6, r5, {
    value: t7,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e6[r5] = t7, e6;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e6, r5) {
  var t7 = Object.keys(e6);
  if (Object.getOwnPropertySymbols) {
    var o9 = Object.getOwnPropertySymbols(e6);
    r5 && (o9 = o9.filter(function(r6) {
      return Object.getOwnPropertyDescriptor(e6, r6).enumerable;
    })), t7.push.apply(t7, o9);
  }
  return t7;
}
function _objectSpread2(e6) {
  for (var r5 = 1; r5 < arguments.length; r5++) {
    var t7 = null != arguments[r5] ? arguments[r5] : {};
    r5 % 2 ? ownKeys(Object(t7), true).forEach(function(r6) {
      _defineProperty(e6, r6, t7[r6]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(t7)) : ownKeys(Object(t7)).forEach(function(r6) {
      Object.defineProperty(e6, r6, Object.getOwnPropertyDescriptor(t7, r6));
    });
  }
  return e6;
}

// node_modules/redux/es/redux.js
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function miniKindOf(val) {
  if (val === void 0) return "undefined";
  if (val === null) return "null";
  var type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val)) return "array";
  if (isDate(val)) return "date";
  if (isError(val)) return "error";
  var constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  var typeOfVal = typeof val;
  if (process.env.NODE_ENV !== "production") {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener2) {
    if (typeof listener2 !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener2) + "'");
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener2);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener2);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }
    if (typeof action.type === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i11 = 0; i11 < listeners.length; i11++) {
      var listener2 = listeners[i11];
      listener2();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e6) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }
  var unexpectedKeys = Object.keys(inputState).filter(function(key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function(key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;
  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer = reducers[key];
    var initialState2 = reducer(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(12) : 'The slice reducer for key "' + key + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(13) : 'The slice reducer for key "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle '" + ActionTypes.INIT + `' or other actions in "redux/*" `) + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i11 = 0; i11 < reducerKeys.length; i11++) {
    var key = reducerKeys[i11];
    if (process.env.NODE_ENV !== "production") {
      if (typeof reducers[key] === "undefined") {
        warning('No reducer provided for key "' + key + '"');
      }
    }
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var unexpectedKeyCache;
  if (process.env.NODE_ENV !== "production") {
    unexpectedKeyCache = {};
  }
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e6) {
    shapeAssertionError = e6;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (process.env.NODE_ENV !== "production") {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        var actionType = action && action.type;
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(14) : "When called with an action of type " + (actionType ? '"' + String(actionType) + '"' : "(unknown type)") + ', the slice reducer for key "' + _key + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.');
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a9, b8) {
    return function() {
      return a9(b8.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

// node_modules/@reduxjs/toolkit/node_modules/reselect/es/index.js
var import_dist20 = __toESM(require_dist());

// node_modules/@reduxjs/toolkit/node_modules/reselect/es/defaultMemoize.js
var import_dist19 = __toESM(require_dist());
var NOT_FOUND = "NOT_FOUND";
function createSingletonCache(equals) {
  var entry;
  return {
    get: function get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put: function put(key, value) {
      entry = {
        key,
        value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  var entries = [];
  function get(key) {
    var cacheIndex = entries.findIndex(function(entry2) {
      return equals(key, entry2.key);
    });
    if (cacheIndex > -1) {
      var entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({
        key,
        value
      });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return {
    get,
    put,
    getEntries,
    clear
  };
}
var defaultEqualityCheck = function defaultEqualityCheck2(a9, b8) {
  return a9 === b8;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    }
    var length = prev.length;
    for (var i11 = 0; i11 < length; i11++) {
      if (!equalityCheck(prev[i11], next[i11])) {
        return false;
      }
    }
    return true;
  };
}
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    var value = cache.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      if (resultEqualityCheck) {
        var entries = cache.getEntries();
        var matchingEntry = entries.find(function(entry) {
          return resultEqualityCheck(entry.value, value);
        });
        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }
      cache.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = function() {
    return cache.clear();
  };
  return memoized;
}

// node_modules/@reduxjs/toolkit/node_modules/reselect/es/index.js
function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  if (!dependencies.every(function(dep) {
    return typeof dep === "function";
  })) {
    var dependencyTypes = dependencies.map(function(dep) {
      return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
    }).join(", ");
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }
  return dependencies;
}
function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }
  var createSelector2 = function createSelector3() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }
    var _recomputations = 0;
    var _lastResult;
    var directlyPassedOptions = {
      memoizeOptions: void 0
    };
    var resultFunc = funcs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = funcs.pop();
    }
    if (typeof resultFunc !== "function") {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    }
    var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {
      _recomputations++;
      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions));
    var selector = memoize(function dependenciesChecker() {
      var params = [];
      var length = dependencies.length;
      for (var i11 = 0; i11 < length; i11++) {
        params.push(dependencies[i11].apply(null, arguments));
      }
      _lastResult = memoizedResultFunc.apply(null, params);
      return _lastResult;
    });
    Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector;
  };
  return createSelector2;
}
var createSelector = createSelectorCreator(defaultMemoize);

// node_modules/redux-thunk/es/index.js
var import_dist21 = __toESM(require_dist());
function createThunkMiddleware(extraArgument) {
  var middleware = function middleware2(_ref) {
    var dispatch = _ref.dispatch, getState = _ref.getState;
    return function(next) {
      return function(action) {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next(action);
      };
    };
  };
  return middleware;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
var es_default = thunk;

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d8, b8) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d9, b9) {
      d9.__proto__ = b9;
    } || function(d9, b9) {
      for (var p14 in b9) if (Object.prototype.hasOwnProperty.call(b9, p14)) d9[p14] = b9[p14];
    };
    return extendStatics(d8, b8);
  };
  return function(d8, b8) {
    if (typeof b8 !== "function" && b8 !== null)
      throw new TypeError("Class extends value " + String(b8) + " is not a constructor or null");
    extendStatics(d8, b8);
    function __() {
      this.constructor = d8;
    }
    d8.prototype = b8 === null ? Object.create(b8) : (__.prototype = b8.prototype, new __());
  };
}();
var __spreadArray = function(to, from) {
  for (var i11 = 0, il = from.length, j6 = to.length; i11 < il; i11++, j6++)
    to[j6] = from[i11];
  return to;
};
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function(obj, key, value) {
  return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues = function(a9, b8) {
  for (var prop in b8 || (b8 = {}))
    if (__hasOwnProp.call(b8, prop))
      __defNormalProp(a9, prop, b8[prop]);
  if (__getOwnPropSymbols)
    for (var _i = 0, _c = __getOwnPropSymbols(b8); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum.call(b8, prop))
        __defNormalProp(a9, prop, b8[prop]);
    }
  return a9;
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose;
  return compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop2) {
    return noop2;
  };
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  var baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
function getTimeMeasureUtils(maxDelay, fnName) {
  var elapsed = 0;
  return {
    measureTime: function(fn2) {
      var started = Date.now();
      try {
        return fn2();
      } finally {
        var finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded: function() {
      if (elapsed > maxDelay) {
        console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
      }
    }
  };
}
var MiddlewareArray = (
  /** @class */
  function(_super) {
    __extends(MiddlewareArray2, _super);
    function MiddlewareArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
      return _this;
    }
    Object.defineProperty(MiddlewareArray2, Symbol.species, {
      get: function() {
        return MiddlewareArray2;
      },
      enumerable: false,
      configurable: true
    });
    MiddlewareArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr[0].concat(this))))();
      }
      return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr.concat(this))))();
    };
    return MiddlewareArray2;
  }(Array)
);
var isProduction = process.env.NODE_ENV === "production";
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  throw new Error(prefix + ": " + (message || ""));
}
function stringify(obj, serializer, indent, decycler) {
  return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}
function getSerialize(serializer, decycler) {
  var stack = [], keys = [];
  if (!decycler)
    decycler = function(_6, value) {
      if (stack[0] === value)
        return "[Circular ~]";
      return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
    };
  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
      if (~stack.indexOf(value))
        value = decycler.call(this, key, value);
    } else
      stack.push(value);
    return serializer == null ? value : serializer.call(this, key, value);
  };
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value === null || typeof value === "undefined" || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations: function() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths, obj, path) {
  if (ignorePaths === void 0) {
    ignorePaths = [];
  }
  if (path === void 0) {
    path = "";
  }
  var tracked = { value: obj };
  if (!isImmutable(obj)) {
    tracked.children = {};
    for (var key in obj) {
      var childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {
  if (ignorePaths === void 0) {
    ignorePaths = [];
  }
  if (sameParentRef === void 0) {
    sameParentRef = false;
  }
  if (path === void 0) {
    path = "";
  }
  var prevObj = trackedProperty ? trackedProperty.value : void 0;
  var sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return { wasMutated: true, path };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return { wasMutated: false };
  }
  var keysToDetect = {};
  for (var key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (var key in obj) {
    keysToDetect[key] = true;
  }
  for (var key in keysToDetect) {
    var childPath = path ? path + "." + key : key;
    if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
      continue;
    }
    var result = detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return { wasMutated: false };
}
function createImmutableStateInvariantMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  if (process.env.NODE_ENV === "production") {
    return function() {
      return function(next) {
        return function(action) {
          return next(action);
        };
      };
    };
  }
  var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;
  ignoredPaths = ignoredPaths || ignore;
  var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
  return function(_c2) {
    var getState = _c2.getState;
    var state = getState();
    var tracker = track(state);
    var result;
    return function(next) {
      return function(action) {
        var measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(function() {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          invariant(!result.wasMutated, "A state mutation was detected between dispatches, in the path '" + (result.path || "") + "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
        });
        var dispatchedAction = next(action);
        measureUtils.measureTime(function() {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          result.wasMutated && invariant(!result.wasMutated, "A state mutation was detected inside a dispatch, in the path: " + (result.path || "") + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  };
}
function isPlain(val) {
  var type = typeof val;
  return type === "undefined" || val === null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject2(val);
}
function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {
  if (path === void 0) {
    path = "";
  }
  if (isSerializable === void 0) {
    isSerializable = isPlain;
  }
  if (ignoredPaths === void 0) {
    ignoredPaths = [];
  }
  var foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  var entries = getEntries != null ? getEntries(value) : Object.entries(value);
  var hasIgnoredPaths = ignoredPaths.length > 0;
  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
    var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];
    var nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath) >= 0) {
      continue;
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  return false;
}
function createSerializableStateInvariantMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  if (process.env.NODE_ENV === "production") {
    return function() {
      return function(next) {
        return function(action) {
          return next(action);
        };
      };
    };
  }
  var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? ["meta.arg", "meta.baseQueryMeta"] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j;
  return function(storeAPI) {
    return function(next) {
      return function(action) {
        var result = next(action);
        var measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
        if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
          measureUtils.measureTime(function() {
            var foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths);
            if (foundActionNonSerializableValue) {
              var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;
              console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
            }
          });
        }
        if (!ignoreState) {
          measureUtils.measureTime(function() {
            var state = storeAPI.getState();
            var foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths);
            if (foundStateNonSerializableValue) {
              var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;
              console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
            }
          });
          measureUtils.warnIfExceeded();
        }
        return result;
      };
    };
  };
}
function isBoolean(x8) {
  return typeof x8 === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  var _c = options.thunk, thunk2 = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e;
  var middlewareArray = new MiddlewareArray();
  if (thunk2) {
    if (isBoolean(thunk2)) {
      middlewareArray.push(es_default);
    } else {
      middlewareArray.push(es_default.withExtraArgument(thunk2.extraArgument));
    }
  }
  if (process.env.NODE_ENV !== "production") {
    if (immutableCheck) {
      var immutableOptions = {};
      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      var serializableOptions = {};
      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
  }
  return middlewareArray;
}
var IS_PRODUCTION = process.env.NODE_ENV === "production";
function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
  var rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject2(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  var finalMiddleware = middleware;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
      throw new Error("when using a middleware builder function, an array of middleware must be returned");
    }
  }
  if (!IS_PRODUCTION && finalMiddleware.some(function(item) {
    return typeof item !== "function";
  })) {
    throw new Error("each middleware provided to configureStore must be a function");
  }
  var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
  var finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  var storeEnhancers = [middlewareEnhancer];
  if (Array.isArray(enhancers)) {
    storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(storeEnhancers);
  }
  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function createAction(type, prepareAction) {
  function actionCreator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type, payload: args[0] };
  }
  actionCreator.toString = function() {
    return "" + type;
  };
  actionCreator.type = type;
  actionCreator.match = function(action) {
    return action.type === type;
  };
  return actionCreator;
}
function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function(typeOrActionCreator, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (actionMatchers.length > 0) {
          throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (type in actionsMap) {
        throw new Error("addCase cannot be called with two reducers for the same action type");
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher: function(matcher, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({ matcher, reducer });
      return builder;
    },
    addDefaultCase: function(reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error("`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x8) {
  return typeof x8 === "function";
}
function createReducer(initialState2, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }
  var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
  var getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = function() {
      return immer_esm_default(initialState2(), function() {
      });
    };
  } else {
    var frozenInitialState_1 = immer_esm_default(initialState2, function() {
    });
    getInitialState = function() {
      return frozenInitialState_1;
    };
  }
  function reducer(state, action) {
    if (state === void 0) {
      state = getInitialState();
    }
    var caseReducers = __spreadArray([
      actionsMap[action.type]
    ], finalActionMatchers.filter(function(_c2) {
      var matcher = _c2.matcher;
      return matcher(action);
    }).map(function(_c2) {
      var reducer2 = _c2.reducer;
      return reducer2;
    }));
    if (caseReducers.filter(function(cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce(function(previousState, caseReducer) {
      if (caseReducer) {
        if (r(previousState)) {
          var draft = previousState;
          var result = caseReducer(draft, action);
          if (typeof result === "undefined") {
            return previousState;
          }
          return result;
        } else if (!t2(previousState)) {
          var result = caseReducer(previousState, action);
          if (typeof result === "undefined") {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return immer_esm_default(previousState, function(draft2) {
            return caseReducer(draft2, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
function getType2(slice, actionKey) {
  return slice + "/" + actionKey;
}
function createSlice(options) {
  var name = options.name;
  if (!name) {
    throw new Error("`name` is a required option for createSlice");
  }
  var initialState2 = typeof options.initialState == "function" ? options.initialState : immer_esm_default(options.initialState, function() {
  });
  var reducers = options.reducers || {};
  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function(reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type = getType2(name, reducerName);
    var caseReducer;
    var prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
  });
  function buildReducer() {
    var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
    var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState2, finalCaseReducers, actionMatchers, defaultCaseReducer);
  }
  var _reducer;
  return {
    name,
    reducer: function(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState: function() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = "task-" + cancelled;
var taskCompleted = "task-" + completed;
var listenerCancelled = listener + "-" + cancelled;
var listenerCompleted = listener + "-" + completed;
var alm = "listenerMiddleware";
var addListener = createAction(alm + "/add");
var clearAllListeners = createAction(alm + "/removeAll");
var removeListener = createAction(alm + "/remove");
F();

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-CK75LBHF.js
var L3;
var f5;
var p5 = Dr(() => {
  v();
  T();
  L3 = createAction(g), f5 = createAction(l, (e6) => ({ payload: e6 }));
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OULOPE3W.js
var import_dist36 = __toESM(require_dist());
var import_lodash = __toESM(require_lodash());

// node_modules/redux-persist/es/index.js
var import_dist35 = __toESM(require_dist());

// node_modules/redux-persist/es/persistReducer.js
var import_dist29 = __toESM(require_dist());

// node_modules/redux-persist/es/constants.js
var import_dist24 = __toESM(require_dist());
var KEY_PREFIX = "persist:";
var FLUSH = "persist/FLUSH";
var REHYDRATE = "persist/REHYDRATE";
var PAUSE = "persist/PAUSE";
var PERSIST = "persist/PERSIST";
var PURGE = "persist/PURGE";
var REGISTER = "persist/REGISTER";
var DEFAULT_VERSION = -1;

// node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js
var import_dist25 = __toESM(require_dist());
function _typeof2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof3(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i11 = 1; i11 < arguments.length; i11++) {
    var source = arguments[i11] != null ? arguments[i11] : {};
    if (i11 % 2) {
      ownKeys2(source, true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
  var debug = _ref.debug;
  var newState = _objectSpread({}, reducedState);
  if (inboundState && _typeof2(inboundState) === "object") {
    Object.keys(inboundState).forEach(function(key) {
      if (key === "_persist") return;
      if (originalState[key] !== reducedState[key]) {
        if (process.env.NODE_ENV !== "production" && debug) console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
        return;
      }
      newState[key] = inboundState[key];
    });
  }
  if (process.env.NODE_ENV !== "production" && debug && inboundState && _typeof2(inboundState) === "object") console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(", "), "'"));
  return newState;
}

// node_modules/redux-persist/es/createPersistoid.js
var import_dist26 = __toESM(require_dist());
function createPersistoid(config) {
  var blacklist = config.blacklist || null;
  var whitelist = config.whitelist || null;
  var transforms = config.transforms || [];
  var throttle = config.throttle || 0;
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  var storage = config.storage;
  var serialize;
  if (config.serialize === false) {
    serialize = function serialize2(x8) {
      return x8;
    };
  } else if (typeof config.serialize === "function") {
    serialize = config.serialize;
  } else {
    serialize = defaultSerialize;
  }
  var writeFailHandler = config.writeFailHandler || null;
  var lastState = {};
  var stagedState = {};
  var keysToProcess = [];
  var timeIterator = null;
  var writePromise = null;
  var update = function update2(state) {
    Object.keys(state).forEach(function(key) {
      if (!passWhitelistBlacklist(key)) return;
      if (lastState[key] === state[key]) return;
      if (keysToProcess.indexOf(key) !== -1) return;
      keysToProcess.push(key);
    });
    Object.keys(lastState).forEach(function(key) {
      if (state[key] === void 0 && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== void 0) {
        keysToProcess.push(key);
      }
    });
    if (timeIterator === null) {
      timeIterator = setInterval(processNextKey, throttle);
    }
    lastState = state;
  };
  function processNextKey() {
    if (keysToProcess.length === 0) {
      if (timeIterator) clearInterval(timeIterator);
      timeIterator = null;
      return;
    }
    var key = keysToProcess.shift();
    var endState = transforms.reduce(function(subState, transformer) {
      return transformer.in(subState, key, lastState);
    }, lastState[key]);
    if (endState !== void 0) {
      try {
        stagedState[key] = serialize(endState);
      } catch (err) {
        console.error("redux-persist/createPersistoid: error serializing state", err);
      }
    } else {
      delete stagedState[key];
    }
    if (keysToProcess.length === 0) {
      writeStagedState();
    }
  }
  function writeStagedState() {
    Object.keys(stagedState).forEach(function(key) {
      if (lastState[key] === void 0) {
        delete stagedState[key];
      }
    });
    writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
  }
  function passWhitelistBlacklist(key) {
    if (whitelist && whitelist.indexOf(key) === -1 && key !== "_persist") return false;
    if (blacklist && blacklist.indexOf(key) !== -1) return false;
    return true;
  }
  function onWriteFail(err) {
    if (writeFailHandler) writeFailHandler(err);
    if (err && process.env.NODE_ENV !== "production") {
      console.error("Error storing data", err);
    }
  }
  var flush = function flush2() {
    while (keysToProcess.length !== 0) {
      processNextKey();
    }
    return writePromise || Promise.resolve();
  };
  return {
    update,
    flush
  };
}
function defaultSerialize(data) {
  return JSON.stringify(data);
}

// node_modules/redux-persist/es/getStoredState.js
var import_dist27 = __toESM(require_dist());
function getStoredState(config) {
  var transforms = config.transforms || [];
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  var storage = config.storage;
  var debug = config.debug;
  var deserialize;
  if (config.deserialize === false) {
    deserialize = function deserialize2(x8) {
      return x8;
    };
  } else if (typeof config.deserialize === "function") {
    deserialize = config.deserialize;
  } else {
    deserialize = defaultDeserialize;
  }
  return storage.getItem(storageKey).then(function(serialized) {
    if (!serialized) return void 0;
    else {
      try {
        var state = {};
        var rawState = deserialize(serialized);
        Object.keys(rawState).forEach(function(key) {
          state[key] = transforms.reduceRight(function(subState, transformer) {
            return transformer.out(subState, key, rawState);
          }, deserialize(rawState[key]));
        });
        return state;
      } catch (err) {
        if (process.env.NODE_ENV !== "production" && debug) console.log("redux-persist/getStoredState: Error restoring data ".concat(serialized), err);
        throw err;
      }
    }
  });
}
function defaultDeserialize(serial) {
  return JSON.parse(serial);
}

// node_modules/redux-persist/es/purgeStoredState.js
var import_dist28 = __toESM(require_dist());
function purgeStoredState(config) {
  var storage = config.storage;
  var storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  return storage.removeItem(storageKey, warnIfRemoveError);
}
function warnIfRemoveError(err) {
  if (err && process.env.NODE_ENV !== "production") {
    console.error("redux-persist/purgeStoredState: Error purging data stored state", err);
  }
}

// node_modules/redux-persist/es/persistReducer.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i11 = 1; i11 < arguments.length; i11++) {
    var source = arguments[i11] != null ? arguments[i11] : {};
    if (i11 % 2) {
      ownKeys3(source, true).forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i11;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i11 = 0; i11 < sourceSymbolKeys.length; i11++) {
      key = sourceSymbolKeys[i11];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i11;
  for (i11 = 0; i11 < sourceKeys.length; i11++) {
    key = sourceKeys[i11];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var DEFAULT_TIMEOUT = 5e3;
function persistReducer(config, baseReducer) {
  if (process.env.NODE_ENV !== "production") {
    if (!config) throw new Error("config is required for persistReducer");
    if (!config.key) throw new Error("key is required in persistor config");
    if (!config.storage) throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
  }
  var version = config.version !== void 0 ? config.version : DEFAULT_VERSION;
  var debug = config.debug || false;
  var stateReconciler = config.stateReconciler === void 0 ? autoMergeLevel1 : config.stateReconciler;
  var getStoredState2 = config.getStoredState || getStoredState;
  var timeout = config.timeout !== void 0 ? config.timeout : DEFAULT_TIMEOUT;
  var _persistoid = null;
  var _purge = false;
  var _paused = true;
  var conditionalUpdate = function conditionalUpdate2(state) {
    state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
    return state;
  };
  return function(state, action) {
    var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties(_ref, ["_persist"]);
    var restState = rest;
    if (action.type === PERSIST) {
      var _sealed = false;
      var _rehydrate = function _rehydrate2(payload, err) {
        if (process.env.NODE_ENV !== "production" && _sealed) console.error('redux-persist: rehydrate for "'.concat(config.key, '" called after timeout.'), payload, err);
        if (!_sealed) {
          action.rehydrate(config.key, payload, err);
          _sealed = true;
        }
      };
      timeout && setTimeout(function() {
        !_sealed && _rehydrate(void 0, new Error('redux-persist: persist timed out for persist key "'.concat(config.key, '"')));
      }, timeout);
      _paused = false;
      if (!_persistoid) _persistoid = createPersistoid(config);
      if (_persist) {
        return _objectSpread3({}, baseReducer(restState, action), {
          _persist
        });
      }
      if (typeof action.rehydrate !== "function" || typeof action.register !== "function") throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
      action.register(config.key);
      getStoredState2(config).then(function(restoredState) {
        var migrate = config.migrate || function(s9, v7) {
          return Promise.resolve(s9);
        };
        migrate(restoredState, version).then(function(migratedState) {
          _rehydrate(migratedState);
        }, function(migrateErr) {
          if (process.env.NODE_ENV !== "production" && migrateErr) console.error("redux-persist: migration error", migrateErr);
          _rehydrate(void 0, migrateErr);
        });
      }, function(err) {
        _rehydrate(void 0, err);
      });
      return _objectSpread3({}, baseReducer(restState, action), {
        _persist: {
          version,
          rehydrated: false
        }
      });
    } else if (action.type === PURGE) {
      _purge = true;
      action.result(purgeStoredState(config));
      return _objectSpread3({}, baseReducer(restState, action), {
        _persist
      });
    } else if (action.type === FLUSH) {
      action.result(_persistoid && _persistoid.flush());
      return _objectSpread3({}, baseReducer(restState, action), {
        _persist
      });
    } else if (action.type === PAUSE) {
      _paused = true;
    } else if (action.type === REHYDRATE) {
      if (_purge) return _objectSpread3({}, restState, {
        _persist: _objectSpread3({}, _persist, {
          rehydrated: true
        })
        // @NOTE if key does not match, will continue to default else below
      });
      if (action.key === config.key) {
        var reducedState = baseReducer(restState, action);
        var inboundState = action.payload;
        var reconciledRest = stateReconciler !== false && inboundState !== void 0 ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
        var _newState = _objectSpread3({}, reconciledRest, {
          _persist: _objectSpread3({}, _persist, {
            rehydrated: true
          })
        });
        return conditionalUpdate(_newState);
      }
    }
    if (!_persist) return baseReducer(state, action);
    var newState = baseReducer(restState, action);
    if (newState === restState) return state;
    return conditionalUpdate(_objectSpread3({}, newState, {
      _persist
    }));
  };
}

// node_modules/redux-persist/es/persistCombineReducers.js
var import_dist31 = __toESM(require_dist());

// node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js
var import_dist30 = __toESM(require_dist());

// node_modules/redux-persist/es/persistStore.js
var import_dist32 = __toESM(require_dist());
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i11 = 0, arr2 = new Array(arr.length); i11 < arr.length; i11++) {
      arr2[i11] = arr[i11];
    }
    return arr2;
  }
}
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i11 = 1; i11 < arguments.length; i11++) {
    var source = arguments[i11] != null ? arguments[i11] : {};
    if (i11 % 2) {
      ownKeys4(source, true).forEach(function(key) {
        _defineProperty4(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys4(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var initialState = {
  registry: [],
  bootstrapped: false
};
var persistorReducer = function persistorReducer2() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  switch (action.type) {
    case REGISTER:
      return _objectSpread4({}, state, {
        registry: [].concat(_toConsumableArray(state.registry), [action.key])
      });
    case REHYDRATE:
      var firstIndex = state.registry.indexOf(action.key);
      var registry = _toConsumableArray(state.registry);
      registry.splice(firstIndex, 1);
      return _objectSpread4({}, state, {
        registry,
        bootstrapped: registry.length === 0
      });
    default:
      return state;
  }
};
function persistStore(store, options, cb) {
  if (process.env.NODE_ENV !== "production") {
    var optionsToTest = options || {};
    var bannedKeys = ["blacklist", "whitelist", "transforms", "storage", "keyPrefix", "migrate"];
    bannedKeys.forEach(function(k4) {
      if (!!optionsToTest[k4]) console.error('redux-persist: invalid option passed to persistStore: "'.concat(k4, '". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.'));
    });
  }
  var boostrappedCb = cb || false;
  var _pStore = createStore(persistorReducer, initialState, options && options.enhancer ? options.enhancer : void 0);
  var register = function register2(key) {
    _pStore.dispatch({
      type: REGISTER,
      key
    });
  };
  var rehydrate = function rehydrate2(key, payload, err) {
    var rehydrateAction = {
      type: REHYDRATE,
      payload,
      err,
      key
      // dispatch to `store` to rehydrate and `persistor` to track result
    };
    store.dispatch(rehydrateAction);
    _pStore.dispatch(rehydrateAction);
    if (boostrappedCb && persistor.getState().bootstrapped) {
      boostrappedCb();
      boostrappedCb = false;
    }
  };
  var persistor = _objectSpread4({}, _pStore, {
    purge: function purge() {
      var results = [];
      store.dispatch({
        type: PURGE,
        result: function result(purgeResult) {
          results.push(purgeResult);
        }
      });
      return Promise.all(results);
    },
    flush: function flush() {
      var results = [];
      store.dispatch({
        type: FLUSH,
        result: function result(flushResult) {
          results.push(flushResult);
        }
      });
      return Promise.all(results);
    },
    pause: function pause() {
      store.dispatch({
        type: PAUSE
      });
    },
    persist: function persist() {
      store.dispatch({
        type: PERSIST,
        register,
        rehydrate
      });
    }
  });
  if (!(options && options.manualPersist)) {
    persistor.persist();
  }
  return persistor;
}

// node_modules/redux-persist/es/createMigrate.js
var import_dist33 = __toESM(require_dist());
function createMigrate(migrations, config) {
  var _ref = config || {}, debug = _ref.debug;
  return function(state, currentVersion) {
    if (!state) {
      if (process.env.NODE_ENV !== "production" && debug) console.log("redux-persist: no inbound state, skipping migration");
      return Promise.resolve(void 0);
    }
    var inboundVersion = state._persist && state._persist.version !== void 0 ? state._persist.version : DEFAULT_VERSION;
    if (inboundVersion === currentVersion) {
      if (process.env.NODE_ENV !== "production" && debug) console.log("redux-persist: versions match, noop migration");
      return Promise.resolve(state);
    }
    if (inboundVersion > currentVersion) {
      if (process.env.NODE_ENV !== "production") console.error("redux-persist: downgrading version is not supported");
      return Promise.resolve(state);
    }
    var migrationKeys = Object.keys(migrations).map(function(ver) {
      return parseInt(ver);
    }).filter(function(key) {
      return currentVersion >= key && key > inboundVersion;
    }).sort(function(a9, b8) {
      return a9 - b8;
    });
    if (process.env.NODE_ENV !== "production" && debug) console.log("redux-persist: migrationKeys", migrationKeys);
    try {
      var migratedState = migrationKeys.reduce(function(state2, versionKey) {
        if (process.env.NODE_ENV !== "production" && debug) console.log("redux-persist: running migration for versionKey", versionKey);
        return migrations[versionKey](state2);
      }, state);
      return Promise.resolve(migratedState);
    } catch (err) {
      return Promise.reject(err);
    }
  };
}

// node_modules/redux-persist/es/createTransform.js
var import_dist34 = __toESM(require_dist());

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OULOPE3W.js
var N2;
var T2;
var p6;
var O2;
var _3;
var z2;
var F2;
var g4 = Dr(() => {
  v();
  _();
  p5();
  p3();
  N2 = { id: "not-configured", chainId: "", name: "NOT CONFIGURED", egldLabel: "", decimals: "18", digits: "4", gasPerDataByte: "1500", walletConnectDeepLink: "", walletConnectBridgeAddress: "", walletConnectV2RelayAddress: "", walletConnectV2ProjectId: "", walletConnectV2Options: {}, walletAddress: "", apiAddress: "", explorerAddress: "", apiTimeout: "4000", roundDuration: 6e3 }, T2 = { network: N2 }, p6 = createSlice({ name: "appConfig", initialState: T2, reducers: { initializeNetworkConfig: (e6, t7) => {
    let r5 = m(t7.payload.walletConnectV2RelayAddresses), n9 = (0, import_lodash.default)(t7.payload, "walletConnectV2RelayAddresses");
    e6.network = xt(yt(yt({}, e6.network), n9), { walletConnectV2RelayAddress: r5 });
  }, updateNetworkConfig: (e6, t7) => {
    e6.network = yt(yt({}, e6.network), t7.payload);
  }, setCustomWalletAddress: (e6, t7) => {
    e6.network.customWalletAddress = t7.payload;
  } }, extraReducers: (e6) => {
    e6.addCase(L3, (t7) => {
      t7.network.customWalletAddress = void 0;
    }), e6.addCase(REHYDRATE, (t7, r5) => {
      var a9, d8;
      if (!((d8 = (a9 = r5.payload) == null ? void 0 : a9.network) != null && d8.customWalletAddress)) return;
      let { network: { customWalletAddress: n9 } } = r5.payload;
      t7.network.customWalletAddress = n9;
    });
  } }), { initializeNetworkConfig: O2, updateNetworkConfig: _3, setCustomWalletAddress: z2 } = p6.actions, F2 = p6.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-VNUU3UJ4.js
var import_dist37 = __toESM(require_dist());
var i5;
var r2;
var A2;
var E3;
var b2;
var R3;
var f6 = Dr(() => {
  v();
  u();
  p5();
  i5 = { isSigning: false, signedSessions: {} }, r2 = createSlice({ name: "signedMessageInfoSliceState", initialState: i5, reducers: { setSignSession: (e6, n9) => {
    let { sessionId: t7, signedSession: a9, errorMessage: o9 } = n9.payload;
    o9 && (e6.errorMessage = o9), e6.isSigning = a9.status === "pending", e6.signedSessions[t7] = yt(yt({}, e6.signedSessions[t7]), a9);
  }, setSignSessionState: (e6, n9) => yt(yt({}, e6), n9.payload), clearSignedMessageInfo: () => i5 }, extraReducers: (e6) => {
    e6.addCase(L3, () => i5);
  } }), { setSignSession: A2, clearSignedMessageInfo: E3, setSignSessionState: b2 } = r2.actions, R3 = r2.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-WTIKHG7D.js
var import_dist38 = __toESM(require_dist());
var i6;
var n4 = Dr(() => {
  v();
  i6 = () => Date.now() / 1e3;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4DD6JL4B.js
var import_dist39 = __toESM(require_dist());
var d3;
var u8;
var U2;
var Y2;
var j2;
var k2;
var q2;
var g5 = Dr(() => {
  v();
  u();
  n4();
  p5();
  d3 = { customToasts: [], transactionToasts: [] }, u8 = createSlice({ name: "toastsSlice", initialState: d3, reducers: { addCustomToast: (t7, o9) => {
    let s9 = o9.payload.toastId || `custom-toast-${t7.customToasts.length + 1}`, a9 = t7.customToasts.findIndex((e6) => e6.toastId === s9);
    if (a9 !== -1) {
      t7.customToasts[a9] = xt(yt(yt({}, t7.customToasts[a9]), o9.payload), { type: "custom", toastId: s9 });
      return;
    }
    t7.customToasts.push(xt(yt({}, o9.payload), { type: "custom", toastId: s9 }));
  }, removeCustomToast: (t7, o9) => {
    t7.customToasts = t7.customToasts.filter((s9) => s9.toastId !== o9.payload);
  }, addTransactionToast: (t7, o9) => {
    t7.transactionToasts.push({ type: "transaction", startTimestamp: i6(), toastId: o9.payload || `custom-toast-${t7.transactionToasts.length + 1}` });
  }, removeTransactionToast: (t7, o9) => {
    t7.transactionToasts = t7.transactionToasts.filter((s9) => s9.toastId !== o9.payload);
  } }, extraReducers: (t7) => {
    t7.addCase(L3, () => d3), t7.addCase(REHYDRATE, (o9, s9) => {
      var e6, c9;
      let a9 = (c9 = (e6 = s9.customToasts) == null ? void 0 : e6.filter((p14) => !("component" in p14))) != null ? c9 : [];
      o9.customToasts = a9;
    });
  } }), { addCustomToast: U2, removeCustomToast: Y2, addTransactionToast: j2, removeTransactionToast: k2 } = u8.actions, q2 = u8.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-V2IOPWW3.js
var import_dist40 = __toESM(require_dist());
var l4;
var u9;
var p7;
var g6;
var t3;
var c4;
var P2;
var b3;
var A3;
var F3;
var f7 = Dr(() => {
  v();
  p5();
  l4 = "Transaction failed", u9 = "Transaction successful", p7 = "Processing transaction", g6 = "Transaction submitted", t3 = {}, c4 = createSlice({ name: "transactionsInfo", initialState: t3, reducers: { setTransactionsDisplayInfo(s9, a9) {
    let { sessionId: o9, transactionsDisplayInfo: e6 } = a9.payload;
    o9 != null && (s9[o9] = { errorMessage: (e6 == null ? void 0 : e6.errorMessage) || l4, successMessage: (e6 == null ? void 0 : e6.successMessage) || u9, processingMessage: (e6 == null ? void 0 : e6.processingMessage) || p7, submittedMessage: (e6 == null ? void 0 : e6.submittedMessage) || g6, transactionDuration: e6 == null ? void 0 : e6.transactionDuration });
  }, clearTransactionsInfoForSessionId(s9, a9) {
    a9.payload != null && delete s9[a9.payload];
  }, clearTransactionsInfo: () => t3 }, extraReducers: (s9) => {
    s9.addCase(L3, () => t3);
  } }), { clearTransactionsInfo: P2, setTransactionsDisplayInfo: b3, clearTransactionsInfoForSessionId: A3 } = c4.actions, F3 = c4.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-HNDDVE4V.js
var import_dist41 = __toESM(require_dist());
function j3(n9) {
  return n9 != null && (m3(n9) || h2(n9));
}
function k3(n9) {
  return n9 != null && (E4(n9) || v3(n9));
}
function q3(n9) {
  return n9 != null && (d4(n9) || B2(n9));
}
function w3(n9) {
  return n9 != null && (p8(n9) || f8(n9));
}
function y2(n9) {
  return n9 != null && x4(n9);
}
function m3(n9) {
  return n9 != null && s5.includes(n9);
}
function E4(n9) {
  return n9 != null && r3.includes(n9);
}
function d4(n9) {
  return n9 != null && c5.includes(n9);
}
function p8(n9) {
  return n9 != null && u10.includes(n9);
}
function x4(n9) {
  return n9 != null && i7.includes(n9);
}
function h2(n9) {
  return n9 != null && o4.includes(n9);
}
function v3(n9) {
  return n9 != null && S2.includes(n9);
}
function B2(n9) {
  return n9 != null && T3.includes(n9);
}
function f8(n9) {
  return n9 != null && l5.includes(n9);
}
var s5;
var r3;
var c5;
var u10;
var i7;
var o4;
var S2;
var T3;
var l5;
var g7 = Dr(() => {
  v();
  Q();
  s5 = ["sent"], r3 = ["success"], c5 = ["fail", "cancelled", "timedOut"], u10 = ["invalid"], i7 = ["timedOut"], o4 = ["pending"], S2 = ["success"], T3 = ["fail", "invalid"], l5 = ["not executed"];
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ATR67GE7.js
var import_dist42 = __toESM(require_dist());
var S3;
var N3;
var v4;
var V;
var X2;
var Z2;
var _4;
var $;
var nn2;
var sn2;
var an2;
var on2;
var tn2;
var rn2;
var en2;
var b4 = Dr(() => {
  v();
  Q();
  g7();
  p5();
  S3 = { signedTransactions: {}, transactionsToSign: null, signTransactionsError: null, signTransactionsCancelMessage: null, customTransactionInformationForSessionId: {} }, N3 = { signWithoutSending: false, sessionInformation: null, redirectAfterSign: false }, v4 = createSlice({ name: "transactionsSlice", initialState: S3, reducers: { moveTransactionsToSignedState: (n9, a9) => {
    var d8, l8;
    let { sessionId: s9, transactions: o9, errorMessage: t7, status: c9, redirectRoute: r5, customTransactionInformation: T7 } = a9.payload;
    n9.customTransactionInformationForSessionId[s9] = yt(yt(yt({}, N3), ((d8 = n9.signedTransactions[s9]) == null ? void 0 : d8.customTransactionInformation) || {}), n9.customTransactionInformationForSessionId[s9] || {}), n9.signedTransactions[s9] = { transactions: o9, status: c9, errorMessage: t7, redirectRoute: r5, customTransactionInformation: yt(yt({}, n9.customTransactionInformationForSessionId[s9]), T7 != null ? T7 : {}) }, ((l8 = n9 == null ? void 0 : n9.transactionsToSign) == null ? void 0 : l8.sessionId) === s9 && (n9.transactionsToSign = S3.transactionsToSign);
  }, clearSignedTransaction: (n9, a9) => {
    n9.signedTransactions[a9.payload] && delete n9.signedTransactions[a9.payload];
  }, clearTransactionToSign: (n9) => {
    n9 != null && n9.transactionsToSign && (n9.transactionsToSign = null);
  }, updateSignedTransaction: (n9, a9) => {
    n9.signedTransactions = yt(yt({}, n9.signedTransactions), a9.payload);
  }, updateSignedTransactions: (n9, a9) => {
    let { sessionId: s9, status: o9, errorMessage: t7, transactions: c9 } = a9.payload;
    n9.signedTransactions[s9] != null && (n9.signedTransactions[s9].status = o9, t7 != null && (n9.signedTransactions[s9].errorMessage = t7), c9 != null && (n9.signedTransactions[s9].transactions = c9));
  }, updateSignedTransactionStatus: (n9, a9) => {
    var l8, u13, g13, m9, p14, y7, f13, I2;
    let { sessionId: s9, status: o9, errorMessage: t7, transactionHash: c9, serverTransaction: r5, inTransit: T7 } = a9.payload, d8 = (u13 = (l8 = n9.signedTransactions) == null ? void 0 : l8[s9]) == null ? void 0 : u13.transactions;
    if (d8 != null) {
      n9.signedTransactions[s9].transactions = d8.map((e6) => e6.hash === c9 ? xt(yt(yt({}, r5 != null ? r5 : {}), e6), { status: o9, errorMessage: t7, inTransit: T7 }) : e6);
      let F6 = (m9 = (g13 = n9.signedTransactions[s9]) == null ? void 0 : g13.transactions) == null ? void 0 : m9.every((e6) => k3(e6.status)), h4 = (y7 = (p14 = n9.signedTransactions[s9]) == null ? void 0 : p14.transactions) == null ? void 0 : y7.some((e6) => q3(e6.status)), H3 = (I2 = (f13 = n9.signedTransactions[s9]) == null ? void 0 : f13.transactions) == null ? void 0 : I2.every((e6) => w3(e6.status));
      F6 && (n9.signedTransactions[s9].status = "success"), h4 && (n9.signedTransactions[s9].status = "fail"), H3 && (n9.signedTransactions[s9].status = "invalid");
    }
  }, setTransactionsToSign: (n9, a9) => {
    n9.transactionsToSign = a9.payload;
    let { sessionId: s9, customTransactionInformation: o9 } = a9.payload;
    n9.customTransactionInformationForSessionId[s9] = o9, n9.signTransactionsError = null;
  }, clearAllTransactionsToSign: (n9) => {
    n9.transactionsToSign = S3.transactionsToSign, n9.signTransactionsError = null;
  }, clearAllSignedTransactions: (n9) => {
    n9.signedTransactions = S3.signedTransactions;
  }, setSignTransactionsError: (n9, a9) => {
    n9.signTransactionsError = a9.payload;
  }, setSignTransactionsCancelMessage: (n9, a9) => {
    n9.signTransactionsCancelMessage = a9.payload;
  }, updateSignedTransactionsCustomTransactionInformation: (n9, a9) => {
    let { sessionId: s9, customTransactionInformationOverrides: o9 } = a9.payload;
    n9.signedTransactions[s9] != null && (n9.signedTransactions[s9].customTransactionInformation = yt(yt({}, n9.signedTransactions[s9].customTransactionInformation), o9));
  } }, extraReducers: (n9) => {
    n9.addCase(L3, () => S3), n9.addCase(REHYDRATE, (a9, s9) => {
      var r5;
      if (a9.signTransactionsCancelMessage = null, !((r5 = s9.payload) != null && r5.transactions)) return;
      let { signedTransactions: o9, customTransactionInformationForSessionId: t7 } = s9.payload.transactions, c9 = Object.entries(o9).reduce((T7, [d8, l8]) => {
        let u13 = new Date(d8), g13 = /* @__PURE__ */ new Date();
        return g13.setHours(g13.getHours() + 5), g13 - u13 > 0 || (T7[d8] = l8), T7;
      }, {});
      t7 != null && (a9.customTransactionInformationForSessionId = t7), o9 != null && (a9.signedTransactions = c9);
    });
  } }), { updateSignedTransactionStatus: V, updateSignedTransactions: X2, setTransactionsToSign: Z2, clearAllTransactionsToSign: _4, clearAllSignedTransactions: $, clearSignedTransaction: nn2, clearTransactionToSign: sn2, setSignTransactionsError: an2, setSignTransactionsCancelMessage: on2, moveTransactionsToSignedState: tn2, updateSignedTransactionsCustomTransactionInformation: rn2 } = v4.actions, en2 = v4.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-5KGDRZSV.js
var import_dist43 = __toESM(require_dist());
var o5;
var n5 = Dr(() => {
  v();
  o5 = (t7) => (/* @__PURE__ */ new Date()).setMilliseconds((/* @__PURE__ */ new Date()).getMilliseconds() + t7) / 1e3;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-HGOHQNWK.js
var import_dist44 = __toESM(require_dist());
var r4;
var d5 = Dr(() => {
  v();
  r4 = (t7) => (/* @__PURE__ */ new Date()).setSeconds((/* @__PURE__ */ new Date()).getSeconds() + t7);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-6XR6BLIB.js
var import_dist45 = __toESM(require_dist());
var p9 = Dr(() => {
  v();
  n4();
  n5();
  d5();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-W7SO52DM.js
var import_dist46 = __toESM(require_dist());
var m4 = {};
Ft(m4, { clear: () => u11, getItem: () => y3, localStorageKeys: () => i8, removeItem: () => g8, setItem: () => c6 });
var i8;
var o6;
var c6;
var y3;
var g8;
var u11;
var f9 = Dr(() => {
  v();
  p9();
  i8 = { loginExpiresAt: "sdk-dapp-login-expires-at", logoutEvent: "sdk-dapp-logout-event" }, o6 = typeof localStorage != "undefined", c6 = ({ key: t7, data: r5, expires: e6 }) => {
    !o6 || localStorage.setItem(String(t7), JSON.stringify({ expires: e6, data: r5 }));
  }, y3 = (t7) => {
    if (!o6) return;
    let r5 = localStorage.getItem(String(t7));
    if (!r5) return null;
    let e6 = JSON.parse(r5);
    return !e6 || !e6.hasOwnProperty("expires") || !e6.hasOwnProperty("data") ? null : i6() >= e6.expires ? (localStorage.removeItem(String(t7)), null) : e6.data;
  }, g8 = (t7) => {
    !o6 || localStorage.removeItem(String(t7));
  }, u11 = () => {
    !o6 || localStorage.clear();
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-PXHBOM4A.js
var import_dist47 = __toESM(require_dist());
var m5 = {};
Ft(m5, { clear: () => a3, getItem: () => n6, removeItem: () => i9, setItem: () => o7, storage: () => S4 });
var o7;
var n6;
var i9;
var a3;
var S4;
var g9 = Dr(() => {
  v();
  o7 = ({ key: t7, data: s9, expires: e6 }) => {
    sessionStorage.setItem(String(t7), JSON.stringify({ expires: e6, data: s9 }));
  }, n6 = (t7) => {
    let s9 = sessionStorage.getItem(String(t7));
    if (!s9) return null;
    let e6 = JSON.parse(s9);
    return !e6 || !e6.hasOwnProperty("expires") || !e6.hasOwnProperty("data") ? null : Date.now() >= e6.expires ? (sessionStorage.removeItem(String(t7)), null) : e6.data;
  }, i9 = (t7) => sessionStorage.removeItem(String(t7)), a3 = () => sessionStorage.clear(), S4 = { setItem: o7, getItem: n6, removeItem: i9, clear: a3 };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-WISLI42M.js
var import_dist48 = __toESM(require_dist());
var f10;
var e4 = Dr(() => {
  v();
  f9();
  g9();
  f10 = { session: m5, local: m4 };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-IQEG76GP.js
var import_dist49 = __toESM(require_dist());
var import_sdk_core = __toESM(require_out());
var g10;
var a4;
var m6;
var O3;
var Y3;
var Z3;
var j4;
var q4;
var z3;
var F4;
var J;
var M2;
var Q3;
var V2;
var X3;
var w4 = Dr(() => {
  v();
  T();
  e4();
  f9();
  p5();
  g10 = { balance: "...", address: "", isGuarded: false, nonce: 0, txCount: 0, scrCount: 0, claimableRewards: u2 }, a4 = { address: "", websocketEvent: null, websocketBatchEvent: null, accounts: { "": g10 }, ledgerAccount: null, publicKey: "", walletConnectAccount: null, isAccountLoading: true, accountLoadingError: null }, m6 = createSlice({ name: "accountInfoSlice", initialState: a4, reducers: { setAddress: (o9, e6) => {
    let c9 = e6.payload;
    o9.address = c9, o9.publicKey = c9 ? new import_sdk_core.Address(c9).hex() : "";
  }, setAccount: (o9, e6) => {
    let c9 = o9.address === e6.payload.address;
    o9.accounts = { [o9.address]: c9 ? e6.payload : g10 }, o9.shard = e6.payload.shard, o9.isAccountLoading = false, o9.accountLoadingError = null;
  }, setAccountNonce: (o9, e6) => {
    let { address: c9 } = o9;
    o9.accounts[c9].nonce = e6.payload;
  }, setAccountShard: (o9, e6) => {
    o9.shard = e6.payload;
  }, setLedgerAccount: (o9, e6) => {
    o9.ledgerAccount = e6.payload;
  }, updateLedgerAccount: (o9, e6) => {
    o9.ledgerAccount != null && (o9.ledgerAccount.index = e6.payload.index, o9.ledgerAccount.address = e6.payload.address);
  }, setWalletConnectAccount: (o9, e6) => {
    o9.walletConnectAccount = e6.payload;
  }, setIsAccountLoading: (o9, e6) => {
    o9.isAccountLoading = e6.payload, o9.accountLoadingError = null;
  }, setAccountLoadingError: (o9, e6) => {
    o9.accountLoadingError = e6.payload, o9.isAccountLoading = false;
  }, setWebsocketEvent: (o9, e6) => {
    o9.websocketEvent = { timestamp: Date.now(), message: e6.payload };
  }, setWebsocketBatchEvent: (o9, e6) => {
    o9.websocketBatchEvent = { timestamp: Date.now(), data: e6.payload };
  } }, extraReducers: (o9) => {
    o9.addCase(L3, () => (f10.local.removeItem(i8.loginExpiresAt), a4)), o9.addCase(f5, (e6, c9) => {
      let { address: n9 } = c9.payload;
      e6.address = n9, e6.publicKey = new import_sdk_core.Address(n9).hex();
    }), o9.addCase(REHYDRATE, (e6, c9) => {
      var d8;
      if (!((d8 = c9.payload) != null && d8.account)) return;
      let { account: n9 } = c9.payload, { address: s9, shard: f13, accounts: t7, publicKey: T7 } = n9;
      e6.address = s9, e6.shard = f13;
      let b8 = t7 && s9 in t7;
      e6.accounts = b8 ? t7 : a4.accounts, e6.publicKey = T7;
    });
  } }), { setAccount: O3, setAddress: Y3, setAccountNonce: Z3, setAccountShard: j4, setLedgerAccount: q4, updateLedgerAccount: z3, setWalletConnectAccount: F4, setIsAccountLoading: J, setAccountLoadingError: M2, setWebsocketEvent: Q3, setWebsocketBatchEvent: V2 } = m6.actions, X3 = m6.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-O7YCFEFT.js
var import_dist50 = __toESM(require_dist());
var c7;
var n7;
var S5;
var u12;
var m7;
var A4;
var b5;
var l6 = Dr(() => {
  v();
  p5();
  c7 = {}, n7 = createSlice({ name: "batchTransactionsSlice", initialState: c7, reducers: { setBatchTransactions: (a9, t7) => {
    a9[t7.payload.id] = t7.payload;
  }, updateBatchTransactions: (a9, t7) => {
    a9[t7.payload.id] = t7.payload;
  }, clearBatchTransactions: (a9, t7) => {
    delete a9[t7.payload.batchId];
  }, clearAllBatchTransactions: () => c7 }, extraReducers: (a9) => {
    a9.addCase(L3, () => c7);
  } }), { setBatchTransactions: S5, updateBatchTransactions: u12, clearBatchTransactions: m7, clearAllBatchTransactions: A4 } = n7.actions, b5 = n7.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-FBK2N3YE.js
var import_dist51 = __toESM(require_dist());
var o8;
var a5;
var y5;
var D3;
var f11 = Dr(() => {
  v();
  p5();
  o8 = {}, a5 = createSlice({ name: "dappConfigSlice", initialState: o8, reducers: { setDappConfig: (e6, i11) => i11.payload }, extraReducers: (e6) => {
    e6.addCase(L3, () => o8);
  } }), { setDappConfig: y5 } = a5.actions, D3 = a5.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BPYUN5PX.js
var import_dist52 = __toESM(require_dist());
function x5() {
  return (/* @__PURE__ */ new Date()).setHours((/* @__PURE__ */ new Date()).getHours() + 24);
}
function c8(e6) {
  f10.local.setItem({ key: i8.loginExpiresAt, data: e6, expires: e6 });
}
var a6 = Dr(() => {
  v();
  e4();
  f9();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-P3KWCR7B.js
var import_dist53 = __toESM(require_dist());
var L4;
var p10;
var C;
var P3;
var v5;
var b6;
var h3;
var M3;
var R4;
var E5;
var z4;
var V3;
var N4;
var T4 = Dr(() => {
  v();
  a6();
  Q();
  p5();
  L4 = { loginMethod: "", walletConnectLogin: null, ledgerLogin: null, tokenLogin: null, walletLogin: null, extensionLogin: null, passkeyLogin: null, operaLogin: null, crossWindowLogin: null, iframeWindowLogin: null, isLoginSessionInvalid: false, webviewLogin: null }, p10 = createSlice({ name: "loginInfoSlice", initialState: L4, reducers: { setLoginMethod: (n9, o9) => {
    n9.loginMethod = o9.payload;
  }, setTokenLogin: (n9, o9) => {
    n9.tokenLogin = o9.payload;
  }, setTokenLoginSignature: (n9, o9) => {
    (n9 == null ? void 0 : n9.tokenLogin) != null && (n9.tokenLogin.signature = o9.payload);
  }, setWalletLogin: (n9, o9) => {
    n9.walletLogin = o9.payload;
  }, setWalletConnectLogin: (n9, o9) => {
    n9.walletConnectLogin = o9.payload;
  }, setLedgerLogin: (n9, o9) => {
    n9.ledgerLogin = o9.payload;
  }, setWebviewLogin: (n9, o9) => {
    n9.webviewLogin = o9.payload;
  }, invalidateLoginSession: (n9) => {
    n9.isLoginSessionInvalid = true;
  }, setLogoutRoute: (n9, o9) => {
    n9.logoutRoute = o9.payload;
  }, setIsWalletConnectV2Initialized: (n9, o9) => {
    n9.isWalletConnectV2Initialized = o9.payload;
  } }, extraReducers: (n9) => {
    n9.addCase(L3, () => L4), n9.addCase(f5, (o9, e6) => {
      o9.isLoginSessionInvalid = false, o9.loginMethod = e6.payload.loginMethod, o9.iframeLoginType = e6.payload.iframeLoginType, c8(x5());
    });
  } }), { setLoginMethod: C, setWalletConnectLogin: P3, setLedgerLogin: v5, setTokenLogin: b6, setTokenLoginSignature: h3, setWalletLogin: M3, invalidateLoginSession: R4, setLogoutRoute: E5, setIsWalletConnectV2Initialized: z4, setWebviewLogin: V3 } = p10.actions, N4 = p10.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-GTQ4BLGT.js
var import_dist54 = __toESM(require_dist());
var e5;
var d6;
var x6;
var p11;
var b7;
var N5;
var T5;
var s6 = Dr(() => {
  v();
  p5();
  e5 = {}, d6 = createSlice({ name: "modalsSlice", initialState: e5, reducers: { setTxSubmittedModal: (t7, i11) => {
    t7.txSubmittedModal = i11.payload;
  }, setNotificationModal: (t7, i11) => {
    t7.notificationModal = i11.payload;
  }, clearTxSubmittedModal: (t7) => {
    t7.txSubmittedModal = void 0;
  }, clearNotificationModal: (t7) => {
    t7.notificationModal = void 0;
  } }, extraReducers: (t7) => {
    t7.addCase(L3, () => e5);
  } }), { setTxSubmittedModal: x6, setNotificationModal: p11, clearTxSubmittedModal: b7, clearNotificationModal: N5 } = d6.actions, T5 = d6.reducer;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-SI2ND36M.js
var import_dist55 = __toESM(require_dist());
var E6;
var j5;
var S6;
var q5 = Dr(() => {
  v();
  i();
  w4();
  l6();
  f11();
  T4();
  s6();
  g4();
  f6();
  g5();
  f7();
  b4();
  E6 = { ["account"]: X3, ["dappConfig"]: D3, ["loginInfo"]: N4, ["modals"]: T5, ["networkConfig"]: F2, ["signedMessageInfo"]: R3, ["toasts"]: q2, ["transactionsInfo"]: F3, ["transactions"]: en2, ["batchTransactions"]: b5 }, j5 = (d8 = {}) => combineReducers(yt(yt({}, E6), d8)), S6 = j5;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OC3TXL2V.js
var import_dist56 = __toESM(require_dist());
var g11 = Dr(() => {
  v();
  w4();
  T4();
  s6();
  g4();
  f6();
  g5();
  f7();
  b4();
  l6();
  f11();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-VXBF5YEX.js
var import_dist57 = __toESM(require_dist());
var import_storage = __toESM(require_storage());
var import_session = __toESM(require_session());
var oo = {};
Ft(oo, { default: () => $2, sessionStorageReducers: () => a7 });
function s7(n9, P5 = []) {
  return { key: n9, version: 1, storage: import_session.default, blacklist: P5 };
}
var B3;
var t4;
var D4;
var F5;
var G2;
var H2;
var J2;
var K;
var Q4;
var U3;
var V4;
var W2;
var S7;
var X4;
var a7;
var Y4;
var Z4;
var _5;
var $2;
var so = Dr(() => {
  v();
  q5();
  g11();
  w4();
  l6();
  T4();
  s6();
  g4();
  f6();
  g5();
  f7();
  b4();
  i();
  B3 = { persistReducersStorageType: "localStorage" }, t4 = { ["account"]: "sdk-dapp-account", ["loginInfo"]: "sdk-dapp-login-info", ["modals"]: "sdk-dapp-modals", ["networkConfig"]: "sdk-dapp-network-config" }, D4 = s7(t4["account"]), F5 = s7(t4["loginInfo"]), G2 = s7(t4["modals"]), H2 = s7(t4["networkConfig"]), J2 = { 2: (n9) => xt(yt({}, n9), { networkConfig: N2 }) };
  K = s7("sdk-dapp-transactionsInfo"), Q4 = s7("sdk-dapp-transactions", ["transactionsToSign"]), U3 = s7("sdk-dapp-batchTransactions", ["batchTransactions"]), V4 = s7("sdk-dapp-toasts"), W2 = s7("sdk-dapp-signedMessageInfo"), S7 = { key: "sdk-dapp-store", version: 2, storage: import_storage.default, whitelist: Object.keys(t4), migrate: createMigrate(J2, { debug: false }) }, X4 = xt(yt({}, S7), { whitelist: [] }), a7 = { ["toasts"]: persistReducer(V4, q2), ["transactions"]: persistReducer(Q4, en2), ["transactionsInfo"]: persistReducer(K, F3), ["batchTransactions"]: persistReducer(U3, b5), ["signedMessageInfo"]: persistReducer(W2, R3) }, Y4 = xt(yt({}, a7), { ["account"]: persistReducer(D4, X3), ["loginInfo"]: persistReducer(F5, N4), ["modals"]: persistReducer(G2, T5), ["networkConfig"]: persistReducer(H2, F2) }), Z4 = B3.persistReducersStorageType === "localStorage", _5 = Z4 ? persistReducer(S7, S6(a7)) : persistReducer(X4, S6(Y4)), $2 = _5;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-6WZ7DVP7.js
var import_dist58 = __toESM(require_dist());
var p12 = {};
Ft(p12, { default: () => t5 });
function t5(e6) {
  return persistStore(e6);
}
var s8 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-GGMEVY45.js
var import_dist59 = __toESM(require_dist());
var n8 = {};
Ft(n8, { default: () => i10 });
var d7;
var i10;
var A6 = Dr(() => {
  v();
  d7 = [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER], i10 = d7;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-GAX23W6N.js
var import_dist60 = __toESM(require_dist());
var m8 = {};
Ft(m8, { default: () => f12 });
var f12;
var p13 = Dr(() => {
  v();
  q5();
  f12 = S6();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-GE2ZYJPG.js
var import_dist61 = __toESM(require_dist());
var v6;
var y6;
var A7;
var q6 = Dr(() => {
  v();
  o2();
  v6 = s() ? (so(), gt(oo)).default : (p13(), gt(m8)).default, y6 = s() ? (A6(), gt(n8)).default : [], A7 = s() ? (s8(), gt(p12)).default : (o9) => o9;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-SDXMBWMP.js
var import_dist62 = __toESM(require_dist());
var import_lodash2 = __toESM(require_lodash2());
var L5;
var t6;
var x7;
var D5;
var T6 = Dr(() => {
  v();
  T();
  g11();
  a6();
  e4();
  f9();
  L5 = [g], t6 = false, x7 = (0, import_lodash2.default)(() => {
    c8(x5());
  }, 5e3), D5 = (n9) => (e6) => (o9) => {
    if (L5.includes(o9.type)) return e6(o9);
    let i11 = n9.getState(), a9 = f10.local.getItem(i8.loginExpiresAt);
    if (!Boolean(i11 == null ? void 0 : i11.account.address)) return e6(o9);
    if (a9 == null) return c8(x5());
    let f13 = Date.now();
    return a9 - f13 < 0 && !t6 ? setTimeout(() => {
      t6 = true, n9.dispatch(R4());
    }, 1e3) : (t6 && (t6 = false), x7()), e6(o9);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-F2BOSVKG.js
var import_dist63 = __toESM(require_dist());
var import_Subscription = __toESM(require_Subscription());
var a8;
var P4;
var z6;
var C2;
var l7 = Dr(() => {
  v();
  g11();
  T6();
  q6();
  q5();
  a8 = configureStore({ reducer: v6, middleware: (d8) => d8({ serializableCheck: { ignoredActions: [...y6, Z3.type, O3.type], ignoredPaths: ["payload.nonce", "account.account.nonce", "providers.accountProvider"] } }).concat(D5) }), P4 = (0, import_Subscription.createSubscription)(a8), z6 = A7(a8), C2 = configureStore({ reducer: S6 });
});

export {
  o2 as o,
  x,
  i2 as i,
  f2 as f,
  c2 as c,
  u4 as u,
  x2,
  D,
  p2 as p,
  l2 as l,
  u5 as u2,
  L,
  p3 as p2,
  L3 as L2,
  f5 as f2,
  p5 as p3,
  N2 as N,
  O2 as O,
  _3 as _,
  z2 as z,
  g4 as g,
  A2 as A,
  E3 as E,
  b2 as b,
  i6 as i2,
  n4 as n,
  U2 as U,
  Y2 as Y,
  j2 as j,
  k2 as k,
  l4 as l2,
  u9 as u3,
  p7 as p4,
  b3 as b2,
  A3 as A2,
  j3 as j2,
  k3 as k2,
  q3 as q,
  y2 as y,
  h2 as h,
  g7 as g2,
  V,
  X2 as X,
  Z2 as Z,
  _4 as _2,
  $,
  nn2 as nn,
  an2 as an,
  on2 as on,
  tn2 as tn,
  rn2 as rn,
  o5 as o2,
  n5 as n2,
  r4 as r,
  p9 as p5,
  i8 as i3,
  f9 as f3,
  f10 as f4,
  e4 as e,
  g10 as g3,
  O3 as O2,
  Y3 as Y2,
  Z3 as Z2,
  q4 as q2,
  z3 as z2,
  J,
  M2 as M,
  Q3 as Q,
  V2,
  S5 as S,
  u12 as u4,
  m7 as m,
  y5 as y2,
  P3 as P,
  v5 as v,
  b6 as b3,
  M3 as M2,
  E5 as E2,
  z4 as z3,
  V3,
  T4 as T,
  x6 as x3,
  p11 as p6,
  N5 as N2,
  g11 as g4,
  a8 as a,
  P4 as P2,
  z6 as z4,
  l7 as l3
};
//# sourceMappingURL=chunk-DODOUSNB.js.map
