"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectV2Provider = exports.OptionalOperation = exports.Operation = exports.WalletConnectV2ProviderErrorMessagesEnum = void 0;
const sdk_core_1 = require("@multiversx/sdk-core");
const sign_client_1 = __importDefault(require("@walletconnect/sign-client"));
const utils_1 = require("@walletconnect/utils");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
Object.defineProperty(exports, "WalletConnectV2ProviderErrorMessagesEnum", { enumerable: true, get: function () { return errors_1.WalletConnectV2ProviderErrorMessagesEnum; } });
const logger_1 = require("./logger");
const operation_1 = require("./operation");
Object.defineProperty(exports, "Operation", { enumerable: true, get: function () { return operation_1.Operation; } });
Object.defineProperty(exports, "OptionalOperation", { enumerable: true, get: function () { return operation_1.OptionalOperation; } });
const utils_2 = require("./utils");
class WalletConnectV2Provider {
    constructor(onClientConnect, chainId, walletConnectV2Relay, walletConnectV2ProjectId, options) {
        this.chainId = "";
        this.isInitializing = false;
        this.processingTopic = "";
        this.options = {};
        this.account = { address: "" };
        this.onClientConnect = onClientConnect;
        this.chainId = chainId;
        this.walletConnectV2Relay = walletConnectV2Relay;
        this.walletConnectV2ProjectId = walletConnectV2ProjectId;
        this.options = options;
    }
    disconnect() {
        this.account = { address: "", signature: "" };
        this.walletConnector = undefined;
        this.session = undefined;
        this.pairings = undefined;
    }
    /**
     * Initiates WalletConnect client.
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this.isInitialized()) {
                return this.isInitialized();
            }
            else {
                try {
                    if (!this.isInitializing) {
                        this.isInitializing = true;
                        this.disconnect();
                        const metadata = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata)
                            ? {
                                metadata: (0, utils_2.getMetadata)((_b = this.options) === null || _b === void 0 ? void 0 : _b.metadata),
                            }
                            : {};
                        const client = yield sign_client_1.default.init(Object.assign(Object.assign(Object.assign({}, this.options), { relayUrl: this.walletConnectV2Relay, projectId: this.walletConnectV2ProjectId }), metadata));
                        this.walletConnector = client;
                        this.isInitializing = false;
                        yield this.subscribeToEvents(client);
                        yield this.checkPersistedState(client);
                    }
                }
                catch (error) {
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToInit);
                }
                finally {
                    this.isInitializing = false;
                    return this.isInitialized();
                }
            }
        });
    }
    /**
     * Returns true if init() was previously called successfully
     */
    isInitialized() {
        return !!this.walletConnector && !this.isInitializing;
    }
    /**
     * Returns true if provider is initialized and a valid session is set
     */
    isConnected() {
        return Boolean(this.isInitialized() && typeof this.session !== "undefined");
    }
    /**
     * Returns the current account
     */
    getAccount() {
        return this.account;
    }
    /**
     * Sets the current account
     * @param account
     */
    setAccount(account) {
        this.account = account;
    }
    connect(options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (typeof this.walletConnector === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            const connectParams = (0, utils_2.getConnectionParams)(this.chainId, options);
            try {
                const response = yield this.walletConnector.connect(Object.assign({ pairingTopic: options === null || options === void 0 ? void 0 : options.topic }, connectParams));
                return response;
            }
            catch (error) {
                if (options === null || options === void 0 ? void 0 : options.topic) {
                    try {
                        (_b = (_a = this.walletConnector.core) === null || _a === void 0 ? void 0 : _a.expirer) === null || _b === void 0 ? void 0 : _b.set(options.topic, 0);
                    }
                    catch (error) {
                        logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleCleanup);
                    }
                }
                this.disconnect();
                logger_1.Logger.error((options === null || options === void 0 ? void 0 : options.topic)
                    ? errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnectExisting
                    : errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnect);
                throw new Error((options === null || options === void 0 ? void 0 : options.topic)
                    ? errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnectExisting
                    : errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnect);
            }
        });
    }
    login(options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            this.isInitializing = true;
            if (typeof this.walletConnector === "undefined") {
                yield this.connect();
            }
            if (typeof this.walletConnector === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session !== "undefined") {
                yield this.logout({ topic: (_a = this.session) === null || _a === void 0 ? void 0 : _a.topic });
            }
            try {
                if (options && options.approval) {
                    const session = yield options.approval();
                    if (options.token) {
                        yield (0, utils_2.sleep)(constants_1.WALLETCONNECT_SIGN_LOGIN_DELAY); // Delay the sign login token action to allow the UI to update properly
                        const address = (0, utils_2.getAddressFromSession)(session);
                        const selectedNamespace = session.namespaces[constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE];
                        const method = selectedNamespace.methods.includes(operation_1.OptionalOperation.SIGN_NATIVE_AUTH_TOKEN)
                            ? operation_1.OptionalOperation.SIGN_NATIVE_AUTH_TOKEN
                            : operation_1.OptionalOperation.SIGN_LOGIN_TOKEN;
                        const { signature } = yield this.walletConnector.request({
                            chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
                            topic: session.topic,
                            request: {
                                method,
                                params: {
                                    token: options.token,
                                    address,
                                },
                            },
                        });
                        if (!signature) {
                            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSignLoginToken);
                            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSignLoginToken);
                        }
                        return yield this.onSessionConnected({
                            session,
                            signature,
                        });
                    }
                    return yield this.onSessionConnected({
                        session,
                        signature: "",
                    });
                }
            }
            catch (error) {
                this.disconnect();
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToLogin);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToLogin);
            }
            finally {
                this.isInitializing = false;
            }
            return null;
        });
    }
    /**
     * Mocks a logout request by returning true
     */
    logout(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            try {
                if (this.processingTopic ===
                    ((options === null || options === void 0 ? void 0 : options.topic) || (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector))) {
                    return true;
                }
                if (options === null || options === void 0 ? void 0 : options.topic) {
                    this.processingTopic = options.topic;
                    yield this.walletConnector.disconnect({
                        topic: options.topic,
                        reason: (0, utils_1.getSdkError)("USER_DISCONNECTED"),
                    });
                }
                else {
                    const currentSessionTopic = (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector);
                    this.processingTopic = currentSessionTopic;
                    yield this.walletConnector.disconnect({
                        topic: currentSessionTopic,
                        reason: (0, utils_1.getSdkError)("USER_DISCONNECTED"),
                    });
                    this.disconnect();
                    yield this.cleanupPendingPairings({ deletePairings: true });
                }
            }
            catch (_a) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.alreadyLoggedOut);
            }
            finally {
                this.processingTopic = "";
            }
            return true;
        });
    }
    /**
     * Fetches the WalletConnect address
     */
    getAddress() {
        if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
        }
        return this.account.address;
    }
    /**
     * Fetches the WalletConnect signature
     */
    getSignature() {
        if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
        }
        return this.account.signature;
    }
    /**
     * Fetches the WalletConnect pairings
     */
    getPairings() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            return ((_e = (_d = (_c = (_b = (_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.core) === null || _b === void 0 ? void 0 : _b.pairing) === null || _c === void 0 ? void 0 : _c.pairings) === null || _d === void 0 ? void 0 : _d.getAll({ active: true })) !== null && _e !== void 0 ? _e : []);
        });
    }
    /**
     * Signs a message and returns it signed
     * @param message
     */
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const message = new sdk_core_1.Message({
                data: Buffer.from(messageToSign.data),
                address: (_a = messageToSign.address) !== null && _a !== void 0 ? _a : sdk_core_1.Address.fromBech32(this.account.address),
                signer: "wallet-connect-v2",
                version: messageToSign.version,
            });
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            try {
                const address = this.getAddress();
                const { signature } = yield this.walletConnector.request({
                    chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
                    topic: (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector),
                    request: {
                        method: operation_1.Operation.SIGN_MESSAGE,
                        params: {
                            address,
                            message: message.data.toString(),
                        },
                    },
                });
                if (!signature) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageResponse);
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageResponse);
                }
                try {
                    message.signature = Buffer.from(signature, "hex");
                }
                catch (error) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageSignature);
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageSignature);
                }
            }
            catch (error) {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSign);
            }
            return message;
        });
    }
    /**
     * Signs a transaction and returns it signed
     * @param transaction
     */
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            const plainTransaction = transaction.toPlainObject();
            if (this.chainId !== transaction.getChainID().valueOf()) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
            }
            try {
                const response = yield this.walletConnector.request({
                    chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
                    topic: (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector),
                    request: {
                        method: operation_1.Operation.SIGN_TRANSACTION,
                        params: {
                            transaction: plainTransaction,
                        },
                    },
                });
                return (0, utils_2.applyTransactionSignature)({ transaction, response });
            }
            catch (error) {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.transactionError);
            }
        });
    }
    /**
     * Signs an array of transactions and returns it signed
     * @param transactions
     */
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            const plainTransactions = transactions.map((transaction) => {
                if (this.chainId !== transaction.getChainID().valueOf()) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                }
                return transaction.toPlainObject();
            });
            try {
                const { signatures } = yield this.walletConnector.request({
                    chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
                    topic: (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector),
                    request: {
                        method: operation_1.Operation.SIGN_TRANSACTIONS,
                        params: {
                            transactions: plainTransactions,
                        },
                    },
                });
                if (!signatures) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
                }
                if (!Array.isArray(signatures) ||
                    transactions.length !== signatures.length) {
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
                }
                for (const [index, transaction] of transactions.entries()) {
                    const response = signatures[index];
                    (0, utils_2.applyTransactionSignature)({ transaction, response });
                }
                return transactions;
            }
            catch (error) {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.transactionError);
            }
        });
    }
    /**
     * Sends a custom request
     * @param request
     */
    sendCustomRequest(options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            if ((_a = options === null || options === void 0 ? void 0 : options.request) === null || _a === void 0 ? void 0 : _a.method) {
                try {
                    const request = Object.assign({}, options.request);
                    let { method } = request;
                    const { response } = yield this.walletConnector.request({
                        chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
                        topic: (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector),
                        request: Object.assign(Object.assign({}, request), { method }),
                    });
                    if (!response) {
                        logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidCustomRequestResponse);
                    }
                }
                catch (error) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidCustomRequestResponse);
                }
                return;
            }
        });
    }
    /**
     * Ping helper
     */
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            try {
                const topic = (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector);
                yield this.walletConnector.ping({
                    topic,
                });
                return true;
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.pingFailed);
                return false;
            }
        });
    }
    loginAccount(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options) {
                return "";
            }
            if ((0, utils_2.addressIsValid)(options.address)) {
                this.account.address = options.address;
                if (options.signature) {
                    this.account.signature = options.signature;
                }
                this.onClientConnect.onClientLogin();
                return this.account.address;
            }
            logger_1.Logger.error(`${errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidAddress} ${options.address}`);
            if (this.walletConnector) {
                yield this.logout();
            }
            return "";
        });
    }
    onSessionConnected(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options) {
                return null;
            }
            this.session = options.session;
            this.account.signature = options.signature || "";
            const address = (0, utils_2.getAddressFromSession)(options.session);
            if (address) {
                yield this.loginAccount({ address, signature: options.signature });
                this.account.address = address;
                return this.account;
            }
            return null;
        });
    }
    handleTopicUpdateEvent(_a) {
        return __awaiter(this, arguments, void 0, function* ({ topic, }) {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                return;
            }
            try {
                const existingPairings = yield this.getPairings();
                if (this.account.address && !this.isInitializing && existingPairings) {
                    if ((existingPairings === null || existingPairings === void 0 ? void 0 : existingPairings.length) === 0) {
                        this.onClientConnect.onClientLogout();
                    }
                    else {
                        const lastActivePairing = existingPairings[existingPairings.length - 1];
                        if ((lastActivePairing === null || lastActivePairing === void 0 ? void 0 : lastActivePairing.topic) === topic) {
                            this.onClientConnect.onClientLogout();
                        }
                    }
                }
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleTopic);
            }
            finally {
                this.pairings = yield this.getPairings();
            }
        });
    }
    handleSessionEvents(_a) {
        return __awaiter(this, arguments, void 0, function* ({ topic, params, }) {
            var _b;
            if (typeof this.walletConnector === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (this.session && ((_b = this.session) === null || _b === void 0 ? void 0 : _b.topic) !== topic) {
                return;
            }
            const { event } = params;
            if ((event === null || event === void 0 ? void 0 : event.name) &&
                (0, utils_2.getCurrentTopic)(this.chainId, this.walletConnector) === topic) {
                const eventData = event.data;
                this.onClientConnect.onClientEvent(eventData);
            }
        });
    }
    subscribeToEvents(client) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (typeof client === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            try {
                // Session Events
                client.on("session_update", ({ topic, params }) => {
                    var _a;
                    if (!this.session || ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) !== topic) {
                        return;
                    }
                    const { namespaces } = params;
                    const _session = client.session.get(topic);
                    const updatedSession = Object.assign(Object.assign({}, _session), { namespaces });
                    this.onSessionConnected({ session: updatedSession });
                });
                client.on("session_event", this.handleSessionEvents.bind(this));
                client.on("session_delete", (_a) => __awaiter(this, [_a], void 0, function* ({ topic }) {
                    var _b;
                    if (this.isInitializing) {
                        this.onClientConnect.onClientLogout();
                        this.disconnect();
                    }
                    if (!this.session || ((_b = this.session) === null || _b === void 0 ? void 0 : _b.topic) !== topic) {
                        return;
                    }
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionDeleted);
                    this.onClientConnect.onClientLogout();
                    this.disconnect();
                    yield this.cleanupPendingPairings({ deletePairings: true });
                }));
                client.on("session_expire", (_a) => __awaiter(this, [_a], void 0, function* ({ topic }) {
                    var _b;
                    if (!this.session || ((_b = this.session) === null || _b === void 0 ? void 0 : _b.topic) !== topic) {
                        return;
                    }
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionExpired);
                    this.onClientConnect.onClientLogout();
                    this.disconnect();
                    yield this.cleanupPendingPairings({ deletePairings: true });
                }));
                // Pairing Events
                (_b = (_a = client.core) === null || _a === void 0 ? void 0 : _a.pairing) === null || _b === void 0 ? void 0 : _b.events.on("pairing_delete", this.handleTopicUpdateEvent.bind(this));
                (_d = (_c = client.core) === null || _c === void 0 ? void 0 : _c.pairing) === null || _d === void 0 ? void 0 : _d.events.on("pairing_expire", this.handleTopicUpdateEvent.bind(this));
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleEvent);
            }
        });
    }
    checkPersistedState(client) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof client === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            this.pairings = yield this.getPairings();
            if (typeof this.session !== "undefined") {
                return;
            }
            // Populates existing session to state (assume only the top one)
            if (client.session.length &&
                !this.account.address &&
                !this.isInitializing) {
                const session = (0, utils_2.getCurrentSession)(this.chainId, client);
                if (session) {
                    yield this.onSessionConnected({ session });
                    return session;
                }
            }
            return;
        });
    }
    cleanupPendingPairings() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (typeof this.walletConnector === "undefined") {
                return;
            }
            try {
                const inactivePairings = (_c = (_b = (_a = this.walletConnector.core) === null || _a === void 0 ? void 0 : _a.pairing) === null || _b === void 0 ? void 0 : _b.pairings) === null || _c === void 0 ? void 0 : _c.getAll({ active: false });
                if (!(0, utils_1.isValidArray)(inactivePairings)) {
                    return;
                }
                for (const pairing of inactivePairings) {
                    if (options.deletePairings) {
                        (_e = (_d = this.walletConnector.core) === null || _d === void 0 ? void 0 : _d.expirer) === null || _e === void 0 ? void 0 : _e.set(pairing.topic, 0);
                    }
                    else {
                        try {
                            yield ((_h = (_g = (_f = this.walletConnector.core) === null || _f === void 0 ? void 0 : _f.relayer) === null || _g === void 0 ? void 0 : _g.subscriber) === null || _h === void 0 ? void 0 : _h.unsubscribe(pairing.topic));
                        }
                        catch (error) {
                            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleCleanup);
                        }
                    }
                }
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleCleanup);
            }
        });
    }
}
exports.WalletConnectV2Provider = WalletConnectV2Provider;
//# sourceMappingURL=walletConnectV2Provider.js.map