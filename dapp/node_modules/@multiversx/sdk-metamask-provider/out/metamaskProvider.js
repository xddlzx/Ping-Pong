var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Address, Message, Transaction } from '@multiversx/sdk-core/out';
import { defaultSnapOrigin } from './config';
import { safeWindow } from './constants';
import { ErrAccountNotConnected, ErrCannotSignSingleTransaction, ErrTransactionCancelled } from './errors';
import { connectSnap, getSnap } from './snap';
class MetamaskProvider {
    static isMetamaskInstalled() {
        return Boolean(safeWindow && safeWindow.ethereum && safeWindow.ethereum.isMetaMask);
    }
    constructor() {
        this.account = { address: '' };
        this.initialized = false;
        if (MetamaskProvider._instance) {
            throw new Error('Error: Instantiation failed: Use MetamaskProvider.getInstance() instead of new.');
        }
        MetamaskProvider._instance = this;
    }
    static getInstance() {
        return MetamaskProvider._instance;
    }
    setAddress(address) {
        this.account.address = address;
        return MetamaskProvider._instance;
    }
    getAccount() {
        return this.account;
    }
    setAccount(account) {
        this.account = account;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const hasMetamask = MetamaskProvider.isMetamaskInstalled();
            if (hasMetamask && !this.initialized) {
                try {
                    yield connectSnap();
                    const installedSnap = yield getSnap();
                    this.initialized = installedSnap !== undefined;
                }
                catch (error) {
                    this.initialized = false;
                }
            }
            return this.initialized;
        });
    }
    login(options = {}) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const token = options.token;
            if (!this.initialized) {
                throw new Error('Metamask provider is not initialised, call init() first' + token);
            }
            try {
                const address = (yield ((_a = safeWindow === null || safeWindow === void 0 ? void 0 : safeWindow.ethereum) === null || _a === void 0 ? void 0 : _a.request({
                    method: 'wallet_invokeSnap',
                    params: {
                        snapId: defaultSnapOrigin,
                        request: {
                            method: 'mvx_getAddress',
                            params: undefined
                        }
                    }
                })));
                this.account.address = address;
                if (token) {
                    const tokenSigned = (yield ((_b = safeWindow === null || safeWindow === void 0 ? void 0 : safeWindow.ethereum) === null || _b === void 0 ? void 0 : _b.request({
                        method: 'wallet_invokeSnap',
                        params: {
                            snapId: defaultSnapOrigin,
                            request: {
                                method: 'mvx_signAuthToken',
                                params: { token: token }
                            }
                        }
                    })));
                    this.account.signature = tokenSigned;
                }
            }
            catch (error) {
                throw error;
            }
            return this.account;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new Error('Metamask provider is not initialised, call init() first');
            }
            this.account = { address: '' };
            return true;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new Error('Metamask provider is not initialised, call init() first');
            }
            return this.account ? this.account.address : '';
        });
    }
    isInitialized() {
        return this.initialized;
    }
    isConnected() {
        return Boolean(this.account.address);
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedTransactions = yield this.signTransactions([transaction]);
            if (signedTransactions.length != 1) {
                throw new ErrCannotSignSingleTransaction();
            }
            return signedTransactions[0];
        });
    }
    signTransactions(transactions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const transactionsPlain = transactions.map((transaction) => transaction.toPlainObject());
                const metamaskReponse = (yield ((_a = safeWindow === null || safeWindow === void 0 ? void 0 : safeWindow.ethereum) === null || _a === void 0 ? void 0 : _a.request({
                    method: 'wallet_invokeSnap',
                    params: {
                        snapId: defaultSnapOrigin,
                        request: {
                            method: 'mvx_signTransactions',
                            params: { transactions: transactionsPlain }
                        }
                    }
                })));
                const transactionsResponse = metamaskReponse.map((transaction) => Transaction.fromPlainObject(JSON.parse(transaction)));
                return transactionsResponse;
            }
            catch (error) {
                throw new ErrTransactionCancelled();
            }
        });
    }
    signMessage(messageToSign) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.ensureConnected();
                const metamaskReponse = (yield ((_a = safeWindow === null || safeWindow === void 0 ? void 0 : safeWindow.ethereum) === null || _a === void 0 ? void 0 : _a.request({
                    method: 'wallet_invokeSnap',
                    params: {
                        snapId: defaultSnapOrigin,
                        request: {
                            method: 'mvx_signMessage',
                            params: { message: Buffer.from(messageToSign.data).toString() }
                        }
                    }
                })));
                return new Message({
                    data: Buffer.from(messageToSign.data),
                    address: (_b = messageToSign.address) !== null && _b !== void 0 ? _b : Address.fromBech32(this.account.address),
                    signer: 'metamask',
                    version: messageToSign.version,
                    signature: Buffer.from(metamaskReponse, 'hex')
                });
            }
            catch (error) {
                throw error;
            }
        });
    }
    cancelAction() {
        return false;
    }
    ensureConnected() {
        const hasMetamask = MetamaskProvider.isMetamaskInstalled();
        if (!this.account.address || !hasMetamask) {
            throw new ErrAccountNotConnected();
        }
    }
}
MetamaskProvider._instance = new MetamaskProvider();
export { MetamaskProvider };
//# sourceMappingURL=metamaskProvider.js.map