"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossWindowProvider = void 0;
const sdk_core_1 = require("@multiversx/sdk-core");
const constants_1 = require("../constants");
const enums_1 = require("../enums");
const errors_1 = require("../errors");
const WindowManager_1 = require("../WindowManager");
const constants_2 = require("./PopupConsent/constants");
class CrossWindowProvider {
    constructor() {
        this.account = { address: '' };
        this.accessToken = undefined;
        this.initialized = false;
        this._shouldShowConsentPopup = false;
        this.windowManager = new WindowManager_1.WindowManager();
    }
    setShouldShowConsentPopup(shouldShow) {
        this._shouldShowConsentPopup = shouldShow;
    }
    ensureConnected() {
        if (!this.account.address) {
            throw new errors_1.ErrAccountNotConnected();
        }
    }
    disconnect() {
        this.account = { address: '' };
    }
    static getInstance() {
        if (!CrossWindowProvider._instance) {
            CrossWindowProvider._instance = new CrossWindowProvider();
            return CrossWindowProvider._instance;
        }
        return CrossWindowProvider._instance;
    }
    getWindowManager() {
        return this.windowManager;
    }
    setAddress(address) {
        this.account.address = address;
        return this;
    }
    setWalletUrl(url) {
        this.windowManager.setWalletUrl(url);
        return this;
    }
    setWalletWindow() {
        return this.windowManager.setWalletWindow();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initialized = yield this.windowManager.init();
            return this.initialized;
        });
    }
    login(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            const isRelogin = this.isConnected();
            if (isRelogin) {
                const { address, signature, multisig, impersonate } = this.account;
                return {
                    address,
                    signature,
                    multisig,
                    impersonate
                };
            }
            this.accessToken = options.token;
            const popupConsentResponse = yield this.openPopupConsent();
            if (!popupConsentResponse) {
                throw new errors_1.ErrCouldNotLogin();
            }
            const { payload: { data, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.loginRequest,
                payload: {
                    token: this.accessToken
                }
            });
            if (error || !data) {
                throw new errors_1.ErrCouldNotLogin();
            }
            this.account.address = data.address;
            this.account.signature = data.signature;
            this.account.multisig = data.multisig;
            this.account.impersonate = data.impersonate;
            return {
                address: this.account.address,
                signature: this.account.signature,
                multisig: this.account.multisig,
                impersonate: this.account.impersonate
            };
        });
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionClosed = yield this.windowManager.closeConnection();
            return connectionClosed;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            const popupConsentResponse = yield this.openPopupConsent();
            if (!this.initialized || !popupConsentResponse) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            this.ensureConnected();
            const connectionClosed = yield this.dispose();
            this.initialized = false;
            this.disconnect();
            return connectionClosed;
        });
    }
    getAddress() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            return (_b = (_a = this.account) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '';
        });
    }
    isInitialized() {
        return this.initialized;
    }
    isConnected() {
        return Boolean(this.account.address);
    }
    getAccount() {
        return this.account;
    }
    setAccount(account) {
        this.account = account;
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const signedTransactions = yield this.signTransactions([transaction]);
            if (signedTransactions.length != 1) {
                throw new errors_1.ErrCannotSignSingleTransaction();
            }
            return signedTransactions[0];
        });
    }
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const popupConsentResponse = yield this.openPopupConsent();
            if (!popupConsentResponse) {
                throw new errors_1.ErrTransactionCancelled();
            }
            const { type, payload: { data: signedPlainTransactions, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.signTransactionsRequest,
                payload: transactions.map((tx) => tx.toPlainObject())
            });
            if (error || !signedPlainTransactions) {
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            if (type === enums_1.WindowProviderResponseEnums.cancelResponse) {
                throw new errors_1.ErrTransactionCancelled();
            }
            const hasTransactions = (signedPlainTransactions === null || signedPlainTransactions === void 0 ? void 0 : signedPlainTransactions.length) > 0;
            if (!hasTransactions) {
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            return signedPlainTransactions.map((tx) => sdk_core_1.Transaction.fromPlainObject(tx));
        });
    }
    guardTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const popupConsentResponse = yield this.openPopupConsent();
            if (!popupConsentResponse) {
                throw new errors_1.ErrTransactionCancelled();
            }
            const { type, payload: { data: signedPlainTransactions, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.guardTransactionsRequest,
                payload: transactions.map((tx) => tx.toPlainObject())
            });
            if (error || !signedPlainTransactions) {
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            if (type === enums_1.WindowProviderResponseEnums.cancelResponse) {
                throw new errors_1.ErrTransactionCancelled();
            }
            const hasTransactions = (signedPlainTransactions === null || signedPlainTransactions === void 0 ? void 0 : signedPlainTransactions.length) > 0;
            if (!hasTransactions) {
                throw new errors_1.ErrCouldNotGuardTransactions();
            }
            return signedPlainTransactions.map((tx) => sdk_core_1.Transaction.fromPlainObject(tx));
        });
    }
    signMessage(messageToSign) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const popupConsentResponse = yield this.openPopupConsent();
            if (!popupConsentResponse) {
                throw new errors_1.ErrCouldNotSignMessage();
            }
            const { payload: { data, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.signMessageRequest,
                payload: {
                    message: Buffer.from(messageToSign.data).toString()
                }
            });
            if (error || !data) {
                throw new errors_1.ErrCouldNotSignMessage();
            }
            const { status, signature } = data;
            if (status !== enums_1.SignMessageStatusEnum.signed) {
                throw new errors_1.ErrCouldNotSignMessage();
            }
            return new sdk_core_1.Message({
                data: Buffer.from(messageToSign.data),
                address: (_a = messageToSign.address) !== null && _a !== void 0 ? _a : sdk_core_1.Address.fromBech32(this.account.address),
                signer: messageToSign.signer || 'wallet-cross-window',
                version: messageToSign.version,
                signature: Buffer.from(String(signature), 'hex')
            });
        });
    }
    cancelAction() {
        var _a, _b;
        const isWalletOpened = (_a = this.windowManager) === null || _a === void 0 ? void 0 : _a.isWalletOpened(enums_1.WindowProviderRequestEnums.cancelAction);
        if (!isWalletOpened) {
            return;
        }
        return (_b = this.windowManager) === null || _b === void 0 ? void 0 : _b.postMessage({
            type: enums_1.WindowProviderRequestEnums.cancelAction,
            payload: undefined
        });
    }
    openPopupConsent() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._shouldShowConsentPopup ||
                typeof document === 'undefined' ||
                typeof window === 'undefined') {
                return true;
            }
            const module = yield Promise.resolve().then(() => __importStar(require('./PopupConsent/PopupConsent')));
            const PopupConsent = module.PopupConsent;
            const customElements = constants_1.safeWindow.customElements;
            if (customElements && !customElements.get(constants_2.confirmationDialogTag)) {
                customElements.define(constants_2.confirmationDialogTag, PopupConsent);
            }
            const popup = document.createElement(constants_2.confirmationDialogTag);
            popup.walletUrl = this.windowManager.walletUrl;
            document.body.appendChild(popup);
            const popupConsentResponse = yield new Promise((resolve) => {
                popup.onConfirm = () => {
                    resolve(true);
                    document.body.removeChild(popup);
                };
                popup.onCancel = () => {
                    resolve(false);
                    document.body.removeChild(popup);
                };
            });
            this._shouldShowConsentPopup = false;
            return popupConsentResponse;
        });
    }
}
CrossWindowProvider._instance = null;
exports.CrossWindowProvider = CrossWindowProvider;
//# sourceMappingURL=CrossWindowProvider.js.map