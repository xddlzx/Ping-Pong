"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperaProvider = void 0;
const errors_1 = require("./errors");
class OperaProvider {
    constructor() {
        this.account = { address: "" };
        this.initialized = false;
        if (OperaProvider._instance) {
            throw new Error("Error: Instantiation failed: Use OperaProvider.getInstance() instead of new.");
        }
        OperaProvider._instance = this;
    }
    static getInstance() {
        return OperaProvider._instance;
    }
    setAddress(address) {
        this.account.address = address;
        return OperaProvider._instance;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (window && window.elrond && window.isOpera && !this.initialized) {
                try {
                    this.initialized = yield window.elrond.init();
                }
                catch (error) {
                    this.initialized = false;
                }
            }
            return this.initialized;
        });
    }
    login({ token, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new Error("Opera provider is not initialised, call init() first");
            }
            try {
                this.account.address = yield window.elrond.login(token);
            }
            catch (error) {
                throw error;
            }
            return this.account.address;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new Error("Opera provider is not initialised, call init() first");
            }
            try {
                yield window.elrond.logout();
                this.disconnect();
            }
            catch (error) {
                console.warn("Opera logout operation failed!", error);
            }
            return true;
        });
    }
    disconnect() {
        this.account = { address: "" };
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new Error("Opera provider is not initialised, call init() first");
            }
            return this.account ? this.account.address : "";
        });
    }
    isInitialized() {
        return this.initialized;
    }
    isConnected() {
        return Boolean(this.account.address);
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedTransactions = yield this.signTransactions([transaction]);
            if (signedTransactions.length != 1) {
                throw new errors_1.ErrCannotSignSingleTransaction();
            }
            return signedTransactions[0];
        });
    }
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.ensureConnected();
                return yield window.elrond.signTransactions(transactions);
            }
            catch (error) {
                throw error;
            }
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.ensureConnected();
                return yield window.elrond.signMessage(message);
            }
            catch (error) {
                throw error;
            }
        });
    }
    cancelAction() {
        //opera does not have a cancel action method implemented
        return false;
    }
    ensureConnected() {
        if (!this.account.address) {
            throw new errors_1.ErrAccountNotConnected();
        }
    }
}
exports.OperaProvider = OperaProvider;
OperaProvider._instance = new OperaProvider();
//# sourceMappingURL=operaProvider.js.map