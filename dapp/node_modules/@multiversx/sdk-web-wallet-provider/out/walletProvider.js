"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletProvider = void 0;
const sdk_core_1 = require("@multiversx/sdk-core");
const qs_1 = __importDefault(require("qs"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const plainSignedTransaction_1 = require("./plainSignedTransaction");
class WalletProvider {
    /**
     * Creates a new WalletProvider
     * @param walletURL
     */
    constructor(walletURL) {
        this.walletUrl = walletURL;
    }
    /**
     * Fetches the login hook url and redirects the client to the wallet login.
     */
    login(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const redirectUrl = this.buildWalletUrl({
                endpoint: constants_1.WALLET_PROVIDER_CONNECT_URL,
                callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl,
                params: {
                    token: options === null || options === void 0 ? void 0 : options.token
                }
            });
            yield this.redirect(redirectUrl, options === null || options === void 0 ? void 0 : options.redirectDelayMilliseconds);
            return redirectUrl;
        });
    }
    redirect(url, delayMilliseconds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (delayMilliseconds) {
                yield this.redirectLater(url, delayMilliseconds);
            }
            else {
                this.redirectImmediately(url);
            }
        });
    }
    redirectImmediately(url) {
        window.location.href = url;
    }
    redirectLater(url, delayMilliseconds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => {
                setTimeout(() => {
                    window.location.href = url;
                    resolve(true);
                }, delayMilliseconds);
            });
        });
    }
    /**
    * Fetches the logout hook url and redirects the client to the wallet logout.
    */
    logout(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const redirectUrl = this.buildWalletUrl({
                endpoint: constants_1.WALLET_PROVIDER_DISCONNECT_URL,
                callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl
            });
            yield this.redirect(redirectUrl, options === null || options === void 0 ? void 0 : options.redirectDelayMilliseconds);
            return true;
        });
    }
    /**
     * Packs a {@link Message} and fetches correct redirect URL from the wallet API. Then redirects
     * the client to the sign message hook
     * @param message
     * @param options
     */
    signMessage(messageToSign, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = new sdk_core_1.Message({
                data: Buffer.from(messageToSign.data),
                address: messageToSign.address,
                signer: "web-wallet",
                version: messageToSign.version,
            });
            const redirectUrl = this.buildWalletUrl({
                endpoint: constants_1.WALLET_PROVIDER_SIGN_MESSAGE_URL,
                callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl,
                params: {
                    message: message.data.toString()
                }
            });
            yield this.redirect(redirectUrl);
            return redirectUrl;
        });
    }
    getMessageSignatureFromWalletUrl() {
        var _a, _b;
        const url = window.location.search.slice(1);
        console.info("getMessageSignatureFromWalletUrl(), url:", url);
        const urlParams = qs_1.default.parse(url);
        const status = ((_a = urlParams.status) === null || _a === void 0 ? void 0 : _a.toString()) || "";
        const expectedStatus = "signed";
        if (status !== expectedStatus) {
            throw new errors_1.ErrCannotSignedMessage();
        }
        const signature = ((_b = urlParams.signature) === null || _b === void 0 ? void 0 : _b.toString()) || "";
        return signature;
    }
    /**
    * Packs an array of {$link Transaction} and redirects to the 2fa hook
    *
    * @param transactions
    * @param options
    */
    guardTransactions(transactions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.redirectTransactionsToEndpoint(constants_1.WALLET_PROVIDER_GUARD_TRANSACTION_URL, transactions, options);
        });
    }
    /**
    * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook
    *
    * @param transactions
    * @param options
    */
    signTransactions(transactions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.redirectTransactionsToEndpoint(constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL, transactions, options);
        });
    }
    /**
     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects
     *   the client to the sign transaction hook
     * @param transaction
     * @param options
     */
    signTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.signTransactions([transaction], options);
        });
    }
    getTransactionsFromWalletUrl(search = window.location.search) {
        const urlParams = qs_1.default.parse(search.slice(1));
        if (!WalletProvider.isTxSignReturnSuccess(urlParams)) {
            return [];
        }
        return this.getTxSignReturnValue(urlParams);
    }
    static isTxSignReturnSuccess(urlParams) {
        return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;
    }
    getTxSignReturnValue(urlParams) {
        console.info("getTxSignReturnValue(), urlParams:", urlParams);
        // "options", "data", "guardian", "guardianSignature", "senderUsername", "receiverUsername" properties are optional (it isn't always received from the Web Wallet)
        const expectedProps = ["nonce", "value", "receiver", "sender", "gasPrice",
            "gasLimit", "chainID", "version", "signature"];
        for (let txProp of expectedProps) {
            if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {
                throw new errors_1.ErrCannotGetSignedTransactions();
            }
        }
        const expectedLength = urlParams["nonce"].length;
        for (let txProp of expectedProps) {
            if (urlParams[txProp].length !== expectedLength) {
                throw new errors_1.ErrCannotGetSignedTransactions();
            }
        }
        const transactions = [];
        for (let i = 0; i < expectedLength; i++) {
            let plainSignedTransaction = new plainSignedTransaction_1.PlainSignedTransaction(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ nonce: parseInt(urlParams["nonce"][i]), value: urlParams["value"][i], receiver: urlParams["receiver"][i], sender: urlParams["sender"][i], gasPrice: parseInt(urlParams["gasPrice"][i]), gasLimit: parseInt(urlParams["gasLimit"][i]), 
                // Handle the optional "data" property.
                data: urlParams["data"] && urlParams["data"][i] ? urlParams["data"][i] : "", chainID: urlParams["chainID"][i], version: parseInt(urlParams["version"][i]) }, (urlParams["guardian"] && urlParams["guardian"][i] ? { guardian: urlParams["guardian"][i] } : {})), (urlParams["guardianSignature"] && urlParams["guardianSignature"][i] ? { guardianSignature: urlParams["guardianSignature"][i] } : {})), (urlParams["options"] && urlParams["options"][i] ? {
                options: parseInt(urlParams["options"][i])
            } : {})), (urlParams["senderUsername"] && urlParams["senderUsername"][i] ? { senderUsername: urlParams["senderUsername"][i] } : {})), (urlParams["receiverUsername"] && urlParams["receiverUsername"][i] ? { receiverUsername: urlParams["receiverUsername"][i] } : {})), { signature: urlParams["signature"][i] }));
            transactions.push(plainSignedTransaction);
        }
        return transactions;
    }
    static prepareWalletTransaction(transaction) {
        let plainTransaction = transaction.toPlainObject();
        // We adjust the data field, in order to make it compatible with what the web wallet expects.
        if (plainTransaction.data) {
            plainTransaction.data = Buffer.from(plainTransaction.data, "base64").toString();
        }
        else {
            // The web wallet expects the data field to be a string, even if it's empty (early 2023).
            plainTransaction.data = "";
        }
        return plainTransaction;
    }
    buildWalletUrl(options) {
        const callbackUrl = (options === null || options === void 0 ? void 0 : options.callbackUrl) || window.location.href;
        const partialQueryString = qs_1.default.stringify(options.params || {});
        const fullQueryString = partialQueryString ? `${partialQueryString}&callbackUrl=${callbackUrl}` : `callbackUrl=${callbackUrl}`;
        const url = `${this.baseWalletUrl()}/${options.endpoint}?${fullQueryString}`;
        console.info(`Redirecting to Wallet URL: ${decodeURI(url)}`);
        return url;
    }
    baseWalletUrl() {
        const pathArray = this.walletUrl.split('/');
        const protocol = pathArray[0];
        const host = pathArray[2];
        return protocol + '//' + host;
    }
    /**
     * Packs an array of {$link Transaction} and redirects to the specified wallet hook
     *
     * @param transactions
     * @param options
     */
    redirectTransactionsToEndpoint(endpoint, transactions, options) {
        const jsonToSend = {};
        transactions.map(tx => {
            let plainTx = WalletProvider.prepareWalletTransaction(tx);
            for (let txProp in plainTx) {
                if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {
                    jsonToSend[txProp] = [];
                }
                jsonToSend[txProp].push(plainTx[txProp]);
            }
        });
        const redirectUrl = this.buildWalletUrl({
            endpoint,
            callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl,
            params: jsonToSend
        });
        window.location.href = redirectUrl;
    }
}
exports.WalletProvider = WalletProvider;
//# sourceMappingURL=walletProvider.js.map