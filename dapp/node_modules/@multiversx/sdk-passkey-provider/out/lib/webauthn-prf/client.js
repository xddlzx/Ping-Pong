"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticate = exports.register = exports.isLocalAuthenticator = exports.isAvailable = void 0;
/* eslint-disable @typescript-eslint/ban-ts-comment */
const short_unique_id_1 = __importDefault(require("short-unique-id"));
const utils = __importStar(require("./utils.js"));
//generated with crypto.getRandomValues
const randomness = '125,31,50,6,242,196,44,99,212,140,13,135,165,76,139,234,130,235,189,246,131,38,217,236,172,174,67,82,180,79,137,150';
const salt = new Uint8Array(randomness.split(',').map((str) => parseInt(str)));
/**
 * Returns whether passwordless authentication is available on this browser/platform or not.
 */
function isAvailable() {
    return !!window.PublicKeyCredential;
}
exports.isAvailable = isAvailable;
/**
 * Returns whether the device itself can be used as authenticator.
 */
async function isLocalAuthenticator() {
    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
}
exports.isLocalAuthenticator = isLocalAuthenticator;
async function getAuthAttachment(authType) {
    if (authType === 'local') {
        return 'platform';
    }
    if (authType === 'roaming' || authType === 'extern') {
        return 'cross-platform';
    }
    if (authType === 'both') {
        return undefined;
    } // The webauthn protocol considers `null` as invalid but `undefined` as "both"!
    // the default case: "auto", depending on device capabilities
    try {
        if (await isLocalAuthenticator()) {
            return 'platform';
        }
        else {
            return 'cross-platform';
        }
    }
    catch (e) {
        // might happen due to some security policies
        // see https://w3c.github.io/webauthn/#sctn-isUserVerifyingPlatformAuthenticatorAvailable
        return undefined; // The webauthn protocol considers `null` as invalid but `undefined` as "both"!
    }
}
const getDomainWithoutSubdomain = (url) => {
    const urlParts = new URL(url).hostname.split('.');
    return urlParts
        .slice(0)
        .slice(-(urlParts.length === 4 ? 3 : 2))
        .join('.');
};
function getAlgoName(num) {
    switch (num) {
        case -7:
            return 'ES256';
        // case -8 ignored to to its rarity
        case -257:
            return 'RS256';
        default:
            throw new Error(`Unknown algorithm code: ${num}`);
    }
}
/**
 * Creates a cryptographic key pair, in order to register the public key for later passwordless authentication.
 *
 * @param {string} username
 * @param {string} challenge A server-side randomly generated string.
 * @param {Object} [options] Optional parameters.
 * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.
 * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.
 * @param {'auto'|'local'|'roaming'|'both'}       [options.authenticatorType='auto'] Which device to use as authenticator.
 *          'auto': if the local device can be used as authenticator it will be preferred. Otherwise it will prompt for a roaming device.
 *          'local': use the local device (using TouchID, FaceID, Windows Hello or PIN)
 *          'roaming': use a roaming device (security key or connected phone)
 *          'both': prompt the user to choose between local or roaming device. The UI and user interaction in this case is platform specific.
 * @param {boolean} [attestation=false] If enabled, the device attestation and clientData will be provided as Base64url encoded binary data.
 *                                Note that this is not available on some platforms.
 */
async function register(username, challenge, options) {
    options = options ?? {};
    if (!utils.isBase64url(challenge)) {
        throw new Error('Provided challenge is not properly encoded in Base64url');
    }
    const uid = new short_unique_id_1.default({ length: 5 });
    const usernameRandom = uid.rnd();
    const creationOptions = {
        challenge: utils.parseBase64url(challenge),
        rp: {
            id: getDomainWithoutSubdomain(window.location.href),
            name: getDomainWithoutSubdomain(window.location.href)
        },
        user: {
            id: await utils.sha256(new TextEncoder().encode(`${username}-${usernameRandom}`)),
            name: `${username}-${usernameRandom}`,
            displayName: `${username}-${usernameRandom}`
        },
        pubKeyCredParams: [
            { alg: -7, type: 'public-key' },
            { alg: -257, type: 'public-key' } // RS256 (for Windows Hello and others)
        ],
        timeout: options.timeout ?? 60000,
        authenticatorSelection: {
            residentKey: 'required',
            requireResidentKey: true,
            userVerification: options.userVerification ?? 'required',
            authenticatorAttachment: await getAuthAttachment('auto')
        },
        attestation: 'direct',
        extensions: {
            prf: {
                eval: {
                    first: salt.buffer
                }
            }
        }
    };
    if (options.debug) {
        console.debug(creationOptions);
    }
    const credential = (await navigator.credentials.create({
        publicKey: creationOptions
    }));
    if (options.debug) {
        console.debug(credential);
    }
    const response = credential.response;
    const publicKey = response.getPublicKey();
    const publicKeyAlgorithm = credential.response.getPublicKeyAlgorithm();
    if (!publicKey) {
        throw new Error('Could not retrieve public key');
    }
    if (!publicKeyAlgorithm) {
        throw new Error('Could not retrieve public key algorithm');
    }
    const registration = {
        username: username,
        credential: {
            id: credential.id,
            publicKey: utils.toBase64url(publicKey),
            algorithm: getAlgoName(publicKeyAlgorithm)
        },
        authenticatorData: utils.toBase64url(response.getAuthenticatorData()),
        clientData: utils.toBase64url(response.clientDataJSON),
        extensionResults: new Uint8Array(credential.getClientExtensionResults().prf.results.first)
    };
    if (options.attestation) {
        registration.attestationData = utils.toBase64url(response.attestationObject);
    }
    return registration;
}
exports.register = register;
async function getTransports(authType) {
    const local = ['internal'];
    //@ts-ignore
    const roaming = ['hybrid', 'usb', 'ble', 'nfc'];
    if (authType === 'local') {
        return local;
    }
    if (authType == 'roaming' || authType === 'extern') {
        return roaming;
    }
    if (authType === 'both') {
        return [...local, ...roaming];
    }
    // the default case: "auto", depending on device capabilities
    try {
        if (await isLocalAuthenticator()) {
            return local;
        }
        else {
            return roaming;
        }
    }
    catch (e) {
        return [...local, ...roaming];
    }
}
/**
 * Signs a challenge using one of the provided credentials IDs in order to authenticate the user.
 *
 * @param {string[]} credentialIds The list of credential IDs that can be used for signing.
 * @param {string} challenge A server-side randomly generated string, the base64 encoded version will be signed.
 * @param {Object} [options] Optional parameters.
 * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.
 * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.
 * @param {'optional'|'conditional'|'required'|'silent'} [options.mediation='optional'] https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get#mediation
 */
async function authenticate(credentialIds, challenge, options) {
    options = options ?? {};
    if (!utils.isBase64url(challenge)) {
        throw new Error('Provided challenge is not properly encoded in Base64url');
    }
    const transports = await getTransports(options.authenticatorType ?? 'auto');
    const authOptions = {
        challenge: utils.parseBase64url(challenge),
        rpId: getDomainWithoutSubdomain(window.location.href),
        allowCredentials: credentialIds.map((id) => {
            return {
                id: utils.parseBase64url(id),
                type: 'public-key',
                transports: transports
            };
        }),
        userVerification: options.userVerification ?? 'required',
        timeout: options.timeout ?? 60000,
        extensions: {
            prf: {
                eval: {
                    first: salt.buffer
                }
            }
        }
    };
    if (options.debug) {
        console.debug(authOptions);
    }
    const auth = (await navigator.credentials.get({
        publicKey: authOptions,
        mediation: options.mediation
    }));
    if (options.debug) {
        console.debug(auth);
    }
    const response = auth.response;
    const authentication = {
        credentialId: auth.id,
        //userHash: utils.toBase64url(response.userHandle), // unreliable, optional for authenticators
        authenticatorData: utils.toBase64url(response.authenticatorData),
        clientData: utils.toBase64url(response.clientDataJSON),
        signature: utils.toBase64url(response.signature),
        extensionResults: new Uint8Array(auth.getClientExtensionResults().prf.results.first)
    };
    return authentication;
}
exports.authenticate = authenticate;
//# sourceMappingURL=client.js.map