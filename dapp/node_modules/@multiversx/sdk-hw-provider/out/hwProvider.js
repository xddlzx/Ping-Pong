"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HWProvider = void 0;
const hw_transport_web_ble_1 = __importDefault(require("@ledgerhq/hw-transport-web-ble"));
const hw_transport_webhid_1 = __importDefault(require("@ledgerhq/hw-transport-webhid"));
const hw_transport_webusb_1 = __importDefault(require("@ledgerhq/hw-transport-webusb"));
const sdk_core_1 = require("@multiversx/sdk-core");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const ledgerApp_1 = __importDefault(require("./ledgerApp"));
const transport_type_enum_1 = require("./transport-type.enum");
const versioning_1 = require("./versioning");
class HWProvider {
    constructor(_hwApp) {
        this._hwApp = _hwApp;
        this._addressIndex = 0;
        this._account = { address: '' };
    }
    get addressIndex() {
        return this._addressIndex;
    }
    get hwApp() {
        return this._hwApp;
    }
    get transportType() {
        return this._transportType;
    }
    /**
     * Creates transport and initialises ledger app.
     */
    init(type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isInitialized()) {
                return true;
            }
            try {
                const { transport, transportType } = yield this.getTransport(type);
                this._transportType = transportType;
                this._transport = transport;
                this._hwApp = new ledgerApp_1.default(this._transport);
                return this.isInitialized();
            }
            catch (error) {
                console.error("Provider initialization error", error);
                return false;
            }
        });
    }
    getTransport(transportType) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._transport && this._transportType) {
                return {
                    transport: this._transport,
                    transportType: this._transportType
                };
            }
            const isLedgerSupported = yield this.isLedgerTransportSupported();
            if (!isLedgerSupported) {
                throw new Error("Ledger is not supported");
            }
            if (transportType) {
                const transport = yield this.getTransportByType(transportType);
                if (!transport) {
                    throw new Error(`Failed to initialize provider type ${transportType}`);
                }
                return {
                    transport,
                    transportType
                };
            }
            let transport = yield this.getUSBTransport();
            if (transport) {
                return {
                    transport,
                    transportType: transport_type_enum_1.TransportType.USB
                };
            }
            transport = yield this.getBLETransport();
            if (transport) {
                return {
                    transport,
                    transportType: transport_type_enum_1.TransportType.BLE
                };
            }
            transport = yield this.getHIDTransport();
            if (transport) {
                return {
                    transport,
                    transportType: transport_type_enum_1.TransportType.HID
                };
            }
            throw new Error("Failed to initialize provider");
        });
    }
    getTransportByType(type) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (type) {
                case transport_type_enum_1.TransportType.USB:
                    return this.getUSBTransport();
                case transport_type_enum_1.TransportType.BLE:
                    return this.getBLETransport();
                case transport_type_enum_1.TransportType.HID:
                    return this.getHIDTransport();
                default:
                    throw new Error("Transport type not supported");
            }
        });
    }
    getUSBTransport() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const webUSBSupported = yield this.isWebUSBSupported();
                if (webUSBSupported) {
                    console.log("Web USB Transport selected");
                    return yield hw_transport_webusb_1.default.create();
                }
            }
            catch (error) {
                console.error("Failed to create USB transport:", error);
            }
            return null;
        });
    }
    getBLETransport() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const webBLESupported = yield this.isBLESupported();
                if (webBLESupported) {
                    console.log("Web BLE Transport selected");
                    return yield hw_transport_web_ble_1.default.create();
                }
            }
            catch (error) {
                console.error("Failed to create BLE transport:", error);
            }
            return null;
        });
    }
    getHIDTransport() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const webHIDSupported = yield this.isWebHIDSupported();
                if (webHIDSupported) {
                    console.log("Web HID Transport selected");
                    return yield hw_transport_webhid_1.default.create();
                }
            }
            catch (error) {
                console.error("Failed to create HID transport:", error);
            }
            return null;
        });
    }
    isLedgerTransportSupported() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.isBLESupported()) || (yield this.isWebUSBSupported()) || (yield this.isWebHIDSupported());
        });
    }
    isBLESupported() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield hw_transport_web_ble_1.default.isSupported();
        });
    }
    isWebUSBSupported() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield hw_transport_webusb_1.default.isSupported();
        });
    }
    isWebHIDSupported() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield hw_transport_webhid_1.default.isSupported();
        });
    }
    /**
     * Returns true if init() was previously called successfully
     */
    isInitialized() {
        return Boolean(this.hwApp && this._transport && this._transportType);
    }
    /**
     * Mocked function, returns isInitialized as an async function
     */
    isConnected() {
        if (!this.isInitialized()) {
            return false;
        }
        if (this._transportType === transport_type_enum_1.TransportType.USB) {
            return this._transport.device.opened;
        }
        if (this._transportType === transport_type_enum_1.TransportType.BLE) {
            return this._transport.device.gatt.connected;
        }
        return true;
    }
    /**
     * Returns the current account if it exists
     */
    getAccount() {
        return this._account;
    }
    /**
     * Sets the current account
     * @param account
     * @returns void
     */
    setAccount(account) {
        this._account = account;
    }
    /**
     * Performs a login request by setting the selected index in Ledger and returning that address
     */
    login() {
        return __awaiter(this, arguments, void 0, function* (options = { addressIndex: 0 }) {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            yield this.setAddressIndex(options.addressIndex);
            const { address } = yield this.hwApp.getAddress(0, options.addressIndex, true);
            this._account = {
                address
            };
            return this._account;
        });
    }
    setAddressIndex(addressIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            this._addressIndex = addressIndex;
            yield this.hwApp.setAddress(0, addressIndex);
        });
    }
    getAccounts() {
        return __awaiter(this, arguments, void 0, function* (page = 0, pageSize = 10) {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            const addresses = [];
            const startIndex = page * pageSize;
            for (let index = startIndex; index < startIndex + pageSize; index++) {
                const { address } = yield this.hwApp.getAddress(0, index);
                addresses.push(address);
            }
            return addresses;
        });
    }
    /**
     * Mocks a logout request by returning true
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            return true;
        });
    }
    /**
     * Fetches current selected ledger address
     */
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            const { address } = yield this.hwApp.getAddress(0, this._addressIndex);
            return address;
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            transaction = this.cloneTransaction(transaction);
            const appFeatures = yield this.getAppFeatures();
            const appVersion = appFeatures.appVersion;
            const mustUseVersionWithOptions = appFeatures.mustUseVersionWithOptions;
            const mustUsingHash = appFeatures.mustSignUsingHash;
            const canUseGuardian = appFeatures.canUseGuardian;
            const inputOptions = transaction.getOptions().valueOf();
            const hasGuardianOption = inputOptions & constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
            if (hasGuardianOption && !canUseGuardian) {
                throw new Error(`MultiversX App v${appVersion} does not support guarded transactions.`);
            }
            if (mustUseVersionWithOptions) {
                transaction.setVersion(constants_1.TRANSACTION_VERSION_WITH_OPTIONS);
                console.info("Transaction version: ", transaction.getVersion().valueOf());
            }
            if (mustUsingHash) {
                transaction.setOptions(inputOptions | constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN);
                console.info("Transaction options: ", transaction.getOptions().valueOf());
            }
            const serializedTransaction = transaction.serializeForSigning();
            const serializedTransactionBuffer = Buffer.from(serializedTransaction);
            const signature = yield this.hwApp.signTransaction(serializedTransactionBuffer, mustUsingHash);
            transaction.applySignature(Buffer.from(signature, "hex"));
            return transaction;
        });
    }
    cloneTransaction(transaction) {
        return sdk_core_1.Transaction.fromPlainObject(transaction.toPlainObject());
    }
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedTransactions = [];
            for (const transaction of transactions) {
                const signedTransaction = yield this.signTransaction(transaction);
                signedTransactions.push(signedTransaction);
            }
            return signedTransactions;
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            const message = new sdk_core_1.Message({
                data: Buffer.from(messageToSign.data),
                address: (_a = messageToSign.address) !== null && _a !== void 0 ? _a : sdk_core_1.Address.fromBech32(this._account.address),
                signer: constants_1.SIGNER,
                version: messageToSign.version
            });
            const messageSize = this.getMessageSize(messageToSign);
            const serializedMessageBuffer = Buffer.concat([
                messageSize,
                Buffer.from(messageToSign.data)
            ]);
            const signature = yield this.hwApp.signMessage(serializedMessageBuffer);
            message.signature = Buffer.from(signature, "hex");
            return message;
        });
    }
    getMessageSize(message) {
        const messageSize = Buffer.alloc(4);
        messageSize.writeUInt32BE(message.data.length, 0);
        return messageSize;
    }
    tokenLogin(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            let addressIndex = options.addressIndex || 0;
            yield this.setAddressIndex(addressIndex);
            const { signature, address } = yield this.hwApp.getAddressAndSignAuthToken(0, addressIndex, options.token);
            return {
                signature: Buffer.from(signature, "hex"),
                address
            };
        });
    }
    getAppFeatures() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hwApp) {
                throw new errors_1.ErrNotInitialized();
            }
            const config = yield this.hwApp.getAppConfiguration();
            const appVersion = config.version;
            const mustSignUsingHash = (0, versioning_1.compareVersions)(appVersion, constants_1.LEDGER_TX_HASH_SIGN_MIN_VERSION) >= 0;
            const canUseGuardian = (0, versioning_1.compareVersions)(appVersion, constants_1.LEDGER_TX_GUARDIAN_MIN_VERSION) >= 0;
            return {
                appVersion: appVersion,
                mustUseVersionWithOptions: mustSignUsingHash,
                mustSignUsingHash: mustSignUsingHash,
                canUseGuardian: canUseGuardian
            };
        });
    }
}
exports.HWProvider = HWProvider;
//# sourceMappingURL=hwProvider.js.map