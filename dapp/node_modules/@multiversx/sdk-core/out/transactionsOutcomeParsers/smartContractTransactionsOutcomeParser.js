"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContractTransactionsOutcomeParser = void 0;
const address_1 = require("../address");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const smartcontracts_1 = require("../smartcontracts");
const resources_1 = require("./resources");
var Events;
(function (Events) {
    Events["SCDeploy"] = "SCDeploy";
    Events["SignalError"] = "signalError";
    Events["WriteLog"] = "writeLog";
})(Events || (Events = {}));
class SmartContractTransactionsOutcomeParser {
    constructor(options) {
        this.abi = options?.abi;
        this.legacyResultsParser = options?.legacyResultsParser || new smartcontracts_1.ResultsParser();
    }
    parseDeploy(options) {
        if ("transactionOutcome" in options) {
            return this.parseDeployGivenTransactionOutcome(options.transactionOutcome);
        }
        return this.parseDeployGivenTransactionOnNetwork(options.transactionOnNetwork);
    }
    /**
     * Legacy approach.
     */
    parseDeployGivenTransactionOutcome(transactionOutcome) {
        const directCallOutcome = transactionOutcome.directSmartContractCallOutcome;
        const events = resources_1.findEventsByIdentifier(transactionOutcome, Events.SCDeploy);
        const contracts = events.map((event) => this.parseScDeployEvent(event));
        return {
            returnCode: directCallOutcome.returnCode,
            returnMessage: directCallOutcome.returnMessage,
            contracts: contracts,
        };
    }
    parseDeployGivenTransactionOnNetwork(transactionOnNetwork) {
        const directCallOutcome = this.findDirectSmartContractCallOutcome(transactionOnNetwork);
        const events = transactionOnNetwork.logs.events
            .concat(transactionOnNetwork.contractResults.items.flatMap((result) => result.logs.events))
            .filter((event) => event.identifier === Events.SCDeploy);
        const contracts = events.map((event) => this.parseScDeployEvent({
            topics: event.topics.map((topic) => Buffer.from(topic.hex(), "hex")),
        }));
        return {
            returnCode: directCallOutcome.returnCode,
            returnMessage: directCallOutcome.returnMessage,
            contracts: contracts,
        };
    }
    parseScDeployEvent(event) {
        const topicForAddress = event.topics[0];
        const topicForOwnerAddress = event.topics[1];
        const topicForCodeHash = event.topics[2];
        const address = topicForAddress?.length ? new address_1.Address(topicForAddress).toBech32() : "";
        const ownerAddress = topicForOwnerAddress?.length ? new address_1.Address(topicForOwnerAddress).toBech32() : "";
        const codeHash = topicForCodeHash;
        return {
            address,
            ownerAddress,
            codeHash,
        };
    }
    parseExecute(options) {
        if ("transactionOutcome" in options) {
            return this.parseExecuteGivenTransactionOutcome(options.transactionOutcome, options.function);
        }
        return this.parseExecuteGivenTransactionOnNetwork(options.transactionOnNetwork, options.function);
    }
    /**
     * Legacy approach.
     */
    parseExecuteGivenTransactionOutcome(transactionOutcome, functionName) {
        const directCallOutcome = transactionOutcome.directSmartContractCallOutcome;
        if (!this.abi) {
            return {
                values: directCallOutcome.returnDataParts,
                returnCode: directCallOutcome.returnCode,
                returnMessage: directCallOutcome.returnMessage,
            };
        }
        functionName = functionName || directCallOutcome.function;
        if (!functionName) {
            throw new errors_1.Err(`Function name is not available in the transaction outcome, thus endpoint definition (ABI) cannot be picked (for parsing). Maybe provide the "function" parameter explicitly?`);
        }
        const endpoint = this.abi.getEndpoint(functionName);
        const legacyUntypedBundle = {
            returnCode: new smartcontracts_1.ReturnCode(directCallOutcome.returnCode),
            returnMessage: directCallOutcome.returnMessage,
            values: directCallOutcome.returnDataParts.map((part) => Buffer.from(part)),
        };
        const legacyTypedBundle = this.legacyResultsParser.parseOutcomeFromUntypedBundle(legacyUntypedBundle, endpoint);
        return {
            values: legacyTypedBundle.values.map((value) => value.valueOf()),
            returnCode: legacyTypedBundle.returnCode.toString(),
            returnMessage: legacyTypedBundle.returnMessage,
        };
    }
    parseExecuteGivenTransactionOnNetwork(transactionOnNetwork, functionName) {
        const directCallOutcome = this.findDirectSmartContractCallOutcome(transactionOnNetwork);
        if (!this.abi) {
            return {
                values: directCallOutcome.returnDataParts,
                returnCode: directCallOutcome.returnCode,
                returnMessage: directCallOutcome.returnMessage,
            };
        }
        functionName = functionName || directCallOutcome.function;
        if (!functionName) {
            throw new errors_1.Err(`Function name is not available in the transaction, thus endpoint definition (ABI) cannot be picked (for parsing). Maybe provide the "function" parameter explicitly?`);
        }
        const argsSerializer = new smartcontracts_1.ArgSerializer();
        const endpoint = this.abi.getEndpoint(functionName);
        const buffers = directCallOutcome.returnDataParts.map((part) => Buffer.from(part));
        const values = argsSerializer.buffersToValues(buffers, endpoint.output);
        return {
            returnCode: directCallOutcome.returnCode,
            returnMessage: directCallOutcome.returnMessage,
            values: values,
        };
    }
    findDirectSmartContractCallOutcome(transactionOnNetwork) {
        let outcome = this.findDirectSmartContractCallOutcomeWithinSmartContractResults(transactionOnNetwork);
        if (outcome) {
            return outcome;
        }
        outcome = this.findDirectSmartContractCallOutcomeIfError(transactionOnNetwork);
        if (outcome) {
            return outcome;
        }
        outcome = this.findDirectSmartContractCallOutcomeWithinWriteLogEvents(transactionOnNetwork);
        if (outcome) {
            return outcome;
        }
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: "",
            returnMessage: "",
            returnDataParts: [],
        });
    }
    findDirectSmartContractCallOutcomeWithinSmartContractResults(transactionOnNetwork) {
        const argSerializer = new smartcontracts_1.ArgSerializer();
        const eligibleResults = [];
        for (const result of transactionOnNetwork.contractResults.items) {
            const matchesCriteriaOnData = result.data.startsWith(constants_1.ARGUMENTS_SEPARATOR);
            const matchesCriteriaOnReceiver = result.receiver.bech32() === transactionOnNetwork.sender.bech32();
            const matchesCriteriaOnPreviousHash = result.previousHash === transactionOnNetwork.hash;
            const matchesCriteria = matchesCriteriaOnData && matchesCriteriaOnReceiver && matchesCriteriaOnPreviousHash;
            if (matchesCriteria) {
                eligibleResults.push(result);
            }
        }
        if (eligibleResults.length === 0) {
            return null;
        }
        if (eligibleResults.length > 1) {
            throw new Error(`More than one smart contract result (holding the return data) found for transaction: ${transactionOnNetwork.hash}`);
        }
        const [result] = eligibleResults;
        const [_ignored, returnCode, ...returnDataParts] = argSerializer.stringToBuffers(result.data);
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: returnCode?.toString(),
            returnMessage: result.returnMessage || returnCode?.toString(),
            returnDataParts: returnDataParts,
        });
    }
    findDirectSmartContractCallOutcomeIfError(transactionOnNetwork) {
        const argSerializer = new smartcontracts_1.ArgSerializer();
        const eventIdentifier = Events.SignalError;
        const eligibleEvents = [];
        // First, look in "logs":
        eligibleEvents.push(...transactionOnNetwork.logs.events.filter((event) => event.identifier === eventIdentifier));
        // Then, look in "logs" of "contractResults":
        for (const result of transactionOnNetwork.contractResults.items) {
            if (result.previousHash != transactionOnNetwork.hash) {
                continue;
            }
            eligibleEvents.push(...result.logs.events.filter((event) => event.identifier === eventIdentifier));
        }
        if (eligibleEvents.length === 0) {
            return null;
        }
        if (eligibleEvents.length > 1) {
            throw new Error(`More than one "${eventIdentifier}" event found for transaction: ${transactionOnNetwork.hash}`);
        }
        const [event] = eligibleEvents;
        const data = event.dataPayload?.valueOf().toString() || "";
        const lastTopic = event.getLastTopic()?.toString();
        const parts = argSerializer.stringToBuffers(data);
        // Assumption: the last part is the return code.
        const returnCode = parts[parts.length - 1];
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: returnCode?.toString() || eventIdentifier,
            returnMessage: lastTopic || returnCode?.toString() || eventIdentifier,
            returnDataParts: [],
        });
    }
    findDirectSmartContractCallOutcomeWithinWriteLogEvents(transactionOnNetwork) {
        const argSerializer = new smartcontracts_1.ArgSerializer();
        const eventIdentifier = Events.WriteLog;
        const eligibleEvents = [];
        // First, look in "logs":
        eligibleEvents.push(...transactionOnNetwork.logs.events.filter((event) => event.identifier === eventIdentifier));
        // Then, look in "logs" of "contractResults":
        for (const result of transactionOnNetwork.contractResults.items) {
            if (result.previousHash != transactionOnNetwork.hash) {
                continue;
            }
            eligibleEvents.push(...result.logs.events.filter((event) => event.identifier === eventIdentifier));
        }
        if (eligibleEvents.length === 0) {
            return null;
        }
        if (eligibleEvents.length > 1) {
            throw new Error(`More than one "${eventIdentifier}" event found for transaction: ${transactionOnNetwork.hash}`);
        }
        const [event] = eligibleEvents;
        const data = event.dataPayload?.valueOf().toString() || "";
        const [_ignored, returnCode, ...returnDataParts] = argSerializer.stringToBuffers(data);
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: returnCode?.toString(),
            returnMessage: returnCode?.toString(),
            returnDataParts: returnDataParts,
        });
    }
}
exports.SmartContractTransactionsOutcomeParser = SmartContractTransactionsOutcomeParser;
//# sourceMappingURL=smartContractTransactionsOutcomeParser.js.map