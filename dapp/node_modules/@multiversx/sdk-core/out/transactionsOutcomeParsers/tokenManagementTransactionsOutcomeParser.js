"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenManagementTransactionsOutcomeParser = void 0;
const address_1 = require("../address");
const transactionsConverter_1 = require("../converters/transactionsConverter");
const errors_1 = require("../errors");
const utils_1 = require("../smartcontracts/codec/utils");
const resources_1 = require("./resources");
class TokenManagementTransactionsOutcomeParser {
    constructor() { }
    parseIssueFungible(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "issue");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseIssueNonFungible(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "issueNonFungible");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseIssueSemiFungible(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "issueSemiFungible");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseRegisterMetaEsdt(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "registerMetaESDT");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseRegisterAndSetAllRoles(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const registerEvents = resources_1.findEventsByIdentifier(transaction, "registerAndSetAllRoles");
        const setRoleEvents = resources_1.findEventsByIdentifier(transaction, "ESDTSetRole");
        if (registerEvents.length !== setRoleEvents.length) {
            throw new errors_1.ErrParseTransactionOutcome("Register Events and Set Role events mismatch. Should have the same number of events.");
        }
        return registerEvents.map((registerEvent, index) => {
            const tokenIdentifier = this.extractTokenIdentifier(registerEvent);
            const encodedRoles = setRoleEvents[index].topics.slice(3);
            const roles = encodedRoles.map((role) => this.decodeTopicAsString(role));
            return { tokenIdentifier, roles };
        });
    }
    parseSetBurnRoleGlobally(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
    }
    parseUnsetBurnRoleGlobally(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
    }
    parseSetSpecialRole(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTSetRole");
        return events.map((event) => this.getOutputForSetSpecialRoleEvent(event));
    }
    getOutputForSetSpecialRoleEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const encodedRoles = event.topics.slice(3);
        const roles = encodedRoles.map((role) => this.decodeTopicAsString(role));
        return { userAddress: userAddress, tokenIdentifier: tokenIdentifier, roles: roles };
    }
    parseNftCreate(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTCreate");
        return events.map((event) => this.getOutputForNftCreateEvent(event));
    }
    getOutputForNftCreateEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const amount = this.extractAmount(event);
        return { tokenIdentifier: tokenIdentifier, nonce: nonce, initialQuantity: amount };
    }
    parseLocalMint(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTLocalMint");
        return events.map((event) => this.getOutputForLocalMintEvent(event));
    }
    getOutputForLocalMintEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const mintedSupply = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            mintedSupply: mintedSupply,
        };
    }
    parseLocalBurn(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTLocalBurn");
        return events.map((event) => this.getOutputForLocalBurnEvent(event));
    }
    getOutputForLocalBurnEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntSupply = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            burntSupply: burntSupply,
        };
    }
    parsePause(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTPause");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseUnpause(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTUnPause");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseFreeze(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTFreeze");
        return events.map((event) => this.getOutputForFreezeEvent(event));
    }
    getOutputForFreezeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            balance: balance,
        };
    }
    parseUnfreeze(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTUnFreeze");
        return events.map((event) => this.getOutputForUnfreezeEvent(event));
    }
    getOutputForUnfreezeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            balance: balance,
        };
    }
    parseWipe(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTWipe");
        return events.map((event) => this.getOutputForWipeEvent(event));
    }
    getOutputForWipeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            balance: balance,
        };
    }
    parseUpdateAttributes(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTUpdateAttributes");
        return events.map((event) => this.getOutputForUpdateAttributesEvent(event));
    }
    getOutputForUpdateAttributesEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const attributes = event.topics[3] ? event.topics[3] : new Uint8Array();
        return {
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            attributes: attributes,
        };
    }
    parseAddQuantity(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTAddQuantity");
        return events.map((event) => this.getOutputForAddQuantityEvent(event));
    }
    getOutputForAddQuantityEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const addedQuantity = this.extractAmount(event);
        return {
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            addedQuantity: addedQuantity,
        };
    }
    parseBurnQuantity(transaction) {
        transaction = this.ensureTransactionOutcome(transaction);
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTBurn");
        return events.map((event) => this.getOutputForBurnQuantityEvent(event));
    }
    getOutputForBurnQuantityEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntQuantity = this.extractAmount(event);
        return {
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            burntQuantity: burntQuantity,
        };
    }
    /**
     * Temporary workaround, until "TransactionOnNetwork" completely replaces "TransactionOutcome".
     */
    ensureTransactionOutcome(transaction) {
        if ("hash" in transaction) {
            return new transactionsConverter_1.TransactionsConverter().transactionOnNetworkToOutcome(transaction);
        }
        return transaction;
    }
    ensureNoError(transactionEvents) {
        for (const event of transactionEvents) {
            if (event.identifier == "signalError") {
                const data = Buffer.from(event.dataItems[0]?.toString().slice(1)).toString() || "";
                const message = this.decodeTopicAsString(event.topics[1]);
                throw new errors_1.ErrParseTransactionOutcome(`encountered signalError: ${message} (${Buffer.from(data, "hex").toString()})`);
            }
        }
    }
    extractTokenIdentifier(event) {
        if (!event.topics[0]?.length) {
            return "";
        }
        return this.decodeTopicAsString(event.topics[0]);
    }
    extractNonce(event) {
        if (!event.topics[1]?.length) {
            return BigInt(0);
        }
        const nonce = Buffer.from(event.topics[1]);
        return BigInt(utils_1.bufferToBigInt(nonce).toFixed(0));
    }
    extractAmount(event) {
        if (!event.topics[2]?.length) {
            return BigInt(0);
        }
        const amount = Buffer.from(event.topics[2]);
        return BigInt(utils_1.bufferToBigInt(amount).toFixed(0));
    }
    extractAddress(event) {
        if (!event.topics[3]?.length) {
            return "";
        }
        const address = Buffer.from(event.topics[3]);
        return address_1.Address.fromBuffer(address).bech32();
    }
    decodeTopicAsString(topic) {
        return Buffer.from(topic).toString();
    }
}
exports.TokenManagementTransactionsOutcomeParser = TokenManagementTransactionsOutcomeParser;
//# sourceMappingURL=tokenManagementTransactionsOutcomeParser.js.map