"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelayedTransactionV1Builder = void 0;
const address_1 = require("./address");
const errors_1 = require("./errors");
const transaction_1 = require("./transaction");
const transactionPayload_1 = require("./transactionPayload");
const JSONbig = require("json-bigint");
/**
 * @deprecated Use {@link RelayedTransactionsFactory} instead.
 */
class RelayedTransactionV1Builder {
    /**
     * Sets the inner transaction to be used. It has to be already signed.
     *
     * @param {Transaction} transaction The inner transaction to be used
     */
    setInnerTransaction(transaction) {
        this.innerTransaction = transaction;
        return this;
    }
    /**
     * Sets the network config to be used for building the relayed v1 transaction
     *
     * @param {INetworkConfig} netConfig The network configuration to be used
     */
    setNetworkConfig(netConfig) {
        this.netConfig = netConfig;
        return this;
    }
    /**
     * Sets the address of the relayer (the one that will actually pay the fee)
     *
     * @param relayerAddress
     */
    setRelayerAddress(relayerAddress) {
        this.relayerAddress = relayerAddress;
        return this;
    }
    /**
     * (optional) Sets the nonce of the relayer
     *
     * @param relayerNonce
     */
    setRelayerNonce(relayerNonce) {
        this.relayerNonce = relayerNonce;
        return this;
    }
    /**
     * (optional) Sets the version of the relayed transaction
     *
     * @param relayedTxVersion
     */
    setRelayedTransactionVersion(relayedTxVersion) {
        this.relayedTransactionVersion = relayedTxVersion;
        return this;
    }
    /**
     * (optional) Sets the options of the relayed transaction
     *
     * @param relayedTxOptions
     */
    setRelayedTransactionOptions(relayedTxOptions) {
        this.relayedTransactionOptions = relayedTxOptions;
        return this;
    }
    /**
     * (optional) Sets the guardian of the relayed transaction
     *
     * @param relayedTxGuardian
     */
    setRelayedTransactionGuardian(relayedTxGuardian) {
        this.relayedTransactionGuardian = relayedTxGuardian;
        return this;
    }
    /**
     * Tries to build the relayed v1 transaction based on the previously set fields
     *
     * @throws ErrInvalidRelayedV1BuilderArguments
     * @return Transaction
     */
    build() {
        if (!this.innerTransaction ||
            !this.netConfig ||
            !this.relayerAddress ||
            !this.innerTransaction.getSignature()) {
            throw new errors_1.ErrInvalidRelayedV1BuilderArguments();
        }
        const serializedTransaction = this.prepareInnerTransaction();
        const data = `relayedTx@${Buffer.from(serializedTransaction).toString("hex")}`;
        const payload = new transactionPayload_1.TransactionPayload(data);
        const gasLimit = this.netConfig.MinGasLimit +
            this.netConfig.GasPerDataByte * payload.length() +
            this.innerTransaction.getGasLimit().valueOf();
        let relayedTransaction = new transaction_1.Transaction({
            nonce: this.relayerNonce,
            sender: this.relayerAddress,
            receiver: this.innerTransaction.getSender(),
            value: 0,
            gasLimit: gasLimit,
            data: payload,
            chainID: this.netConfig.ChainID,
            version: this.relayedTransactionVersion,
            options: this.relayedTransactionOptions,
            guardian: this.relayedTransactionGuardian,
        });
        if (this.relayerNonce) {
            relayedTransaction.setNonce(this.relayerNonce);
        }
        return relayedTransaction;
    }
    prepareInnerTransaction() {
        if (!this.innerTransaction) {
            return "";
        }
        const txObject = {
            nonce: this.innerTransaction.getNonce().valueOf(),
            sender: new address_1.Address(this.innerTransaction.getSender().bech32()).pubkey().toString("base64"),
            receiver: new address_1.Address(this.innerTransaction.getReceiver().bech32()).pubkey().toString("base64"),
            value: BigInt(this.innerTransaction.getValue().toString()),
            gasPrice: this.innerTransaction.getGasPrice().valueOf(),
            gasLimit: this.innerTransaction.getGasLimit().valueOf(),
            data: this.innerTransaction.getData().valueOf().toString("base64"),
            signature: this.innerTransaction.getSignature().toString("base64"),
            chainID: Buffer.from(this.innerTransaction.getChainID().valueOf()).toString("base64"),
            version: this.innerTransaction.getVersion().valueOf(),
            options: this.innerTransaction.getOptions().valueOf() == 0
                ? undefined
                : this.innerTransaction.getOptions().valueOf(),
            guardian: this.innerTransaction.getGuardian().bech32()
                ? new address_1.Address(this.innerTransaction.getGuardian().bech32()).pubkey().toString("base64")
                : undefined,
            guardianSignature: this.innerTransaction.getGuardianSignature().toString("hex")
                ? this.innerTransaction.getGuardianSignature().toString("base64")
                : undefined,
            sndUserName: this.innerTransaction.getSenderUsername()
                ? Buffer.from(this.innerTransaction.getSenderUsername()).toString("base64")
                : undefined,
            rcvUserName: this.innerTransaction.getReceiverUsername()
                ? Buffer.from(this.innerTransaction.getReceiverUsername()).toString("base64")
                : undefined,
        };
        return JSONbig.stringify(txObject);
    }
}
exports.RelayedTransactionV1Builder = RelayedTransactionV1Builder;
//# sourceMappingURL=relayedTransactionV1Builder.js.map