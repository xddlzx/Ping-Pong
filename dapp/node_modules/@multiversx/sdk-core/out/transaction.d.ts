/// <reference types="node" />
import { BigNumber } from "bignumber.js";
import { Address } from "./address";
import { Hash } from "./hash";
import { IAddress, IChainID, IGasLimit, IGasPrice, INonce, IPlainTransactionObject, ISignature, ITransactionOptions, ITransactionPayload, ITransactionValue, ITransactionVersion } from "./interface";
import { INetworkConfig } from "./interfaceOfNetwork";
import { TransactionOptions, TransactionVersion } from "./networkParams";
/**
 * An abstraction for creating and signing transactions.
 */
export declare class Transaction {
    /**
     * The nonce of the transaction (the account sequence number of the sender).
     */
    nonce: bigint;
    /**
     * The value to transfer.
     */
    value: bigint;
    /**
     * The address of the sender, in bech32 format.
     */
    sender: string;
    /**
     * The address of the receiver, in bech32 format.
     */
    receiver: string;
    /**
     * The username of the sender.
     */
    senderUsername: string;
    /**
     * The username of the receiver.
     */
    receiverUsername: string;
    /**
     * The gas price to be used.
     */
    gasPrice: bigint;
    /**
     * The maximum amount of gas to be consumed when processing the transaction.
     */
    gasLimit: bigint;
    /**
     * The payload of the transaction.
     */
    data: Uint8Array;
    /**
     * The chain ID of the Network (e.g. "1" for Mainnet).
     */
    chainID: string;
    /**
     * The version, required by the Network in order to correctly interpret the contents of the transaction.
     */
    version: number;
    /**
     * The options field, useful for describing different settings available for transactions.
     */
    options: number;
    /**
     * The address of the guardian, in bech32 format.
     */
    guardian: string;
    /**
     * The relayer address.
     *  Note: in the next major version, `sender`, `receiver` and `guardian` will also have the type `Address`, instead of `string`.
     */
    relayer: Address;
    /**
     * The signature.
     */
    signature: Uint8Array;
    /**
     * The signature of the guardian.
     */
    guardianSignature: Uint8Array;
    /**
     * The signature of the relayer.
     */
    relayerSignature: Uint8Array;
    /**
     * Creates a new Transaction object.
     */
    constructor(options: {
        nonce?: INonce | bigint;
        value?: ITransactionValue | bigint;
        sender: IAddress | string;
        receiver: IAddress | string;
        relayer?: Address;
        senderUsername?: string;
        receiverUsername?: string;
        gasPrice?: IGasPrice | bigint;
        gasLimit: IGasLimit | bigint;
        data?: ITransactionPayload | Uint8Array;
        chainID: IChainID | string;
        version?: ITransactionVersion | number;
        options?: ITransactionOptions | number;
        guardian?: IAddress | string;
        signature?: Uint8Array;
        guardianSignature?: Uint8Array;
        relayerSignature?: Uint8Array;
    });
    private addressAsBech32;
    /**
     * Legacy method, use the "nonce" property instead.
     */
    getNonce(): INonce;
    /**
     * Legacy method, use the "nonce" property instead.
     * Sets the account sequence number of the sender. Must be done prior signing.
     */
    setNonce(nonce: INonce | bigint): void;
    /**
     * Legacy method, use the "value" property instead.
     */
    getValue(): ITransactionValue;
    /**
     * Legacy method, use the "value" property instead.
     */
    setValue(value: ITransactionValue | bigint): void;
    /**
     * Legacy method, use the "sender" property instead.
     */
    getSender(): IAddress;
    /**
     * Legacy method, use the "sender" property instead.
     */
    setSender(sender: IAddress | string): void;
    /**
     * Legacy method, use the "receiver" property instead.
     */
    getReceiver(): IAddress;
    /**
     * Legacy method, use the "senderUsername" property instead.
     */
    getSenderUsername(): string;
    /**
     * Legacy method, use the "senderUsername" property instead.
     */
    setSenderUsername(senderUsername: string): void;
    /**
     * Legacy method, use the "receiverUsername" property instead.
     */
    getReceiverUsername(): string;
    /**
     * Legacy method, use the "receiverUsername" property instead.
     */
    setReceiverUsername(receiverUsername: string): void;
    /**
     * Legacy method, use the "guardian" property instead.
     */
    getGuardian(): IAddress;
    /**
     * Legacy method, use the "gasPrice" property instead.
     */
    getGasPrice(): IGasPrice;
    /**
     * Legacy method, use the "gasPrice" property instead.
     */
    setGasPrice(gasPrice: IGasPrice | bigint): void;
    /**
     * Legacy method, use the "gasLimit" property instead.
     */
    getGasLimit(): IGasLimit;
    /**
     * Legacy method, use the "gasLimit" property instead.
     */
    setGasLimit(gasLimit: IGasLimit | bigint): void;
    /**
     * Legacy method, use the "data" property instead.
     */
    getData(): ITransactionPayload;
    /**
     * Legacy method, use the "chainID" property instead.
     */
    getChainID(): IChainID;
    /**
     * Legacy method, use the "chainID" property instead.
     */
    setChainID(chainID: IChainID | string): void;
    /**
     * Legacy method, use the "version" property instead.
     */
    getVersion(): TransactionVersion;
    /**
     * Legacy method, use the "version" property instead.
     */
    setVersion(version: ITransactionVersion | number): void;
    /**
     * Legacy method, use the "options" property instead.
     */
    getOptions(): TransactionOptions;
    /**
     * Legacy method, use the "options" property instead.
     *
     * Question for review: check how the options are set by sdk-dapp, wallet, ledger, extension.
     */
    setOptions(options: ITransactionOptions | number): void;
    /**
     * Legacy method, use the "signature" property instead.
     */
    getSignature(): Buffer;
    /**
     * Legacy method, use the "guardianSignature" property instead.
     */
    getGuardianSignature(): Buffer;
    /**
     * Legacy method, use the "guardian" property instead.
     */
    setGuardian(guardian: IAddress | string): void;
    /**
     * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
     */
    getHash(): TransactionHash;
    /**
     * Legacy method, use "TransactionComputer.computeBytesForSigning()" instead.
     * Serializes a transaction to a sequence of bytes, ready to be signed.
     * This function is called internally by signers.
     */
    serializeForSigning(): Buffer;
    /**
     * Checks the integrity of the guarded transaction
     */
    isGuardedTransaction(): boolean;
    /**
     * Legacy method, use "TransactionsConverter.transactionToPlainObject()" instead.
     *
     * Converts the transaction object into a ready-to-serialize, plain JavaScript object.
     * This function is called internally within the signing procedure.
     */
    toPlainObject(): IPlainTransactionObject;
    /**
     * Legacy method, use "TransactionsConverter.plainObjectToTransaction()" instead.
     * Converts a plain object transaction into a Transaction Object.
     *
     * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()
     */
    static fromPlainObject(plainObjectTransaction: IPlainTransactionObject): Transaction;
    /**
     * Legacy method, use the "signature" property instead.
     * Applies the signature on the transaction.
     *
     * @param signature The signature, as computed by a signer.
     */
    applySignature(signature: ISignature | Uint8Array): void;
    /**
     * Legacy method, use the "guardianSignature" property instead.
     * Applies the guardian signature on the transaction.
     *
     * @param guardianSignature The signature, as computed by a signer.
     */
    applyGuardianSignature(guardianSignature: ISignature | Uint8Array): void;
    /**
     * Converts a transaction to a ready-to-broadcast object.
     * Called internally by the network provider.
     */
    toSendable(): any;
    /**
     * Legacy method, use "TransactionComputer.computeTransactionFee()" instead.
     *
     * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties
     * @param networkConfig {@link NetworkConfig}
     */
    computeFee(networkConfig: INetworkConfig): BigNumber;
}
/**
 * Legacy class, use "TransactionComputer.computeTransactionHash()" instead.
 * An abstraction for handling and computing transaction hashes.
 */
export declare class TransactionHash extends Hash {
    constructor(hash: string);
    /**
     * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
     * Computes the hash of a transaction.
     */
    static compute(transaction: Transaction): TransactionHash;
}
