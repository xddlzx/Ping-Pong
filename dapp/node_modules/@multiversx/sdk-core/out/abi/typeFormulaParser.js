"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeFormulaParser = void 0;
const typeFormula_1 = require("./typeFormula");
class TypeFormulaParser {
    parseExpression(expression) {
        expression = expression.trim();
        const tokens = this.tokenizeExpression(expression).filter((token) => token !== TypeFormulaParser.COMMA);
        const stack = [];
        for (const token of tokens) {
            if (this.isPunctuation(token)) {
                if (this.isEndOfTypeParameters(token)) {
                    const typeFormula = this.acquireTypeWithParameters(stack);
                    stack.push(typeFormula);
                }
                else if (this.isBeginningOfTypeParameters(token)) {
                    // This symbol is pushed as a simple string.
                    stack.push(token);
                }
                else {
                    throw new Error(`Unexpected token (punctuation): ${token}`);
                }
            }
            else {
                // It's a type name. We push it as a simple string.
                stack.push(token);
            }
        }
        if (stack.length !== 1) {
            throw new Error(`Unexpected stack length at end of parsing: ${stack.length}`);
        }
        if (TypeFormulaParser.PUNCTUATION.includes(stack[0])) {
            throw new Error("Unexpected root element.");
        }
        const item = stack[0];
        if (item instanceof typeFormula_1.TypeFormula) {
            return item;
        }
        else if (typeof item === "string") {
            // Expression contained a simple, non-generic type.
            return new typeFormula_1.TypeFormula(item, []);
        }
        else {
            throw new Error(`Unexpected item on stack: ${item}`);
        }
    }
    tokenizeExpression(expression) {
        const tokens = [];
        let currentToken = "";
        for (const character of expression) {
            if (this.isPunctuation(character)) {
                if (currentToken) {
                    // Retain current token
                    tokens.push(currentToken.trim());
                    // Reset current token
                    currentToken = "";
                }
                // Punctuation character
                tokens.push(character);
            }
            else {
                currentToken += character;
            }
        }
        if (currentToken) {
            // Retain the last token (if any).
            tokens.push(currentToken.trim());
        }
        return tokens;
    }
    acquireTypeWithParameters(stack) {
        const typeParameters = this.acquireTypeParameters(stack);
        const typeName = stack.pop();
        if (typeName === "ManagedDecimal" || typeName === "ManagedDecimalSigned") {
            const metadata = typeParameters[0].name;
            const typeFormula = new typeFormula_1.TypeFormula(typeName, [], metadata);
            return typeFormula;
        }
        const typeFormula = new typeFormula_1.TypeFormula(typeName, typeParameters.reverse());
        return typeFormula;
    }
    acquireTypeParameters(stack) {
        const typeParameters = [];
        while (true) {
            const item = stack.pop();
            if (item === undefined) {
                throw new Error("Badly specified type parameters");
            }
            if (this.isBeginningOfTypeParameters(item)) {
                // We've acquired all type parameters.
                break;
            }
            if (item instanceof typeFormula_1.TypeFormula) {
                // Type parameter is a previously-acquired type.
                typeParameters.push(item);
            }
            else if (typeof item === "string") {
                // Type parameter is a simple, non-generic type.
                typeParameters.push(new typeFormula_1.TypeFormula(item, []));
            }
            else {
                throw new Error(`Unexpected type parameter object in stack: ${item}`);
            }
        }
        return typeParameters;
    }
    isPunctuation(token) {
        return TypeFormulaParser.PUNCTUATION.includes(token);
    }
    isEndOfTypeParameters(token) {
        return token === TypeFormulaParser.END_TYPE_PARAMETERS;
    }
    isBeginningOfTypeParameters(token) {
        return token === TypeFormulaParser.BEGIN_TYPE_PARAMETERS;
    }
}
exports.TypeFormulaParser = TypeFormulaParser;
TypeFormulaParser.BEGIN_TYPE_PARAMETERS = "<";
TypeFormulaParser.END_TYPE_PARAMETERS = ">";
TypeFormulaParser.COMMA = ",";
TypeFormulaParser.PUNCTUATION = [
    TypeFormulaParser.COMMA,
    TypeFormulaParser.BEGIN_TYPE_PARAMETERS,
    TypeFormulaParser.END_TYPE_PARAMETERS,
];
//# sourceMappingURL=typeFormulaParser.js.map