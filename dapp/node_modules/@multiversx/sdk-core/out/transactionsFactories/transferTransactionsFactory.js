"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferTransactionsFactory = void 0;
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const smartcontracts_1 = require("../smartcontracts");
const tokens_1 = require("../tokens");
const transaction_1 = require("../transaction");
const transactionPayload_1 = require("../transactionPayload");
const tokenTransfersDataBuilder_1 = require("./tokenTransfersDataBuilder");
const transactionBuilder_1 = require("./transactionBuilder");
const ADDITIONAL_GAS_FOR_ESDT_TRANSFER = 100000;
const ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER = 800000;
/**
 * Use this class to create transactions for native token transfers (EGLD) or custom tokens transfers (ESDT/NTF/MetaESDT).
 */
class TransferTransactionsFactory {
    /**
     * Should be instantiated using `Config`.
     * Instantiating this class using GasEstimator represents the legacy version of this class.
     * The legacy version contains methods like `createEGLDTransfer`, `createESDTTransfer`, `createESDTNFTTransfer` and `createMultiESDTNFTTransfer`.
     * This was done in order to minimize breaking changes in client code.
     */
    constructor(options) {
        if (this.isGasEstimator(options)) {
            this.gasEstimator = options;
        }
        else {
            this.config = options.config;
            this.tokenComputer = new tokens_1.TokenComputer();
            this.tokenTransfersDataBuilder = new tokenTransfersDataBuilder_1.TokenTransfersDataBuilder();
        }
    }
    isGasEstimator(options) {
        return (typeof options === "object" &&
            typeof options.forEGLDTransfer === "function" &&
            typeof options.forESDTTransfer === "function" &&
            typeof options.forESDTNFTTransfer === "function" &&
            typeof options.forMultiESDTNFTTransfer === "function");
    }
    isGasEstimatorDefined() {
        return this.gasEstimator !== undefined;
    }
    ensureConfigIsDefined() {
        if (this.config === undefined) {
            throw new errors_1.Err("'config' is not defined");
        }
    }
    createTransactionForNativeTokenTransfer(options) {
        this.ensureConfigIsDefined();
        const data = options.data || new Uint8Array();
        return new transaction_1.Transaction({
            sender: options.sender.bech32(),
            receiver: options.receiver.bech32(),
            chainID: this.config.chainID,
            gasLimit: this.computeGasForMoveBalance(this.config, data),
            data: data,
            value: options.nativeAmount,
        });
    }
    createTransactionForESDTTokenTransfer(options) {
        this.ensureConfigIsDefined();
        const numberOfTransfers = options.tokenTransfers.length;
        if (numberOfTransfers === 0) {
            throw new errors_1.ErrBadUsage("No token transfer has been provided");
        }
        if (numberOfTransfers === 1) {
            return this.createSingleESDTTransferTransaction(options);
        }
        const { dataParts, extraGasForTransfer } = this.buildMultiESDTNFTTransferData(options.tokenTransfers, options.receiver);
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: options.sender,
            receiver: options.sender,
            dataParts: dataParts,
            gasLimit: extraGasForTransfer,
            addDataMovementGas: true,
        }).build();
    }
    createTransactionForTransfer(options) {
        const nativeAmount = options.nativeAmount ?? 0n;
        let tokenTransfers = options.tokenTransfers ? [...options.tokenTransfers] : [];
        const numberOfTokens = tokenTransfers.length;
        if (numberOfTokens && options.data?.length) {
            throw new errors_1.ErrBadUsage("Can't set data field when sending esdt tokens");
        }
        if ((nativeAmount && numberOfTokens === 0) || options.data) {
            return this.createTransactionForNativeTokenTransfer({
                sender: options.sender,
                receiver: options.receiver,
                nativeAmount: nativeAmount,
                data: options.data,
            });
        }
        const nativeTransfer = nativeAmount ? tokens_1.TokenTransfer.newFromEgldAmount(nativeAmount) : undefined;
        if (nativeTransfer) {
            tokenTransfers.push(nativeTransfer);
        }
        return this.createTransactionForESDTTokenTransfer({
            sender: options.sender,
            receiver: options.receiver,
            tokenTransfers: tokenTransfers,
        });
    }
    /**
     * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
     * Use {@link createTransactionForNativeTokenTransfer} instead.
     */
    createEGLDTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
            throw new errors_1.Err("You are calling a legacy function to create an EGLD transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForNativeTokenTransfer` method.");
        }
        const dataLength = args.data?.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forEGLDTransfer(dataLength);
        return new transaction_1.Transaction({
            nonce: args.nonce,
            value: args.value,
            receiver: args.receiver,
            sender: args.sender,
            gasPrice: args.gasPrice,
            gasLimit: args.gasLimit || estimatedGasLimit,
            data: args.data,
            chainID: args.chainID,
        });
    }
    /**
     * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
     * Use {@link createTransactionForESDTTokenTransfer} instead.
     */
    createESDTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
            throw new errors_1.Err("You are calling a legacy function to create an ESDT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
            // The token identifier
            smartcontracts_1.BytesValue.fromUTF8(args.tokenTransfer.tokenIdentifier),
            // The transfered amount
            new smartcontracts_1.BigUIntValue(args.tokenTransfer.valueOf()),
        ]);
        const data = `ESDTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forESDTTransfer(dataLength);
        return new transaction_1.Transaction({
            nonce: args.nonce,
            receiver: args.receiver,
            sender: args.sender,
            gasPrice: args.gasPrice,
            gasLimit: args.gasLimit || estimatedGasLimit,
            data: transactionPayload,
            chainID: args.chainID,
        });
    }
    /**
     * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
     * Use {@link createTransactionForESDTTokenTransfer} instead.
     */
    createESDTNFTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
            throw new errors_1.Err("You are calling a legacy function to create an ESDTNFT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
            // The token identifier
            smartcontracts_1.BytesValue.fromUTF8(args.tokenTransfer.tokenIdentifier),
            // The nonce of the token
            new smartcontracts_1.U64Value(args.tokenTransfer.nonce),
            // The transferred quantity
            new smartcontracts_1.BigUIntValue(args.tokenTransfer.valueOf()),
            // The destination address
            new smartcontracts_1.AddressValue(args.destination),
        ]);
        const data = `ESDTNFTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forESDTNFTTransfer(dataLength);
        return new transaction_1.Transaction({
            nonce: args.nonce,
            receiver: args.sender,
            sender: args.sender,
            gasPrice: args.gasPrice,
            gasLimit: args.gasLimit || estimatedGasLimit,
            data: transactionPayload,
            chainID: args.chainID,
        });
    }
    /**
     * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
     * Use {@link createTransactionForESDTTokenTransfer} instead.
     */
    createMultiESDTNFTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
            throw new errors_1.Err("You are calling a legacy function to create a MultiESDTNFT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const parts = [
            // The destination address
            new smartcontracts_1.AddressValue(args.destination),
            // Number of tokens
            new smartcontracts_1.U16Value(args.tokenTransfers.length),
        ];
        for (const payment of args.tokenTransfers) {
            parts.push(...[
                // The token identifier
                smartcontracts_1.BytesValue.fromUTF8(payment.tokenIdentifier),
                // The nonce of the token
                new smartcontracts_1.U64Value(payment.nonce),
                // The transfered quantity
                new smartcontracts_1.BigUIntValue(payment.valueOf()),
            ]);
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString(parts);
        const data = `MultiESDTNFTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forMultiESDTNFTTransfer(dataLength, args.tokenTransfers.length);
        return new transaction_1.Transaction({
            nonce: args.nonce,
            receiver: args.sender,
            sender: args.sender,
            gasPrice: args.gasPrice,
            gasLimit: args.gasLimit || estimatedGasLimit,
            data: transactionPayload,
            chainID: args.chainID,
        });
    }
    createSingleESDTTransferTransaction(options) {
        this.ensureConfigIsDefined();
        const transfer = options.tokenTransfers[0];
        const { dataParts, extraGasForTransfer, receiver } = this.buildTransferData(transfer, options);
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: options.sender,
            receiver: receiver,
            dataParts: dataParts,
            gasLimit: extraGasForTransfer,
            addDataMovementGas: true,
        }).build();
    }
    buildTransferData(transfer, options) {
        let dataParts = [];
        let extraGasForTransfer;
        let receiver = options.receiver;
        if (this.tokenComputer.isFungible(transfer.token)) {
            if (transfer.token.identifier === constants_1.EGLD_IDENTIFIER_FOR_MULTI_ESDTNFT_TRANSFER) {
                ({ dataParts, extraGasForTransfer } = this.buildMultiESDTNFTTransferData([transfer], receiver));
                receiver = options.sender;
            }
            else {
                ({ dataParts, extraGasForTransfer } = this.buildESDTTransferData(transfer));
            }
        }
        else {
            ({ dataParts, extraGasForTransfer } = this.buildSingleESDTNFTTransferData(transfer, receiver));
            receiver = options.sender; // Override receiver for non-fungible tokens
        }
        return { dataParts, extraGasForTransfer, receiver };
    }
    buildMultiESDTNFTTransferData(transfer, receiver) {
        return {
            dataParts: this.tokenTransfersDataBuilder.buildDataPartsForMultiESDTNFTTransfer(receiver, transfer),
            extraGasForTransfer: this.config.gasLimitMultiESDTNFTTransfer * BigInt(transfer.length) +
                BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER),
        };
    }
    buildESDTTransferData(transfer) {
        return {
            dataParts: this.tokenTransfersDataBuilder.buildDataPartsForESDTTransfer(transfer),
            extraGasForTransfer: this.config.gasLimitESDTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_TRANSFER),
        };
    }
    buildSingleESDTNFTTransferData(transfer, receiver) {
        return {
            dataParts: this.tokenTransfersDataBuilder.buildDataPartsForSingleESDTNFTTransfer(transfer, receiver),
            extraGasForTransfer: this.config.gasLimitESDTNFTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER),
        };
    }
    computeGasForMoveBalance(config, data) {
        return config.minGasLimit + config.gasLimitPerByte * BigInt(data.length);
    }
}
exports.TransferTransactionsFactory = TransferTransactionsFactory;
//# sourceMappingURL=transferTransactionsFactory.js.map