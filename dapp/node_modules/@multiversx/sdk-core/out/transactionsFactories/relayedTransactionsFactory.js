"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelayedTransactionsFactory = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const address_1 = require("../address");
const errors_1 = require("../errors");
const smartcontracts_1 = require("../smartcontracts");
const transaction_1 = require("../transaction");
const JSONbig = require("json-bigint");
/**
 * Use this class to create both RelayedV1 and RelayedV2 transactions.
 */
class RelayedTransactionsFactory {
    constructor(options) {
        this.config = options.config;
    }
    createRelayedV1Transaction(options) {
        if (!options.innerTransaction.gasLimit) {
            throw new errors_1.ErrInvalidInnerTransaction("The gas limit is not set for the inner transaction");
        }
        if (!options.innerTransaction.signature.length) {
            throw new errors_1.ErrInvalidInnerTransaction("The inner transaction is not signed");
        }
        const serializedTransaction = this.prepareInnerTransactionForRelayedV1(options.innerTransaction);
        const data = `relayedTx@${Buffer.from(serializedTransaction).toString("hex")}`;
        const additionalGasForDataLength = this.config.gasLimitPerByte * BigInt(data.length);
        const gasLimit = this.config.minGasLimit + additionalGasForDataLength + options.innerTransaction.gasLimit;
        return new transaction_1.Transaction({
            chainID: this.config.chainID,
            sender: options.relayerAddress.bech32(),
            receiver: options.innerTransaction.sender,
            gasLimit: gasLimit,
            data: Buffer.from(data),
        });
    }
    createRelayedV2Transaction(options) {
        if (options.innerTransaction.gasLimit) {
            throw new errors_1.ErrInvalidInnerTransaction("The gas limit should not be set for the inner transaction");
        }
        if (!options.innerTransaction.signature.length) {
            throw new errors_1.ErrInvalidInnerTransaction("The inner transaction is not signed");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
            new smartcontracts_1.AddressValue(address_1.Address.fromBech32(options.innerTransaction.receiver)),
            new smartcontracts_1.U64Value(new bignumber_js_1.default(options.innerTransaction.nonce.toString())),
            new smartcontracts_1.BytesValue(Buffer.from(options.innerTransaction.data)),
            new smartcontracts_1.BytesValue(Buffer.from(options.innerTransaction.signature)),
        ]);
        const data = `relayedTxV2@${argumentsString}`;
        const additionalGasForDataLength = this.config.gasLimitPerByte * BigInt(data.length);
        const gasLimit = options.innerTransactionGasLimit + this.config.minGasLimit + additionalGasForDataLength;
        return new transaction_1.Transaction({
            sender: options.relayerAddress.bech32(),
            receiver: options.innerTransaction.sender,
            value: 0n,
            gasLimit: gasLimit,
            chainID: this.config.chainID,
            data: Buffer.from(data),
            version: options.innerTransaction.version,
            options: options.innerTransaction.options,
        });
    }
    prepareInnerTransactionForRelayedV1(innerTransaction) {
        const txObject = {
            nonce: innerTransaction.nonce,
            sender: address_1.Address.newFromBech32(innerTransaction.sender).getPublicKey().toString("base64"),
            receiver: address_1.Address.newFromBech32(innerTransaction.receiver).getPublicKey().toString("base64"),
            value: innerTransaction.value,
            gasPrice: innerTransaction.gasPrice,
            gasLimit: innerTransaction.gasLimit,
            data: Buffer.from(innerTransaction.data).toString("base64"),
            signature: Buffer.from(innerTransaction.signature).toString("base64"),
            chainID: Buffer.from(innerTransaction.chainID).toString("base64"),
            version: innerTransaction.version,
            options: innerTransaction.options.valueOf() == 0 ? undefined : innerTransaction.options,
            guardian: innerTransaction.guardian
                ? address_1.Address.newFromBech32(innerTransaction.guardian).getPublicKey().toString("base64")
                : undefined,
            guardianSignature: innerTransaction.guardianSignature.length
                ? Buffer.from(innerTransaction.guardianSignature).toString("base64")
                : undefined,
            sndUserName: innerTransaction.senderUsername
                ? Buffer.from(innerTransaction.senderUsername).toString("base64")
                : undefined,
            rcvUserName: innerTransaction.receiverUsername
                ? Buffer.from(innerTransaction.receiverUsername).toString("base64")
                : undefined,
        };
        return JSONbig.stringify(txObject);
    }
}
exports.RelayedTransactionsFactory = RelayedTransactionsFactory;
//# sourceMappingURL=relayedTransactionsFactory.js.map