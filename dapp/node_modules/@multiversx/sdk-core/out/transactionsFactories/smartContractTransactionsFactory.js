"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContractTransactionsFactory = void 0;
const address_1 = require("../address");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const logger_1 = require("../logger");
const smartcontracts_1 = require("../smartcontracts");
const nativeSerializer_1 = require("../smartcontracts/nativeSerializer");
const typesystem_1 = require("../smartcontracts/typesystem");
const tokens_1 = require("../tokens");
const utils_codec_1 = require("../utils.codec");
const tokenTransfersDataBuilder_1 = require("./tokenTransfersDataBuilder");
const transactionBuilder_1 = require("./transactionBuilder");
/**
 * Use this class to create transactions to deploy, call or upgrade a smart contract.
 */
class SmartContractTransactionsFactory {
    constructor(options) {
        this.config = options.config;
        this.abi = options.abi;
        this.tokenComputer = new tokens_1.TokenComputer();
        this.dataArgsBuilder = new tokenTransfersDataBuilder_1.TokenTransfersDataBuilder();
        this.contractDeployAddress = address_1.Address.fromHex(constants_1.CONTRACT_DEPLOY_ADDRESS_HEX, this.config.addressHrp);
    }
    createTransactionForDeploy(options) {
        const nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        const isUpgradeable = options.isUpgradeable ?? true;
        const isReadable = options.isReadable ?? true;
        const isPayable = options.isPayable ?? false;
        const isPayableBySmartContract = options.isPayableBySmartContract ?? true;
        const args = options.arguments || [];
        const metadata = new smartcontracts_1.CodeMetadata(isUpgradeable, isReadable, isPayable, isPayableBySmartContract);
        const dataParts = [utils_codec_1.byteArrayToHex(options.bytecode), utils_codec_1.byteArrayToHex(constants_1.VM_TYPE_WASM_VM), metadata.toString()];
        const endpoint = this.abi?.constructorDefinition;
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: options.sender,
            receiver: this.contractDeployAddress,
            dataParts: dataParts,
            gasLimit: options.gasLimit,
            addDataMovementGas: false,
            amount: nativeTransferAmount,
        }).build();
    }
    createTransactionForExecute(options) {
        const args = options.arguments || [];
        let tokenTransfers = options.tokenTransfers ? [...options.tokenTransfers] : [];
        let nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        let numberOfTokens = tokenTransfers.length;
        if (nativeTransferAmount && numberOfTokens) {
            tokenTransfers.push(tokens_1.TokenTransfer.newFromEgldAmount(nativeTransferAmount));
            nativeTransferAmount = 0n;
            numberOfTokens++;
        }
        let receiver = options.contract;
        let dataParts = [];
        if (numberOfTokens === 1) {
            const transfer = tokenTransfers[0];
            if (this.tokenComputer.isFungible(transfer.token)) {
                dataParts = this.dataArgsBuilder.buildDataPartsForESDTTransfer(transfer);
            }
            else {
                dataParts = this.dataArgsBuilder.buildDataPartsForSingleESDTNFTTransfer(transfer, receiver);
                receiver = options.sender;
            }
        }
        else if (numberOfTokens > 1) {
            dataParts = this.dataArgsBuilder.buildDataPartsForMultiESDTNFTTransfer(receiver, tokenTransfers);
            receiver = options.sender;
        }
        dataParts.push(dataParts.length ? utils_codec_1.utf8ToHex(options.function) : options.function);
        const endpoint = this.abi?.getEndpoint(options.function);
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: options.sender,
            receiver: receiver,
            dataParts: dataParts,
            gasLimit: options.gasLimit,
            addDataMovementGas: false,
            amount: nativeTransferAmount,
        }).build();
    }
    createTransactionForUpgrade(options) {
        const nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        const isUpgradeable = options.isUpgradeable ?? true;
        const isReadable = options.isReadable ?? true;
        const isPayable = options.isPayable ?? false;
        const isPayableBySmartContract = options.isPayableBySmartContract ?? true;
        const args = options.arguments || [];
        const metadata = new smartcontracts_1.CodeMetadata(isUpgradeable, isReadable, isPayable, isPayableBySmartContract);
        const dataParts = ["upgradeContract", utils_codec_1.byteArrayToHex(options.bytecode), metadata.toString()];
        const endpoint = this.getEndpointForUpgrade();
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: options.sender,
            receiver: options.contract,
            dataParts: dataParts,
            gasLimit: options.gasLimit,
            addDataMovementGas: false,
            amount: nativeTransferAmount,
        }).build();
    }
    getEndpointForUpgrade() {
        if (!this.abi) {
            return undefined;
        }
        if (this.abi.upgradeConstructorDefinition) {
            return this.abi.upgradeConstructorDefinition;
        }
        try {
            return this.abi.getEndpoint("upgrade");
        }
        catch (error) {
            // Contracts written using an old Rust framework and deployed prior Sirius might not describe the 'upgrade' endpoint in the ABI.
            logger_1.Logger.warn("In the ABI, cannot find the 'upgrade' endpoint definition. Will use the constructor definition (fallback).");
            return this.abi.constructorDefinition;
        }
    }
    createTransactionForClaimingDeveloperRewards(options) {
        const dataParts = ["ClaimDeveloperRewards"];
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: options.sender,
            receiver: options.contract,
            dataParts: dataParts,
            gasLimit: this.config.gasLimitClaimDeveloperRewards,
            addDataMovementGas: false,
        }).build();
    }
    createTransactionForChangingOwnerAddress(options) {
        const dataParts = ["ChangeOwnerAddress", address_1.Address.fromBech32(options.newOwner.bech32()).toHex()];
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: options.sender,
            receiver: options.contract,
            dataParts: dataParts,
            gasLimit: this.config.gasLimitChangeOwnerAddress,
            addDataMovementGas: false,
        }).build();
    }
    argsToDataParts(args, endpoint) {
        if (endpoint) {
            const typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args, endpoint);
            return new smartcontracts_1.ArgSerializer().valuesToStrings(typedArgs);
        }
        if (this.areArgsOfTypedValue(args)) {
            return new smartcontracts_1.ArgSerializer().valuesToStrings(args);
        }
        throw new errors_1.Err("Can't convert args to TypedValues");
    }
    areArgsOfTypedValue(args) {
        return args.every((arg) => typesystem_1.isTyped(arg));
    }
}
exports.SmartContractTransactionsFactory = SmartContractTransactionsFactory;
//# sourceMappingURL=smartContractTransactionsFactory.js.map