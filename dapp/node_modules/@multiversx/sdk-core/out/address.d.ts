/// <reference types="node" />
interface IAddress {
    getPublicKey(): Buffer;
    getHrp(): string;
}
/**
 * An Address, as an immutable object.
 */
export declare class Address {
    private readonly publicKey;
    private readonly hrp;
    /**
     * Creates an address object, given a raw string (whether a hex pubkey or a Bech32 address), a sequence of bytes, or another Address object.
     */
    constructor(value: Address | Uint8Array | string, hrp?: string);
    /**
     * Creates an address object from a bech32-encoded string
     */
    static newFromBech32(value: string): Address;
    /**
     * Use {@link newFromBech32} instead.
     */
    static fromBech32(value: string): Address;
    /**
     * Creates an address object from a hex-encoded string
     */
    static newFromHex(value: string, hrp?: string): Address;
    /**
     * Use {@link newFromHex} instead.
     */
    static fromHex(value: string, hrp?: string): Address;
    /**
     * @deprecated Constructing an address object from another object is deprecated.
     */
    static fromAddress(address: Address): Address;
    /**
     * @deprecated Use the constructor, instead.
     */
    static fromBuffer(buffer: Buffer, hrp?: string): Address;
    /**
     * @deprecated Use {@link newFromBech32} or {@link newFromHex}.
     */
    static fromString(value: string, hrp?: string): Address;
    private static isValidHex;
    /**
     * Creates an empty address object.
     * Generally speaking, this should not be used by client code (internal use only).
     */
    static empty(): Address;
    /**
     * Performs address validation without throwing errors
     */
    static isValid(value: string): boolean;
    /**
     * Use {@link toHex} instead.
     */
    hex(): string;
    /**
     * Returns the hex representation of the address (pubkey)
     */
    toHex(): string;
    /**
     * Use {@link toBech32} instead.
     */
    bech32(): string;
    /**
     * Returns the bech32 representation of the address
     */
    toBech32(): string;
    /**
     * Use {@link getPublicKey} instead.
     */
    pubkey(): Buffer;
    /**
     * Returns the pubkey as raw bytes (buffer)
     */
    getPublicKey(): Buffer;
    /**
     * Returns the human-readable-part of the bech32 addresses.
     */
    getHrp(): string;
    /**
     * Returns whether the address is empty.
     */
    isEmpty(): boolean;
    /**
     * Compares the address to another address
     */
    equals(other: Address | null): boolean;
    /**
     * Returns the bech32 representation of the address
     */
    toString(): string;
    /**
     * Converts the address to a pretty, plain JavaScript object.
     */
    toJSON(): object;
    /**
     * Creates the Zero address (the one that should be used when deploying smart contracts).
     * Generally speaking, this should not be used by client code (internal use only).
     */
    static Zero(): Address;
    /**
     * Use {@link isSmartContract} instead.
     */
    isContractAddress(): boolean;
    /**
     * Returns whether the address is a smart contract address.
     */
    isSmartContract(): boolean;
}
export declare class AddressComputer {
    private readonly numberOfShardsWithoutMeta;
    constructor(numberOfShardsWithoutMeta?: number);
    computeContractAddress(deployer: IAddress, deploymentNonce: bigint): Address;
    getShardOfAddress(address: IAddress): number;
    private getShardOfPubkey;
    private isPubkeyOfMetachain;
}
export {};
