"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContract = void 0;
const address_1 = require("../address");
const compatibility_1 = require("../compatibility");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const smartContractTransactionsFactory_1 = require("../transactionsFactories/smartContractTransactionsFactory");
const transactionsFactoryConfig_1 = require("../transactionsFactories/transactionsFactoryConfig");
const utils_1 = require("../utils");
const codeMetadata_1 = require("./codeMetadata");
const function_1 = require("./function");
const interaction_1 = require("./interaction");
const nativeSerializer_1 = require("./nativeSerializer");
const query_1 = require("./query");
/**
 * An abstraction for deploying and interacting with Smart Contracts.
 */
class SmartContract {
    /**
     * Create a SmartContract object by providing its address on the Network.
     */
    constructor(options = {}) {
        this.address = address_1.Address.empty();
        /**
         * This object contains a function for each endpoint defined by the contract.
         * (a bit similar to web3js's "contract.methods").
         */
        this.methodsExplicit = {};
        /**
         * This object contains a function for each endpoint defined by the contract.
         * (a bit similar to web3js's "contract.methods").
         *
         * This is an alternative to {@link methodsExplicit}.
         * Unlike {@link methodsExplicit}, automatic type inference (wrt. ABI) is applied when using {@link methods}.
         */
        this.methods = {};
        this.address = options.address || address_1.Address.empty();
        this.abi = options.abi;
        if (this.abi) {
            this.setupMethods();
        }
    }
    setupMethods() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let contract = this;
        let abi = this.getAbi();
        for (const definition of abi.getEndpoints()) {
            let functionName = definition.name;
            // For each endpoint defined by the ABI, we attach a function to the "methods" and "methodsAuto" objects,
            // a function that receives typed values as arguments
            // and returns a prepared contract interaction.
            this.methodsExplicit[functionName] = function (args) {
                let func = new function_1.ContractFunction(functionName);
                let interaction = new interaction_1.Interaction(contract, func, args || []);
                return interaction;
            };
            this.methods[functionName] = function (args) {
                let func = new function_1.ContractFunction(functionName);
                // Perform automatic type inference, wrt. the endpoint definition:
                let typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args || [], definition);
                let interaction = new interaction_1.Interaction(contract, func, typedArgs || []);
                return interaction;
            };
        }
    }
    /**
     * Sets the address, as on Network.
     */
    setAddress(address) {
        this.address = address;
    }
    /**
     * Gets the address, as on Network.
     */
    getAddress() {
        return this.address;
    }
    getAbi() {
        utils_1.guardValueIsSet("abi", this.abi);
        return this.abi;
    }
    getEndpoint(name) {
        return this.getAbi().getEndpoint(name);
    }
    /**
     * Creates a {@link Transaction} for deploying the Smart Contract to the Network.
     */
    deploy({ deployer, code, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID, }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(deployer, "'deployer' of SmartContract.deploy()", "pass the actual address to deploy()");
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
            config: config,
            abi: this.abi,
        });
        const bytecode = Buffer.from(code.toString(), "hex");
        const metadataAsJson = this.getMetadataPropertiesAsObject(codeMetadata);
        const transaction = factory.createTransactionForDeploy({
            sender: deployer,
            bytecode: bytecode,
            gasLimit: BigInt(gasLimit.valueOf()),
            arguments: initArguments,
            isUpgradeable: metadataAsJson.upgradeable,
            isReadable: metadataAsJson.readable,
            isPayable: metadataAsJson.payable,
            isPayableBySmartContract: metadataAsJson.payableBySc,
        });
        transaction.setChainID(chainID);
        transaction.setValue(value ?? 0);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
    }
    getMetadataPropertiesAsObject(codeMetadata) {
        let metadata;
        if (codeMetadata) {
            metadata = codeMetadata_1.CodeMetadata.fromBytes(Buffer.from(codeMetadata.toString(), "hex"));
        }
        else {
            metadata = new codeMetadata_1.CodeMetadata();
        }
        const metadataAsJson = metadata.toJSON();
        return metadataAsJson;
    }
    /**
     * Creates a {@link Transaction} for upgrading the Smart Contract on the Network.
     */
    upgrade({ caller, code, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID, }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(caller, "'caller' of SmartContract.upgrade()", "pass the actual address to upgrade()");
        this.ensureHasAddress();
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
            config: config,
            abi: this.abi,
        });
        const bytecode = Uint8Array.from(Buffer.from(code.toString(), "hex"));
        const metadataAsJson = this.getMetadataPropertiesAsObject(codeMetadata);
        const transaction = factory.createTransactionForUpgrade({
            sender: caller,
            contract: this.getAddress(),
            bytecode: bytecode,
            gasLimit: BigInt(gasLimit.valueOf()),
            arguments: initArguments,
            isUpgradeable: metadataAsJson.upgradeable,
            isReadable: metadataAsJson.readable,
            isPayable: metadataAsJson.payable,
            isPayableBySmartContract: metadataAsJson.payableBySc,
        });
        transaction.setChainID(chainID);
        transaction.setValue(value ?? 0);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
    }
    /**
     * Creates a {@link Transaction} for calling (a function of) the Smart Contract.
     */
    call({ func, args, value, gasLimit, receiver, gasPrice, chainID, caller }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(caller, "'caller' of SmartContract.call()", "pass the actual address to call()");
        this.ensureHasAddress();
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
            config: config,
            abi: this.abi,
        });
        args = args || [];
        value = value || 0;
        const transaction = factory.createTransactionForExecute({
            sender: caller,
            contract: receiver ? receiver : this.getAddress(),
            function: func.toString(),
            gasLimit: BigInt(gasLimit.valueOf()),
            arguments: args,
        });
        transaction.setChainID(chainID);
        transaction.setValue(value);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
    }
    createQuery({ func, args, value, caller }) {
        this.ensureHasAddress();
        return new query_1.Query({
            address: this.getAddress(),
            func: func,
            args: args,
            value: value,
            caller: caller,
        });
    }
    ensureHasAddress() {
        if (!this.getAddress().bech32()) {
            throw new errors_1.ErrContractHasNoAddress();
        }
    }
    /**
     * Computes the address of a Smart Contract.
     * The address is computed deterministically, from the address of the owner and the nonce of the deployment transaction.
     *
     * @param owner The owner of the Smart Contract
     * @param nonce The owner nonce used for the deployment transaction
     */
    static computeAddress(owner, nonce) {
        const deployer = address_1.Address.fromBech32(owner.bech32());
        const addressComputer = new address_1.AddressComputer();
        return addressComputer.computeContractAddress(deployer, BigInt(nonce.valueOf()));
    }
}
exports.SmartContract = SmartContract;
//# sourceMappingURL=smartContract.js.map