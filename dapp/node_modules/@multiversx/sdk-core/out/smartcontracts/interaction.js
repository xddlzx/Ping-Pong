"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interaction = void 0;
const address_1 = require("../address");
const compatibility_1 = require("../compatibility");
const constants_1 = require("../constants");
const tokens_1 = require("../tokens");
const transactionsFactories_1 = require("../transactionsFactories");
const interactionChecker_1 = require("./interactionChecker");
const query_1 = require("./query");
/**
 * Legacy component. Use "SmartContractTransactionsFactory" (for transactions) or "SmartContractQueriesController" (for queries), instead.
 *
 * Interactions can be seen as mutable transaction & query builders.
 *
 * Aside from building transactions and queries, the interactors are also responsible for interpreting
 * the execution outcome for the objects they've built.
 */
class Interaction {
    constructor(contract, func, args) {
        this.nonce = 0;
        this.value = "0";
        this.gasLimit = 0;
        this.gasPrice = undefined;
        this.chainID = "";
        this.querent = address_1.Address.empty();
        this.sender = address_1.Address.empty();
        this.version = constants_1.TRANSACTION_VERSION_DEFAULT;
        this.contract = contract;
        this.function = func;
        this.args = args;
        this.tokenTransfers = [];
    }
    getContractAddress() {
        return this.contract.getAddress();
    }
    getFunction() {
        return this.function;
    }
    getEndpoint() {
        return this.contract.getEndpoint(this.function);
    }
    getArguments() {
        return this.args;
    }
    getValue() {
        return this.value;
    }
    getTokenTransfers() {
        return this.tokenTransfers;
    }
    getGasLimit() {
        return this.gasLimit;
    }
    getExplicitReceiver() {
        return this.explicitReceiver;
    }
    buildTransaction() {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(this.sender, "'sender' of interaction", "use interaction.withSender()");
        const factoryConfig = new transactionsFactories_1.TransactionsFactoryConfig({ chainID: this.chainID.valueOf() });
        const factory = new transactionsFactories_1.SmartContractTransactionsFactory({
            config: factoryConfig,
        });
        const transaction = factory.createTransactionForExecute({
            sender: this.sender,
            contract: this.contract.getAddress(),
            function: this.function.valueOf(),
            gasLimit: BigInt(this.gasLimit.valueOf()),
            arguments: this.args,
            nativeTransferAmount: BigInt(this.value.toString()),
            tokenTransfers: this.tokenTransfers,
        });
        transaction.chainID = this.chainID.valueOf();
        transaction.nonce = BigInt(this.nonce.valueOf());
        transaction.version = this.version;
        if (this.gasPrice) {
            transaction.gasPrice = BigInt(this.gasPrice.valueOf());
        }
        return transaction;
    }
    buildQuery() {
        return new query_1.Query({
            address: this.contract.getAddress(),
            func: this.function,
            args: this.args,
            // Value will be set using "withValue()".
            value: this.value,
            caller: this.querent,
        });
    }
    withValue(value) {
        this.value = value;
        return this;
    }
    withSingleESDTTransfer(transfer) {
        this.tokenTransfers = [transfer].map((transfer) => new tokens_1.TokenTransfer(transfer));
        return this;
    }
    withSingleESDTNFTTransfer(transfer) {
        this.tokenTransfers = [transfer].map((transfer) => new tokens_1.TokenTransfer(transfer));
        return this;
    }
    withMultiESDTNFTTransfer(transfers) {
        this.tokenTransfers = transfers.map((transfer) => new tokens_1.TokenTransfer(transfer));
        return this;
    }
    withGasLimit(gasLimit) {
        this.gasLimit = gasLimit;
        return this;
    }
    withGasPrice(gasPrice) {
        this.gasPrice = gasPrice;
        return this;
    }
    withNonce(nonce) {
        this.nonce = nonce;
        return this;
    }
    useThenIncrementNonceOf(account) {
        return this.withNonce(account.getNonceThenIncrement());
    }
    withChainID(chainID) {
        this.chainID = chainID;
        return this;
    }
    withSender(sender) {
        this.sender = sender;
        return this;
    }
    withVersion(version) {
        this.version = version;
        return this;
    }
    /**
     * Sets the "caller" field on contract queries.
     */
    withQuerent(querent) {
        this.querent = querent;
        return this;
    }
    withExplicitReceiver(receiver) {
        this.explicitReceiver = receiver;
        return this;
    }
    /**
     * To perform custom checking, extend {@link Interaction} and override this method.
     */
    check() {
        new interactionChecker_1.InteractionChecker().checkInteraction(this, this.getEndpoint());
        return this;
    }
}
exports.Interaction = Interaction;
//# sourceMappingURL=interaction.js.map