import { EndpointDefinition } from "./endpoint";
import { EnumType } from "./enum";
import { EventDefinition } from "./event";
import { ExplicitEnumType } from "./explicit-enum";
import { StructType } from "./struct";
import { CustomType } from "./types";
export declare class AbiRegistry {
    readonly name: string;
    readonly constructorDefinition: EndpointDefinition;
    readonly upgradeConstructorDefinition?: EndpointDefinition;
    readonly endpoints: EndpointDefinition[];
    readonly customTypes: CustomType[];
    readonly events: EventDefinition[];
    private constructor();
    static create(options: {
        name?: string;
        constructor?: any;
        upgradeConstructor?: any;
        endpoints?: any[];
        types?: Record<string, any>;
        events?: any[];
    }): AbiRegistry;
    getCustomType(name: string): CustomType;
    getStruct(name: string): StructType;
    getStructs(names: string[]): StructType[];
    getEnum(name: string): EnumType;
    getExplicitEnum(name: string): ExplicitEnumType;
    getEnums(names: string[]): EnumType[];
    getEndpoints(): EndpointDefinition[];
    getEndpoint(name: string): EndpointDefinition;
    getEvent(name: string): EventDefinition;
    /**
     * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)
     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).
     *
     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).
     *
     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).
     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).
     * The result is an equivalent, more explicit ABI registry.
     */
    remapToKnownTypes(): AbiRegistry;
    private mapCustomTypeDepthFirst;
}
