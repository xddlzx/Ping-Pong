/// <reference types="node" />
import { TransactionMetadata } from "@multiversx/sdk-transaction-decoder/lib/src/transaction.decoder";
import { IAddress } from "../interface";
import { IContractQueryResponse, IContractResults, ITransactionLogs, ITransactionOnNetwork } from "../interfaceOfNetwork";
import { TypedOutcomeBundle, UntypedOutcomeBundle } from "./interface";
import { ReturnCode } from "./returnCode";
import { Type, TypedValue } from "./typesystem";
interface IResultsParserOptions {
    argsSerializer: IArgsSerializer;
}
interface IParameterDefinition {
    type: Type;
}
interface IEventInputDefinition {
    name: string;
    type: Type;
    indexed: boolean;
}
interface ITransactionEvent {
    readonly topics: {
        valueOf(): Uint8Array;
    }[];
    readonly dataPayload?: {
        valueOf(): Uint8Array;
    };
    readonly additionalData?: {
        valueOf(): Uint8Array;
    }[];
}
interface IArgsSerializer {
    buffersToValues(buffers: Buffer[], parameters: IParameterDefinition[]): TypedValue[];
    stringToBuffers(joinedString: string): Buffer[];
}
/**
 * Legacy component.
 * For parsing contract query responses, use the "SmartContractQueriesController" instead.
 * For parsing smart contract outcome (return data), use the "SmartContractTransactionsOutcomeParser" instead.
 * For parding smart contract events, use the "TransactionEventsParser" instead.
 *
 * Parses contract query responses and smart contract results.
 * The parsing involves some heuristics, in order to handle slight inconsistencies (e.g. some SCRs are present on API, but missing on Gateway).
 */
export declare class ResultsParser {
    private readonly argsSerializer;
    constructor(options?: IResultsParserOptions);
    /**
     * Legacy method, use "SmartContractQueriesController.parseQueryResponse()" instead.
     */
    parseQueryResponse(queryResponse: IContractQueryResponse, endpoint: {
        output: IParameterDefinition[];
    }): TypedOutcomeBundle;
    /**
     * Legacy method, use "SmartContractQueriesController.parseQueryResponse()" instead.
     */
    parseUntypedQueryResponse(queryResponse: IContractQueryResponse): UntypedOutcomeBundle;
    /**
     * Legacy method, use "SmartContractTransactionsOutcomeParser.parseExecute()" instead.
     */
    parseOutcome(transaction: ITransactionOnNetwork, endpoint: {
        output: IParameterDefinition[];
    }): TypedOutcomeBundle;
    /**
     * @internal
     * For internal use only.
     */
    parseOutcomeFromUntypedBundle(bundle: UntypedOutcomeBundle, endpoint: {
        output: IParameterDefinition[];
    }): {
        returnCode: ReturnCode;
        returnMessage: string;
        values: TypedValue[];
        firstValue: TypedValue;
        secondValue: TypedValue;
        thirdValue: TypedValue;
        lastValue: TypedValue;
    };
    /**
     * Legacy method, use "SmartContractTransactionsOutcomeParser.parseExecute()" instead.
     */
    parseUntypedOutcome(transaction: ITransactionOnNetwork): UntypedOutcomeBundle;
    protected parseTransactionMetadata(transaction: ITransactionOnNetwork): TransactionMetadata;
    protected createBundleOnSimpleMoveBalance(transaction: ITransactionOnNetwork): UntypedOutcomeBundle | null;
    protected createBundleOnInvalidTransaction(transaction: ITransactionOnNetwork): UntypedOutcomeBundle | null;
    protected createBundleOnEasilyFoundResultWithReturnData(results: IContractResults): UntypedOutcomeBundle | null;
    protected createBundleOnSignalError(logs: ITransactionLogs): UntypedOutcomeBundle | null;
    protected createBundleOnTooMuchGasWarning(logs: ITransactionLogs): UntypedOutcomeBundle | null;
    protected createBundleOnWriteLogWhereFirstTopicEqualsAddress(logs: ITransactionLogs, address: IAddress): UntypedOutcomeBundle | null;
    /**
     * Override this method (in a subclass of {@link ResultsParser}) if the basic heuristics of the parser are not sufficient.
     */
    protected createBundleWithCustomHeuristics(_transaction: ITransactionOnNetwork, _transactionMetadata: TransactionMetadata): UntypedOutcomeBundle | null;
    protected createBundleWithFallbackHeuristics(transaction: ITransactionOnNetwork, transactionMetadata: TransactionMetadata): UntypedOutcomeBundle | null;
    protected sliceDataFieldInParts(data: string): {
        returnCode: ReturnCode;
        returnDataParts: Buffer[];
    };
    /**
     * Legacy method, use "TransactionEventsParser.parseEvent()" instead.
     */
    parseEvent(transactionEvent: ITransactionEvent, eventDefinition: {
        inputs: IEventInputDefinition[];
    }): any;
    /**
     * @internal
     * For internal use only.
     *
     * Once the legacy "ResultParser" is deprecated & removed, this logic will be absorbed into "TransactionEventsParser".
     */
    doParseEvent(options: {
        topics: Buffer[];
        dataItems: Buffer[];
        eventDefinition: {
            inputs: IEventInputDefinition[];
        };
    }): any;
}
export {};
