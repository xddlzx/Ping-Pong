"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeSerializer = void 0;
/* eslint-disable @typescript-eslint/no-namespace */
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const address_1 = require("../address");
const errors_1 = require("../errors");
const utils_codec_1 = require("../utils.codec");
const argumentErrorContext_1 = require("./argumentErrorContext");
const typesystem_1 = require("./typesystem");
var NativeSerializer;
(function (NativeSerializer) {
    /**
     * Interprets a set of native javascript values into a set of typed values, given parameter definitions.
     */
    function nativeToTypedValues(args, endpoint) {
        args = args || [];
        checkArgumentsCardinality(args, endpoint);
        if (hasNonCountedVariadicParameter(endpoint)) {
            args = repackNonCountedVariadicParameters(args, endpoint);
        }
        else {
            // Repacking makes sense (it's possible) only for regular, non-counted variadic parameters.
        }
        let parameters = endpoint.input;
        let values = [];
        for (let i = 0; i < parameters.length; i++) {
            let parameter = parameters[i];
            let errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i, parameter);
            let value = convertToTypedValue(args[i], parameter.type, errorContext);
            values.push(value);
        }
        return values;
    }
    NativeSerializer.nativeToTypedValues = nativeToTypedValues;
    function checkArgumentsCardinality(args, endpoint) {
        // With respect to the notes of "repackNonCountedVariadicParameters", "getArgumentsCardinality" will not be needed anymore.
        // Currently, it is used only for a arguments count check, which will become redundant.
        const { min, max } = getArgumentsCardinality(endpoint.input);
        if (!(min <= args.length && args.length <= max)) {
            throw new errors_1.ErrInvalidArgument(`Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`);
        }
    }
    function hasNonCountedVariadicParameter(endpoint) {
        const lastParameter = endpoint.input[endpoint.input.length - 1];
        return lastParameter?.type instanceof typesystem_1.VariadicType && !lastParameter.type.isCounted;
    }
    // In a future version of the type inference system, re-packing logic will be removed.
    // The client code will be responsible for passing the correctly packed arguments (variadic arguments explicitly packed as arrays).
    // For developers, calling `foo(["erd1", 42, [1, 2, 3]])` will be less ambiguous than `foo(["erd1", 42, 1, 2, 3])`.
    // Furthermore, multiple counted-variadic arguments cannot be expressed in the current variant.
    // E.g. now, it's unreasonable to decide that `foo([1, 2, 3, "a", "b", "c"])` calls `foo(counted-variadic<int>, counted-variadic<string>)`.
    function repackNonCountedVariadicParameters(args, endpoint) {
        const lastEndpointParamIndex = endpoint.input.length - 1;
        const argAtIndex = args[lastEndpointParamIndex];
        if (argAtIndex?.belongsToTypesystem) {
            const isVariadicValue = argAtIndex.hasClassOrSuperclass(typesystem_1.VariadicValue.ClassName);
            if (!isVariadicValue) {
                throw new errors_1.ErrInvalidArgument(`Wrong argument type for endpoint ${endpoint.name}: typed value provided; expected variadic type, have ${argAtIndex.getClassName()}`);
            }
            // Do not repack.
        }
        else {
            args[lastEndpointParamIndex] = args.slice(lastEndpointParamIndex);
        }
        return args;
    }
    // A function may have one of the following formats:
    // f(arg1, arg2, optional<arg3>, optional<arg4>) returns { min: 2, max: 4, variadic: false }
    // f(arg1, variadic<bytes>) returns { min: 1, max: Infinity, variadic: true }
    // f(arg1, arg2, optional<arg3>, arg4, optional<arg5>, variadic<bytes>) returns { min: 2, max: Infinity, variadic: true }
    function getArgumentsCardinality(parameters) {
        let reversed = [...parameters].reverse(); // keep the original unchanged
        let min = parameters.length;
        let max = parameters.length;
        let variadic = false;
        if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {
            max = Infinity;
            variadic = true;
        }
        for (let parameter of reversed) {
            // It's a single-value, not a multi-value parameter. Thus, cardinality isn't affected.
            if (parameter.type.getCardinality().isSingular()) {
                break;
            }
            // It's a multi-value parameter: optional, variadic etc.
            min -= 1;
        }
        return { min, max, variadic };
    }
    NativeSerializer.getArgumentsCardinality = getArgumentsCardinality;
    function convertToTypedValue(value, type, errorContext) {
        if (value && typesystem_1.isTyped(value)) {
            // Value is already typed, no need to convert it.
            return value;
        }
        if (type instanceof typesystem_1.OptionType) {
            return toOptionValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.OptionalType) {
            return toOptionalValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.VariadicType) {
            return toVariadicValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.CompositeType) {
            return toCompositeValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.TupleType) {
            return toTupleValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.StructType) {
            return toStructValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.ListType) {
            return toListValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.PrimitiveType) {
            return toPrimitive(value, type, errorContext);
        }
        if (type instanceof typesystem_1.EnumType) {
            return toEnumValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.ExplicitEnumType) {
            return toExplicitEnumValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.ManagedDecimalType) {
            return toManagedDecimal(value, type, errorContext);
        }
        errorContext.throwError(`convertToTypedValue: unhandled type ${type}`);
    }
    function toOptionValue(native, type, errorContext) {
        if (native == null) {
            return typesystem_1.OptionValue.newMissing();
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return typesystem_1.OptionValue.newProvided(converted);
    }
    function toOptionalValue(native, type, errorContext) {
        if (native == null) {
            return new typesystem_1.OptionalValue(type);
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return new typesystem_1.OptionalValue(type, converted);
    }
    function toVariadicValue(native, type, errorContext) {
        if (type.isCounted) {
            throw new errors_1.ErrInvalidArgument(`Counted variadic arguments must be explicitly typed. E.g. use "VariadicValue.fromItemsCounted()" or "new VariadicValue()"`);
        }
        if (native == null) {
            native = [];
        }
        if (native.map === undefined) {
            errorContext.convertError(native, "Variadic");
        }
        let converted = native.map(function (item) {
            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.VariadicValue(type, converted);
    }
    function toListValue(native, type, errorContext) {
        if (native.map === undefined) {
            errorContext.convertError(native, "List");
        }
        let converted = native.map(function (item) {
            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.List(type, converted);
    }
    function toCompositeValue(native, type, errorContext) {
        let typedValues = [];
        let typeParameters = type.getTypeParameters();
        errorContext.guardSameLength(native, typeParameters);
        for (let i = 0; i < typeParameters.length; i++) {
            typedValues.push(convertToTypedValue(native[i], typeParameters[i], errorContext));
        }
        return new typesystem_1.CompositeValue(type, typedValues);
    }
    function toTupleValue(native, type, errorContext) {
        let typedValues = [];
        const fields = type.getFieldsDefinitions();
        errorContext.guardSameLength(native, fields);
        for (let i = 0; i < fields.length; i++) {
            typedValues.push(convertToTypedValue(native[i], fields[i].type, errorContext));
        }
        return typesystem_1.Tuple.fromItems(typedValues);
    }
    function toStructValue(native, type, errorContext) {
        let structFieldValues = [];
        const fields = type.getFieldsDefinitions();
        for (let i = 0; i < fields.length; i++) {
            const fieldName = fields[i].name;
            errorContext.guardHasField(native, fieldName);
            const fieldNativeValue = native[fieldName];
            const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);
            structFieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));
        }
        return new typesystem_1.Struct(type, structFieldValues);
    }
    function toPrimitive(native, type, errorContext) {
        if (type instanceof typesystem_1.NumericalType) {
            const number = new bignumber_js_1.default(native);
            return convertNumericalType(number, type, errorContext);
        }
        if (type instanceof typesystem_1.BytesType) {
            return convertNativeToBytesValue(native, errorContext);
        }
        if (type instanceof typesystem_1.AddressType) {
            return new typesystem_1.AddressValue(convertNativeToAddress(native, errorContext));
        }
        if (type instanceof typesystem_1.BooleanType) {
            const boolValue = native.toString().toLowerCase() === "true" || native.toString() === "1";
            return new typesystem_1.BooleanValue(boolValue);
        }
        if (type instanceof typesystem_1.TokenIdentifierType) {
            return new typesystem_1.TokenIdentifierValue(convertNativeToString(native, errorContext));
        }
        errorContext.throwError(`(function: toPrimitive) unsupported type ${type}`);
    }
    function toEnumValue(native, type, errorContext) {
        if (typeof native === "number") {
            return typesystem_1.EnumValue.fromDiscriminant(type, native);
        }
        if (typeof native === "string") {
            return typesystem_1.EnumValue.fromName(type, native);
        }
        if (typeof native === "object") {
            errorContext.guardHasField(native, "name");
            const variant = type.getVariantByName(native.name);
            errorContext.guardHasField(native, "fields");
            const nativeFields = native.fields;
            const fieldValues = [];
            const fields = variant.getFieldsDefinitions();
            for (let i = 0; i < fields.length; i++) {
                const fieldName = fields[i].name;
                errorContext.guardHasField(nativeFields, fieldName);
                const fieldNativeValue = nativeFields[fieldName];
                const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);
                fieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));
            }
            return new typesystem_1.EnumValue(type, variant, fieldValues);
        }
        errorContext.throwError(`(function: toEnumValue) unsupported native type ${typeof native}`);
    }
    function toExplicitEnumValue(native, type, errorContext) {
        if (typeof native === "string") {
            return typesystem_1.ExplicitEnumValue.fromName(type, native);
        }
        if (typeof native === "object") {
            errorContext.guardHasField(native, "name");
            const variant = type.getVariantByName(native.name);
            return new typesystem_1.ExplicitEnumValue(type, variant);
        }
        errorContext.throwError(`(function: toExplicitEnumValue) unsupported native type ${typeof native}`);
    }
    function toManagedDecimal(native, type, errorContext) {
        if (typeof native === "object") {
            return new typesystem_1.ManagedDecimalValue(native[0], native[1], type.isVariable());
        }
        errorContext.throwError(`(function: toManagedDecimal) unsupported native type ${typeof native}`);
    }
    // TODO: move logic to typesystem/bytes.ts
    function convertNativeToBytesValue(native, errorContext) {
        const innerValue = native.valueOf();
        if (native === undefined) {
            errorContext.convertError(native, "BytesValue");
        }
        if (native instanceof Buffer) {
            return new typesystem_1.BytesValue(native);
        }
        if (typeof native === "string") {
            return typesystem_1.BytesValue.fromUTF8(native);
        }
        if (innerValue instanceof Buffer) {
            return new typesystem_1.BytesValue(innerValue);
        }
        if (typeof innerValue === "number") {
            return typesystem_1.BytesValue.fromHex(utils_codec_1.numberToPaddedHex(innerValue));
        }
        errorContext.convertError(native, "BytesValue");
    }
    // TODO: move logic to typesystem/string.ts
    function convertNativeToString(native, errorContext) {
        if (native === undefined) {
            errorContext.convertError(native, "Buffer");
        }
        if (native instanceof Buffer) {
            return native.toString();
        }
        if (typeof native === "string") {
            return native;
        }
        errorContext.convertError(native, "Buffer");
    }
    // TODO: move logic to typesystem/address.ts
    function convertNativeToAddress(native, errorContext) {
        if (native.bech32) {
            return native;
        }
        if (native.getAddress) {
            return native.getAddress();
        }
        switch (native.constructor) {
            case Buffer:
            case String:
                return new address_1.Address(native);
            default:
                errorContext.convertError(native, "Address");
        }
    }
    NativeSerializer.convertNativeToAddress = convertNativeToAddress;
    // TODO: move logic to typesystem/numerical.ts
    function convertNumericalType(number, type, errorContext) {
        switch (type.constructor) {
            case typesystem_1.U8Type:
                return new typesystem_1.U8Value(number);
            case typesystem_1.I8Type:
                return new typesystem_1.I8Value(number);
            case typesystem_1.U16Type:
                return new typesystem_1.U16Value(number);
            case typesystem_1.I16Type:
                return new typesystem_1.I16Value(number);
            case typesystem_1.U32Type:
                return new typesystem_1.U32Value(number);
            case typesystem_1.I32Type:
                return new typesystem_1.I32Value(number);
            case typesystem_1.U64Type:
                return new typesystem_1.U64Value(number);
            case typesystem_1.I64Type:
                return new typesystem_1.I64Value(number);
            case typesystem_1.BigUIntType:
                return new typesystem_1.BigUIntValue(number);
            case typesystem_1.BigIntType:
                return new typesystem_1.BigIntValue(number);
            default:
                errorContext.unhandledType("convertNumericalType", type);
        }
    }
})(NativeSerializer = exports.NativeSerializer || (exports.NativeSerializer = {}));
//# sourceMappingURL=nativeSerializer.js.map