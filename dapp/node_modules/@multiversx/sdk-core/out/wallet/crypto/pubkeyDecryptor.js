"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubkeyDecryptor = void 0;
const crypto_1 = __importDefault(require("crypto"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const ed2curve_1 = __importDefault(require("ed2curve"));
const userKeys_1 = require("../userKeys");
class PubkeyDecryptor {
    static decrypt(data, decryptorSecretKey) {
        const ciphertext = Buffer.from(data.ciphertext, 'hex');
        const edhPubKey = Buffer.from(data.identities.ephemeralPubKey, 'hex');
        const originatorPubKeyBuffer = Buffer.from(data.identities.originatorPubKey, 'hex');
        const originatorPubKey = new userKeys_1.UserPublicKey(originatorPubKeyBuffer);
        const authMessage = crypto_1.default.createHash('sha256').update(Buffer.concat([ciphertext, edhPubKey])).digest();
        if (!originatorPubKey.verify(authMessage, Buffer.from(data.mac, 'hex'))) {
            throw new Error("Invalid authentication for encrypted message originator");
        }
        const nonce = Buffer.from(data.nonce, 'hex');
        const x25519Secret = ed2curve_1.default.convertSecretKey(decryptorSecretKey.valueOf());
        const x25519EdhPubKey = ed2curve_1.default.convertPublicKey(edhPubKey);
        if (x25519EdhPubKey === null) {
            throw new Error("Could not convert ed25519 public key to x25519");
        }
        const decryptedMessage = tweetnacl_1.default.box.open(ciphertext, nonce, x25519EdhPubKey, x25519Secret);
        if (decryptedMessage === null) {
            throw new Error("Failed authentication for given ciphertext");
        }
        return Buffer.from(decryptedMessage);
    }
}
exports.PubkeyDecryptor = PubkeyDecryptor;
//# sourceMappingURL=pubkeyDecryptor.js.map