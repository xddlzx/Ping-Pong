"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubkeyEncryptor = void 0;
const crypto_1 = __importDefault(require("crypto"));
const ed2curve_1 = __importDefault(require("ed2curve"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const constants_1 = require("./constants");
const x25519EncryptedData_1 = require("./x25519EncryptedData");
class PubkeyEncryptor {
    static encrypt(data, recipientPubKey, authSecretKey) {
        // create a new x25519 keypair that will be used for EDH
        const edhPair = tweetnacl_1.default.sign.keyPair();
        const recipientDHPubKey = ed2curve_1.default.convertPublicKey(recipientPubKey.valueOf());
        if (recipientDHPubKey === null) {
            throw new Error("Could not convert ed25519 public key to x25519");
        }
        const edhConvertedSecretKey = ed2curve_1.default.convertSecretKey(edhPair.secretKey);
        // For the nonce we use a random component and a deterministic one based on the message
        //  - this is so we won't completely rely on the random number generator
        const nonceDeterministic = crypto_1.default.createHash('sha256').update(data).digest().slice(0, constants_1.PubKeyEncNonceLength / 2);
        const nonceRandom = tweetnacl_1.default.randomBytes(constants_1.PubKeyEncNonceLength / 2);
        const nonce = Buffer.concat([nonceDeterministic, nonceRandom]);
        const encryptedMessage = tweetnacl_1.default.box(data, nonce, recipientDHPubKey, edhConvertedSecretKey);
        // Note that the ciphertext is already authenticated for the ephemeral key - but we want it authenticated by
        //  the ed25519 key which the user interacts with. A signature over H(ciphertext | edhPubKey)
        //  would be enough
        const authMessage = crypto_1.default.createHash('sha256').update(Buffer.concat([encryptedMessage, edhPair.publicKey])).digest();
        const signature = authSecretKey.sign(authMessage);
        return new x25519EncryptedData_1.X25519EncryptedData({
            version: constants_1.PubKeyEncVersion,
            nonce: Buffer.from(nonce).toString('hex'),
            cipher: constants_1.PubKeyEncCipher,
            ciphertext: Buffer.from(encryptedMessage).toString('hex'),
            mac: signature.toString('hex'),
            identities: {
                recipient: recipientPubKey.hex(),
                ephemeralPubKey: Buffer.from(edhPair.publicKey).toString('hex'),
                originatorPubKey: authSecretKey.generatePublicKey().hex(),
            }
        });
    }
}
exports.PubkeyEncryptor = PubkeyEncryptor;
//# sourceMappingURL=pubkeyEncryptor.js.map