"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserWallet = exports.UserWalletKind = void 0;
const errors_1 = require("../errors");
const crypto_1 = require("./crypto");
const derivationParams_1 = require("./crypto/derivationParams");
const mnemonic_1 = require("./mnemonic");
const userKeys_1 = require("./userKeys");
var UserWalletKind;
(function (UserWalletKind) {
    UserWalletKind["SecretKey"] = "secretKey";
    UserWalletKind["Mnemonic"] = "mnemonic";
})(UserWalletKind = exports.UserWalletKind || (exports.UserWalletKind = {}));
class UserWallet {
    constructor({ kind, encryptedData, publicKeyWhenKindIsSecretKey, }) {
        this.kind = kind;
        this.encryptedData = encryptedData;
        this.publicKeyWhenKindIsSecretKey = publicKeyWhenKindIsSecretKey;
    }
    static fromSecretKey({ secretKey, password, randomness, }) {
        randomness = randomness || new crypto_1.Randomness();
        const publicKey = secretKey.generatePublicKey();
        const data = Buffer.concat([secretKey.valueOf(), publicKey.valueOf()]);
        const encryptedData = crypto_1.Encryptor.encrypt(data, password, randomness);
        return new UserWallet({
            kind: UserWalletKind.SecretKey,
            encryptedData,
            publicKeyWhenKindIsSecretKey: publicKey,
        });
    }
    static fromMnemonic({ mnemonic, password, randomness, }) {
        randomness = randomness || new crypto_1.Randomness();
        mnemonic_1.Mnemonic.assertTextIsValid(mnemonic);
        const data = Buffer.from(mnemonic);
        const encryptedData = crypto_1.Encryptor.encrypt(data, password, randomness);
        return new UserWallet({
            kind: UserWalletKind.Mnemonic,
            encryptedData,
        });
    }
    static decrypt(keyFileObject, password, addressIndex) {
        const kind = keyFileObject.kind || UserWalletKind.SecretKey;
        if (kind == UserWalletKind.SecretKey) {
            if (addressIndex !== undefined) {
                throw new errors_1.Err("addressIndex must not be provided when kind == 'secretKey'");
            }
            return UserWallet.decryptSecretKey(keyFileObject, password);
        }
        if (kind == UserWalletKind.Mnemonic) {
            const mnemonic = this.decryptMnemonic(keyFileObject, password);
            return mnemonic.deriveKey(addressIndex || 0);
        }
        throw new errors_1.Err(`Unknown kind: ${kind}`);
    }
    /**
     * Copied from: https://github.com/multiversx/mx-deprecated-core-js/blob/v1.28.0/src/account.js#L42
     * Notes: adjustements (code refactoring, no change in logic), in terms of:
     *  - typing (since this is the TypeScript version)
     *  - error handling (in line with sdk-core's error system)
     *  - references to crypto functions
     *  - references to object members
     *
     * From an encrypted keyfile, given the password, loads the secret key and the public key.
     */
    static decryptSecretKey(keyFileObject, password) {
        // Here, we check the "kind" field only for files that have it. Older keystore files (holding only secret keys) do not have this field.
        const kind = keyFileObject.kind;
        if (kind && kind !== UserWalletKind.SecretKey) {
            throw new errors_1.Err(`Expected keystore kind to be ${UserWalletKind.SecretKey}, but it was ${kind}.`);
        }
        const encryptedData = UserWallet.edFromJSON(keyFileObject);
        let text = crypto_1.Decryptor.decrypt(encryptedData, password);
        while (text.length < 32) {
            let zeroPadding = Buffer.from([0x00]);
            text = Buffer.concat([zeroPadding, text]);
        }
        const seed = text.slice(0, 32);
        return new userKeys_1.UserSecretKey(seed);
    }
    static decryptMnemonic(keyFileObject, password) {
        if (keyFileObject.kind != UserWalletKind.Mnemonic) {
            throw new errors_1.Err(`Expected keystore kind to be ${UserWalletKind.Mnemonic}, but it was ${keyFileObject.kind}.`);
        }
        const encryptedData = UserWallet.edFromJSON(keyFileObject);
        const data = crypto_1.Decryptor.decrypt(encryptedData, password);
        const mnemonic = mnemonic_1.Mnemonic.fromString(data.toString());
        return mnemonic;
    }
    static edFromJSON(keyfileObject) {
        return new crypto_1.EncryptedData({
            version: keyfileObject.version,
            id: keyfileObject.id,
            cipher: keyfileObject.crypto.cipher,
            ciphertext: keyfileObject.crypto.ciphertext,
            iv: keyfileObject.crypto.cipherparams.iv,
            kdf: keyfileObject.crypto.kdf,
            kdfparams: new derivationParams_1.ScryptKeyDerivationParams(keyfileObject.crypto.kdfparams.n, keyfileObject.crypto.kdfparams.r, keyfileObject.crypto.kdfparams.p, keyfileObject.crypto.kdfparams.dklen),
            salt: keyfileObject.crypto.kdfparams.salt,
            mac: keyfileObject.crypto.mac,
        });
    }
    /**
     * Converts the encrypted keyfile to plain JavaScript object.
     */
    toJSON(addressHrp) {
        if (this.kind == UserWalletKind.SecretKey) {
            return this.toJSONWhenKindIsSecretKey(addressHrp);
        }
        return this.toJSONWhenKindIsMnemonic();
    }
    toJSONWhenKindIsSecretKey(addressHrp) {
        if (!this.publicKeyWhenKindIsSecretKey) {
            throw new errors_1.Err("Public key isn't available");
        }
        const cryptoSection = this.getCryptoSectionAsJSON();
        const envelope = {
            version: this.encryptedData.version,
            kind: this.kind,
            id: this.encryptedData.id,
            address: this.publicKeyWhenKindIsSecretKey.hex(),
            bech32: this.publicKeyWhenKindIsSecretKey.toAddress(addressHrp).toString(),
            crypto: cryptoSection,
        };
        return envelope;
    }
    getCryptoSectionAsJSON() {
        const cryptoSection = {
            ciphertext: this.encryptedData.ciphertext,
            cipherparams: { iv: this.encryptedData.iv },
            cipher: crypto_1.CipherAlgorithm,
            kdf: crypto_1.KeyDerivationFunction,
            kdfparams: {
                dklen: this.encryptedData.kdfparams.dklen,
                salt: this.encryptedData.salt,
                n: this.encryptedData.kdfparams.n,
                r: this.encryptedData.kdfparams.r,
                p: this.encryptedData.kdfparams.p,
            },
            mac: this.encryptedData.mac,
        };
        return cryptoSection;
    }
    toJSONWhenKindIsMnemonic() {
        const cryptoSection = this.getCryptoSectionAsJSON();
        return {
            version: this.encryptedData.version,
            id: this.encryptedData.id,
            kind: this.kind,
            crypto: cryptoSection,
        };
    }
}
exports.UserWallet = UserWallet;
//# sourceMappingURL=userWallet.js.map