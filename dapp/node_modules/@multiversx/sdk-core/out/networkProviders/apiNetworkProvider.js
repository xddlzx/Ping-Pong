"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiNetworkProvider = void 0;
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const utils_codec_1 = require("../utils.codec");
const accounts_1 = require("./accounts");
const config_1 = require("./config");
const constants_1 = require("./constants");
const contractQueryRequest_1 = require("./contractQueryRequest");
const contractQueryResponse_1 = require("./contractQueryResponse");
const networkGeneralStatistics_1 = require("./networkGeneralStatistics");
const networkStake_1 = require("./networkStake");
const pairs_1 = require("./pairs");
const proxyNetworkProvider_1 = require("./proxyNetworkProvider");
const tokenDefinitions_1 = require("./tokenDefinitions");
const tokens_1 = require("./tokens");
const transactions_1 = require("./transactions");
const transactionStatus_1 = require("./transactionStatus");
const userAgent_1 = require("./userAgent");
// TODO: Find & remove duplicate code between "ProxyNetworkProvider" and "ApiNetworkProvider".
class ApiNetworkProvider {
    constructor(url, config) {
        this.userAgentPrefix = `${constants_1.BaseUserAgent}/api`;
        this.url = url;
        const proxyConfig = this.getProxyConfig(config);
        this.config = { ...config_1.defaultAxiosConfig, ...config };
        this.backingProxyNetworkProvider = new proxyNetworkProvider_1.ProxyNetworkProvider(url, proxyConfig);
        this.axios = utils_1.getAxios();
        userAgent_1.extendUserAgentIfBackend(this.userAgentPrefix, this.config);
    }
    getProxyConfig(config) {
        let proxyConfig = JSON.parse(JSON.stringify(config || {}));
        proxyConfig = { ...config_1.defaultAxiosConfig, ...proxyConfig };
        return proxyConfig;
    }
    async getNetworkConfig() {
        return await this.backingProxyNetworkProvider.getNetworkConfig();
    }
    async getNetworkStatus() {
        return await this.backingProxyNetworkProvider.getNetworkStatus();
    }
    async getNetworkStakeStatistics() {
        const response = await this.doGetGeneric("stake");
        const networkStake = networkStake_1.NetworkStake.fromHttpResponse(response);
        return networkStake;
    }
    async getNetworkGeneralStatistics() {
        const response = await this.doGetGeneric("stats");
        const stats = networkGeneralStatistics_1.NetworkGeneralStatistics.fromHttpResponse(response);
        return stats;
    }
    async getAccount(address) {
        const response = await this.doGetGeneric(`accounts/${address.bech32()}`);
        const account = accounts_1.AccountOnNetwork.fromHttpResponse(response);
        return account;
    }
    async getGuardianData(address) {
        return await this.backingProxyNetworkProvider.getGuardianData(address);
    }
    async getFungibleTokensOfAccount(address, pagination) {
        pagination = pagination || config_1.defaultPagination;
        const url = `accounts/${address.bech32()}/tokens?${this.buildPaginationParams(pagination)}`;
        const response = await this.doGetGeneric(url);
        const tokens = response.map((item) => tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(item));
        // TODO: Fix sorting
        tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
        return tokens;
    }
    async getNonFungibleTokensOfAccount(address, pagination) {
        pagination = pagination || config_1.defaultPagination;
        const url = `accounts/${address.bech32()}/nfts?${this.buildPaginationParams(pagination)}`;
        const response = await this.doGetGeneric(url);
        const tokens = response.map((item) => tokens_1.NonFungibleTokenOfAccountOnNetwork.fromApiHttpResponse(item));
        // TODO: Fix sorting
        tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
        return tokens;
    }
    async getFungibleTokenOfAccount(address, tokenIdentifier) {
        const response = await this.doGetGeneric(`accounts/${address.bech32()}/tokens/${tokenIdentifier}`);
        const tokenData = tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(response);
        return tokenData;
    }
    async getNonFungibleTokenOfAccount(address, collection, nonce) {
        const nonceAsHex = utils_codec_1.numberToPaddedHex(nonce);
        const response = await this.doGetGeneric(`accounts/${address.bech32()}/nfts/${collection}-${nonceAsHex}`);
        const tokenData = tokens_1.NonFungibleTokenOfAccountOnNetwork.fromApiHttpResponse(response);
        return tokenData;
    }
    async getMexPairs(pagination) {
        let url = `mex/pairs`;
        if (pagination) {
            url = `${url}?from=${pagination.from}&size=${pagination.size}`;
        }
        const response = await this.doGetGeneric(url);
        return response.map((item) => pairs_1.PairOnNetwork.fromApiHttpResponse(item));
    }
    async getTransaction(txHash) {
        const response = await this.doGetGeneric(`transactions/${txHash}`);
        const transaction = transactions_1.TransactionOnNetwork.fromApiHttpResponse(txHash, response);
        return transaction;
    }
    async getTransactionStatus(txHash) {
        const response = await this.doGetGeneric(`transactions/${txHash}?fields=status`);
        const status = new transactionStatus_1.TransactionStatus(response.status);
        return status;
    }
    async sendTransaction(tx) {
        const transaction = transactions_1.prepareTransactionForBroadcasting(tx);
        const response = await this.doPostGeneric("transactions", transaction);
        return response.txHash;
    }
    async sendTransactions(txs) {
        return await this.backingProxyNetworkProvider.sendTransactions(txs);
    }
    async simulateTransaction(tx) {
        return await this.backingProxyNetworkProvider.simulateTransaction(tx);
    }
    async queryContract(query) {
        try {
            const request = new contractQueryRequest_1.ContractQueryRequest(query).toHttpRequest();
            const response = await this.doPostGeneric("query", request);
            return contractQueryResponse_1.ContractQueryResponse.fromHttpResponse(response);
        }
        catch (error) {
            throw new errors_1.ErrContractQuery(error);
        }
    }
    async getDefinitionOfFungibleToken(tokenIdentifier) {
        const response = await this.doGetGeneric(`tokens/${tokenIdentifier}`);
        const definition = tokenDefinitions_1.DefinitionOfFungibleTokenOnNetwork.fromApiHttpResponse(response);
        return definition;
    }
    async getDefinitionOfTokenCollection(collection) {
        const response = await this.doGetGeneric(`collections/${collection}`);
        const definition = tokenDefinitions_1.DefinitionOfTokenCollectionOnNetwork.fromApiHttpResponse(response);
        return definition;
    }
    async getNonFungibleToken(collection, nonce) {
        const nonceAsHex = utils_codec_1.numberToPaddedHex(nonce);
        const response = await this.doGetGeneric(`nfts/${collection}-${nonceAsHex}`);
        const token = tokens_1.NonFungibleTokenOfAccountOnNetwork.fromApiHttpResponse(response);
        return token;
    }
    async doGetGeneric(resourceUrl) {
        const response = await this.doGet(resourceUrl);
        return response;
    }
    async doPostGeneric(resourceUrl, payload) {
        const response = await this.doPost(resourceUrl, payload);
        return response;
    }
    buildPaginationParams(pagination) {
        return `from=${pagination.from}&size=${pagination.size}`;
    }
    async doGet(resourceUrl) {
        const url = `${this.url}/${resourceUrl}`;
        try {
            const response = await this.axios.default.get(url, this.config);
            return response.data;
        }
        catch (error) {
            this.handleApiError(error, resourceUrl);
        }
    }
    async doPost(resourceUrl, payload) {
        const url = `${this.url}/${resourceUrl}`;
        try {
            const response = await this.axios.default.post(url, payload, {
                ...this.config,
                headers: {
                    "Content-Type": "application/json",
                    ...this.config.headers,
                },
            });
            const responsePayload = response.data;
            return responsePayload;
        }
        catch (error) {
            this.handleApiError(error, resourceUrl);
        }
    }
    handleApiError(error, resourceUrl) {
        if (!error.response) {
            throw new errors_1.ErrNetworkProvider(resourceUrl, error.toString(), error);
        }
        const errorData = error.response.data;
        const originalErrorMessage = errorData.message || errorData.error || JSON.stringify(errorData);
        throw new errors_1.ErrNetworkProvider(resourceUrl, originalErrorMessage, error);
    }
}
exports.ApiNetworkProvider = ApiNetworkProvider;
//# sourceMappingURL=apiNetworkProvider.js.map