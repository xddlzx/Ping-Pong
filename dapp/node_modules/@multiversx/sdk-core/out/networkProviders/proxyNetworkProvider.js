"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyNetworkProvider = void 0;
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const accounts_1 = require("./accounts");
const config_1 = require("./config");
const constants_1 = require("./constants");
const contractQueryRequest_1 = require("./contractQueryRequest");
const contractQueryResponse_1 = require("./contractQueryResponse");
const networkConfig_1 = require("./networkConfig");
const networkStatus_1 = require("./networkStatus");
const tokenDefinitions_1 = require("./tokenDefinitions");
const tokens_1 = require("./tokens");
const transactions_1 = require("./transactions");
const transactionStatus_1 = require("./transactionStatus");
const userAgent_1 = require("./userAgent");
// TODO: Find & remove duplicate code between "ProxyNetworkProvider" and "ApiNetworkProvider".
class ProxyNetworkProvider {
    constructor(url, config) {
        this.userAgentPrefix = `${constants_1.BaseUserAgent}/proxy`;
        this.url = url;
        this.config = { ...config_1.defaultAxiosConfig, ...config };
        this.axios = utils_1.getAxios();
        userAgent_1.extendUserAgentIfBackend(this.userAgentPrefix, this.config);
    }
    async getNetworkConfig() {
        const response = await this.doGetGeneric("network/config");
        const networkConfig = networkConfig_1.NetworkConfig.fromHttpResponse(response.config);
        return networkConfig;
    }
    async getNetworkStatus() {
        const response = await this.doGetGeneric("network/status/4294967295");
        const networkStatus = networkStatus_1.NetworkStatus.fromHttpResponse(response.status);
        return networkStatus;
    }
    async getNetworkStakeStatistics() {
        // TODO: Implement wrt.:
        // https://github.com/multiversx/mx-api-service/blob/main/src/endpoints/stake/stake.service.ts
        throw new Error("Method not implemented.");
    }
    async getNetworkGeneralStatistics() {
        // TODO: Implement wrt. (full implementation may not be possible):
        // https://github.com/multiversx/mx-api-service/blob/main/src/endpoints/network/network.service.ts
        throw new Error("Method not implemented.");
    }
    async getAccount(address) {
        const response = await this.doGetGeneric(`address/${address.bech32()}`);
        const account = accounts_1.AccountOnNetwork.fromHttpResponse(response.account);
        return account;
    }
    async getGuardianData(address) {
        const response = await this.doGetGeneric(`address/${address.bech32()}/guardian-data`);
        const accountGuardian = accounts_1.GuardianData.fromHttpResponse(response.guardianData);
        return accountGuardian;
    }
    async getFungibleTokensOfAccount(address, _pagination) {
        const url = `address/${address.bech32()}/esdt`;
        const response = await this.doGetGeneric(url);
        const responseItems = Object.values(response.esdts);
        // Skip NFTs / SFTs.
        const responseItemsFiltered = responseItems.filter((item) => !item.nonce);
        const tokens = responseItemsFiltered.map((item) => tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(item));
        // TODO: Fix sorting
        tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
        return tokens;
    }
    async getNonFungibleTokensOfAccount(address, _pagination) {
        const url = `address/${address.bech32()}/esdt`;
        const response = await this.doGetGeneric(url);
        const responseItems = Object.values(response.esdts);
        // Skip fungible tokens.
        const responseItemsFiltered = responseItems.filter((item) => item.nonce >= 0);
        const tokens = responseItemsFiltered.map((item) => tokens_1.NonFungibleTokenOfAccountOnNetwork.fromProxyHttpResponse(item));
        // TODO: Fix sorting
        tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
        return tokens;
    }
    async getFungibleTokenOfAccount(address, tokenIdentifier) {
        const response = await this.doGetGeneric(`address/${address.bech32()}/esdt/${tokenIdentifier}`);
        const tokenData = tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(response.tokenData);
        return tokenData;
    }
    async getNonFungibleTokenOfAccount(address, collection, nonce) {
        const response = await this.doGetGeneric(`address/${address.bech32()}/nft/${collection}/nonce/${nonce.valueOf()}`);
        const tokenData = tokens_1.NonFungibleTokenOfAccountOnNetwork.fromProxyHttpResponseByNonce(response.tokenData);
        return tokenData;
    }
    async getTransaction(txHash, _) {
        const url = this.buildUrlWithQueryParameters(`transaction/${txHash}`, { withResults: "true" });
        const [data, status] = await Promise.all([this.doGetGeneric(url), this.getTransactionStatus(txHash)]);
        return transactions_1.TransactionOnNetwork.fromProxyHttpResponse(txHash, data.transaction, status);
    }
    async getTransactionStatus(txHash) {
        const response = await this.doGetGeneric(`transaction/${txHash}/process-status`);
        const status = new transactionStatus_1.TransactionStatus(response.status);
        return status;
    }
    async sendTransaction(tx) {
        const transaction = transactions_1.prepareTransactionForBroadcasting(tx);
        const response = await this.doPostGeneric("transaction/send", transaction);
        return response.txHash;
    }
    async sendTransactions(txs) {
        const data = txs.map((tx) => transactions_1.prepareTransactionForBroadcasting(tx));
        const response = await this.doPostGeneric("transaction/send-multiple", data);
        const hashes = Array(txs.length).fill(null);
        for (let i = 0; i < txs.length; i++) {
            hashes[i] = response.txsHashes[i.toString()] || null;
        }
        return hashes;
    }
    async simulateTransaction(tx) {
        const transaction = transactions_1.prepareTransactionForBroadcasting(tx);
        const response = await this.doPostGeneric("transaction/simulate", transaction);
        return response;
    }
    async queryContract(query) {
        try {
            const request = new contractQueryRequest_1.ContractQueryRequest(query).toHttpRequest();
            const response = await this.doPostGeneric("vm-values/query", request);
            return contractQueryResponse_1.ContractQueryResponse.fromHttpResponse(response.data);
        }
        catch (error) {
            throw new errors_1.ErrContractQuery(error);
        }
    }
    async getDefinitionOfFungibleToken(tokenIdentifier) {
        const properties = await this.getTokenProperties(tokenIdentifier);
        const definition = tokenDefinitions_1.DefinitionOfFungibleTokenOnNetwork.fromResponseOfGetTokenProperties(tokenIdentifier, properties);
        return definition;
    }
    async getTokenProperties(identifier) {
        const encodedIdentifier = Buffer.from(identifier).toString("hex");
        const queryResponse = await this.queryContract({
            address: constants_1.EsdtContractAddress,
            func: "getTokenProperties",
            getEncodedArguments: () => [encodedIdentifier],
        });
        const properties = queryResponse.getReturnDataParts();
        return properties;
    }
    async getDefinitionOfTokenCollection(collection) {
        const properties = await this.getTokenProperties(collection);
        const definition = tokenDefinitions_1.DefinitionOfTokenCollectionOnNetwork.fromResponseOfGetTokenProperties(collection, properties);
        return definition;
    }
    async getNonFungibleToken(_collection, _nonce) {
        throw new Error("Method not implemented.");
    }
    async doGetGeneric(resourceUrl) {
        const response = await this.doGet(resourceUrl);
        return response;
    }
    async doPostGeneric(resourceUrl, payload) {
        const response = await this.doPost(resourceUrl, payload);
        return response;
    }
    async doGet(resourceUrl) {
        const url = `${this.url}/${resourceUrl}`;
        try {
            const response = await this.axios.default.get(url, this.config);
            const payload = response.data.data;
            return payload;
        }
        catch (error) {
            this.handleApiError(error, resourceUrl);
        }
    }
    async doPost(resourceUrl, payload) {
        const url = `${this.url}/${resourceUrl}`;
        try {
            const response = await this.axios.default.post(url, payload, {
                ...this.config,
                headers: {
                    "Content-Type": "application/json",
                    ...this.config.headers,
                },
            });
            const responsePayload = response.data.data;
            return responsePayload;
        }
        catch (error) {
            this.handleApiError(error, resourceUrl);
        }
    }
    buildUrlWithQueryParameters(endpoint, params) {
        const searchParams = new URLSearchParams();
        for (let [key, value] of Object.entries(params)) {
            if (value) {
                searchParams.append(key, value);
            }
        }
        return `${endpoint}?${searchParams.toString()}`;
    }
    handleApiError(error, resourceUrl) {
        if (!error.response) {
            throw new errors_1.ErrNetworkProvider(resourceUrl, error.toString(), error);
        }
        const errorData = error.response.data;
        const originalErrorMessage = errorData.message || errorData.error || JSON.stringify(errorData);
        throw new errors_1.ErrNetworkProvider(resourceUrl, originalErrorMessage, error);
    }
}
exports.ProxyNetworkProvider = ProxyNetworkProvider;
//# sourceMappingURL=proxyNetworkProvider.js.map