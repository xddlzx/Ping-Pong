"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenPayment = exports.TokenComputer = exports.TokenTransfer = exports.Token = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
// Legacy constants:
const EGLDTokenIdentifier = "EGLD";
const EGLDNumDecimals = 18;
// Legacy configuration.
// Note: this will actually set the default rounding mode for all BigNumber objects in the environment (in the application / dApp).
bignumber_js_1.default.set({ ROUNDING_MODE: 1 });
class Token {
    constructor(options) {
        this.identifier = options.identifier;
        this.nonce = options.nonce || 0n;
    }
}
exports.Token = Token;
class TokenTransfer {
    constructor(options) {
        if (this.isLegacyTokenTransferOptions(options)) {
            // Handle legacy fields.
            const amount = new bignumber_js_1.default(options.amountAsBigInteger);
            if (!amount.isInteger() || amount.isNegative()) {
                throw new errors_1.ErrInvalidArgument(`bad amountAsBigInteger: ${options.amountAsBigInteger}`);
            }
            this.tokenIdentifier = options.tokenIdentifier;
            this.nonce = options.nonce;
            this.amountAsBigInteger = amount;
            this.numDecimals = options.numDecimals || 0;
            // Handle new fields.
            this.token = new Token({
                identifier: options.tokenIdentifier,
                nonce: BigInt(options.nonce),
            });
            this.amount = BigInt(this.amountAsBigInteger.toFixed(0));
        }
        else {
            // Handle new fields.
            this.token = options.token;
            this.amount = options.amount;
            // Handle legacy fields.
            this.tokenIdentifier = options.token.identifier;
            this.nonce = Number(options.token.nonce);
            this.amountAsBigInteger = new bignumber_js_1.default(this.amount.toString());
            this.numDecimals = 0;
        }
    }
    static newFromEgldAmount(amount) {
        const token = new Token({ identifier: constants_1.EGLD_IDENTIFIER_FOR_MULTI_ESDTNFT_TRANSFER });
        return new TokenTransfer({ token, amount });
    }
    isLegacyTokenTransferOptions(options) {
        return options.tokenIdentifier !== undefined;
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static egldFromAmount(amount) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(EGLDNumDecimals).decimalPlaces(0);
        return this.egldFromBigInteger(amountAsBigInteger);
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static egldFromBigInteger(amountAsBigInteger) {
        return new TokenTransfer({
            tokenIdentifier: EGLDTokenIdentifier,
            nonce: 0,
            amountAsBigInteger,
            numDecimals: EGLDNumDecimals,
        });
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static fungibleFromAmount(tokenIdentifier, amount, numDecimals) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(numDecimals).decimalPlaces(0);
        return this.fungibleFromBigInteger(tokenIdentifier, amountAsBigInteger, numDecimals);
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static fungibleFromBigInteger(tokenIdentifier, amountAsBigInteger, numDecimals = 0) {
        return new TokenTransfer({
            tokenIdentifier,
            nonce: 0,
            amountAsBigInteger,
            numDecimals,
        });
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static nonFungible(tokenIdentifier, nonce) {
        return new TokenTransfer({
            tokenIdentifier,
            nonce,
            amountAsBigInteger: 1,
            numDecimals: 0,
        });
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static semiFungible(tokenIdentifier, nonce, quantity) {
        return new TokenTransfer({
            tokenIdentifier,
            nonce,
            amountAsBigInteger: quantity,
            numDecimals: 0,
        });
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static metaEsdtFromAmount(tokenIdentifier, nonce, amount, numDecimals) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(numDecimals).decimalPlaces(0);
        return this.metaEsdtFromBigInteger(tokenIdentifier, nonce, amountAsBigInteger, numDecimals);
    }
    /**
     * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
     */
    static metaEsdtFromBigInteger(tokenIdentifier, nonce, amountAsBigInteger, numDecimals = 0) {
        return new TokenTransfer({
            tokenIdentifier,
            nonce,
            amountAsBigInteger,
            numDecimals,
        });
    }
    toString() {
        return this.amount.toString();
    }
    /**
     * Legacy function. Use the "amount" field instead.
     */
    valueOf() {
        return new bignumber_js_1.default(this.amount.toString());
    }
    /**
     * Legacy function. For formatting and parsing amounts, use "sdk-dapp" or "bignumber.js" directly.
     */
    toPrettyString() {
        return `${this.toAmount()} ${this.tokenIdentifier}`;
    }
    toAmount() {
        return this.amountAsBigInteger.shiftedBy(-this.numDecimals).toFixed(this.numDecimals);
    }
    /**
     * Legacy function. Within your code, don't mix native values (EGLD) and custom (ESDT) tokens.
     * See "TransferTransactionsFactory.createTransactionForNativeTokenTransfer()" vs. "TransferTransactionsFactory.createTransactionForESDTTokenTransfer()".
     */
    isEgld() {
        return this.token.identifier == EGLDTokenIdentifier;
    }
    /**
     * Legacy function. Use "TokenComputer.isFungible(token)" instead.
     */
    isFungible() {
        return this.token.nonce == 0n;
    }
}
exports.TokenTransfer = TokenTransfer;
class TokenComputer {
    constructor() {
        this.TOKEN_RANDOM_SEQUENCE_LENGTH = 6;
    }
    isFungible(token) {
        return token.nonce === 0n;
    }
    extractNonceFromExtendedIdentifier(identifier) {
        const parts = identifier.split("-");
        const { prefix, ticker, randomSequence } = this.splitIdentifierIntoComponents(parts);
        this.validateExtendedIdentifier(prefix, ticker, randomSequence, parts);
        // If identifier is for a fungible token (2 parts or 3 with prefix), return 0
        if (parts.length === 2 || (prefix && parts.length === 3)) {
            return 0;
        }
        // Otherwise, decode the last part as an unsigned number
        const hexNonce = parts[parts.length - 1];
        return decodeUnsignedNumber(Buffer.from(hexNonce, "hex"));
    }
    extractIdentifierFromExtendedIdentifier(identifier) {
        const parts = identifier.split("-");
        const { prefix, ticker, randomSequence } = this.splitIdentifierIntoComponents(parts);
        this.validateExtendedIdentifier(prefix, ticker, randomSequence, parts);
        if (prefix) {
            this.checkLengthOfPrefix(prefix);
            return prefix + "-" + ticker + "-" + randomSequence;
        }
        return ticker + "-" + randomSequence;
    }
    validateExtendedIdentifier(prefix, ticker, randomSequence, parts) {
        this.checkIfExtendedIdentifierWasProvided(prefix, parts);
        this.ensureTokenTickerValidity(ticker);
        this.checkLengthOfRandomSequence(randomSequence);
    }
    splitIdentifierIntoComponents(parts) {
        if (this.isLowercaseAlphanumeric(parts[0])) {
            return { prefix: parts[0], ticker: parts[1], randomSequence: parts[2] };
        }
        return { prefix: null, ticker: parts[0], randomSequence: parts[1] };
    }
    checkIfExtendedIdentifierWasProvided(prefix, tokenParts) {
        //  this is for the identifiers of fungible tokens
        const MIN_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED = 2;
        //  this is for the identifiers of nft, sft and meta-esdt
        const MAX_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED = prefix ? 4 : 3;
        if (tokenParts.length < MIN_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED ||
            tokenParts.length > MAX_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED) {
            throw new errors_1.ErrInvalidTokenIdentifier("Invalid extended token identifier provided");
        }
    }
    isLowercaseAlphanumeric(str) {
        return /^[a-z0-9]+$/.test(str);
    }
    checkLengthOfRandomSequence(randomSequence) {
        if (randomSequence.length !== this.TOKEN_RANDOM_SEQUENCE_LENGTH) {
            throw new errors_1.ErrInvalidTokenIdentifier("The identifier is not valid. The random sequence does not have the right length");
        }
    }
    checkLengthOfPrefix(prefix) {
        const MAX_TOKEN_PREFIX_LENGTH = 4;
        const MIN_TOKEN_PREFIX_LENGTH = 1;
        if (prefix.length < MIN_TOKEN_PREFIX_LENGTH || prefix.length > MAX_TOKEN_PREFIX_LENGTH) {
            throw new errors_1.ErrInvalidTokenIdentifier("The identifier is not valid. The prefix does not have the right length");
        }
    }
    ensureTokenTickerValidity(ticker) {
        const MIN_TICKER_LENGTH = 3;
        const MAX_TICKER_LENGTH = 10;
        if (ticker.length < MIN_TICKER_LENGTH || ticker.length > MAX_TICKER_LENGTH) {
            throw new errors_1.ErrInvalidTokenIdentifier(`The token ticker should be between ${MIN_TICKER_LENGTH} and ${MAX_TICKER_LENGTH} characters`);
        }
        if (!ticker.match(/^[a-zA-Z0-9]+$/)) {
            throw new errors_1.ErrInvalidTokenIdentifier("The token ticker should only contain alphanumeric characters");
        }
        if (!(ticker == ticker.toUpperCase())) {
            throw new errors_1.ErrInvalidTokenIdentifier("The token ticker should be upper case");
        }
    }
}
exports.TokenComputer = TokenComputer;
function decodeUnsignedNumber(arg) {
    return arg.readUIntBE(0, arg.length);
}
/**
 * @deprecated use {@link TokenTransfer} instead.
 */
class TokenPayment extends TokenTransfer {
    constructor(tokenIdentifier, nonce, amountAsBigInteger, numDecimals) {
        super({
            tokenIdentifier,
            nonce,
            amountAsBigInteger,
            numDecimals,
        });
    }
}
exports.TokenPayment = TokenPayment;
//# sourceMappingURL=tokens.js.map