"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageComputer = exports.Message = void 0;
const constants_1 = require("./constants");
const address_1 = require("./address");
const createKeccakHash = require("keccak");
class Message {
    constructor(options) {
        this.data = options.data;
        this.signature = options.signature;
        this.address = options.address;
        this.version = options.version || constants_1.DEFAULT_MESSAGE_VERSION;
        this.signer = options.signer || constants_1.SDK_JS_SIGNER;
    }
}
exports.Message = Message;
class MessageComputer {
    constructor() { }
    computeBytesForSigning(message) {
        const messageSize = Buffer.from(message.data.length.toString());
        const signableMessage = Buffer.concat([messageSize, message.data]);
        let bytesToHash = Buffer.concat([Buffer.from(constants_1.MESSAGE_PREFIX), signableMessage]);
        return createKeccakHash("keccak256").update(bytesToHash).digest();
    }
    computeBytesForVerifying(message) {
        return this.computeBytesForSigning(message);
    }
    packMessage(message) {
        return {
            message: Buffer.from(message.data).toString("hex"),
            signature: message.signature ? Buffer.from(message.signature).toString("hex") : "",
            address: message.address ? message.address.bech32() : "",
            version: message.version,
            signer: message.signer,
        };
    }
    unpackMessage(packedMessage) {
        const dataHex = this.trimHexPrefix(packedMessage.message);
        const data = Buffer.from(dataHex, "hex");
        const signatureHex = this.trimHexPrefix(packedMessage.signature || "");
        const signature = Buffer.from(signatureHex, "hex");
        let address = undefined;
        if (packedMessage.address) {
            address = address_1.Address.fromBech32(packedMessage.address);
        }
        const version = packedMessage.version || constants_1.DEFAULT_MESSAGE_VERSION;
        const signer = packedMessage.signer || constants_1.UNKNOWN_SIGNER;
        return new Message({
            data: data,
            signature: signature,
            address: address,
            version: version,
            signer: signer,
        });
    }
    trimHexPrefix(data) {
        if (data.startsWith("0x") || data.startsWith("0X")) {
            return data.slice(2);
        }
        return data;
    }
}
exports.MessageComputer = MessageComputer;
//# sourceMappingURL=message.js.map