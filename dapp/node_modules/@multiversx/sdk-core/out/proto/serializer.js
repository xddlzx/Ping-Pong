"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtoSerializer = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const address_1 = require("../address");
const constants_1 = require("../constants");
const errors = __importStar(require("../errors"));
const utils_1 = require("../smartcontracts/codec/utils");
/**
 * Hides away the serialization complexity, for each type of object (e.g. transactions).
 
 * The implementation is non-generic, but practical: there's a pair of `serialize` / `deserialize` method for each type of object.
 */
class ProtoSerializer {
    /**
     * Serializes a Transaction object to a Buffer. Handles low-level conversion logic and field-mappings as well.
     */
    serializeTransaction(transaction) {
        const proto = require("./compiled").proto;
        const protoTransaction = this.convertToProtoMessage(transaction);
        const encoded = proto.Transaction.encode(protoTransaction).finish();
        const buffer = Buffer.from(encoded);
        return buffer;
    }
    convertToProtoMessage(transaction) {
        const proto = require("./compiled").proto;
        const receiverPubkey = new address_1.Address(transaction.receiver).getPublicKey();
        const senderPubkey = new address_1.Address(transaction.sender).getPublicKey();
        let protoTransaction = new proto.Transaction({
            // mx-chain-go's serializer handles nonce == 0 differently, thus we treat 0 as "undefined".
            Nonce: Number(transaction.nonce) ? Number(transaction.nonce) : undefined,
            Value: this.serializeTransactionValue(transaction.value),
            RcvAddr: receiverPubkey,
            RcvUserName: transaction.receiverUsername
                ? Buffer.from(transaction.receiverUsername).toString("base64")
                : undefined,
            SndAddr: senderPubkey,
            SndUserName: transaction.senderUsername
                ? Buffer.from(transaction.senderUsername).toString("base64")
                : undefined,
            GasPrice: Number(transaction.gasPrice),
            GasLimit: Number(transaction.gasLimit),
            Data: transaction.data.length == 0 ? null : transaction.data,
            ChainID: Buffer.from(transaction.chainID),
            Version: transaction.version,
            Signature: transaction.signature,
        });
        if (transaction.options !== constants_1.TRANSACTION_OPTIONS_DEFAULT) {
            protoTransaction.Options = transaction.options;
        }
        if (this.isGuardedTransaction(transaction)) {
            protoTransaction.GuardianAddr = new address_1.Address(transaction.guardian).getPublicKey();
            protoTransaction.GuardianSignature = transaction.guardianSignature;
        }
        if (this.isRelayedTransaction(transaction)) {
            protoTransaction.Relayer = transaction.relayer?.getPublicKey();
            protoTransaction.RelayerSignature = transaction.relayerSignature;
        }
        return protoTransaction;
    }
    isRelayedTransaction(transaction) {
        return !transaction.relayer.isEmpty();
    }
    /**
     * Custom serialization, compatible with mx-chain-go.
     */
    serializeTransactionValue(transactionValue) {
        let value = new bignumber_js_1.default(transactionValue.toString());
        if (value.isZero()) {
            return Buffer.from([0, 0]);
        }
        // Will retain the magnitude, as a buffer.
        let buffer = utils_1.bigIntToBuffer(value);
        // We prepend the "positive" sign marker, in order to be compatible with mx-chain-go's "sign & magnitude" proto-representation (a custom one).
        buffer = Buffer.concat([Buffer.from([0x00]), buffer]);
        return buffer;
    }
    isGuardedTransaction(transaction) {
        const hasGuardian = transaction.guardian.length > 0;
        const hasGuardianSignature = transaction.guardianSignature.length > 0;
        return this.isWithGuardian(transaction) && hasGuardian && hasGuardianSignature;
    }
    isWithGuardian(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) == constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
    }
    deserializeTransaction(_buffer) {
        // Not needed (yet).
        throw new errors.ErrUnsupportedOperation("deserializeTransaction");
    }
}
exports.ProtoSerializer = ProtoSerializer;
//# sourceMappingURL=serializer.js.map