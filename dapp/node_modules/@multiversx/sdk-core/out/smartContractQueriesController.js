"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContractQueriesController = void 0;
const errors_1 = require("./errors");
const smartContractQuery_1 = require("./smartContractQuery");
const smartcontracts_1 = require("./smartcontracts");
const typesystem_1 = require("./smartcontracts/typesystem");
class SmartContractQueriesController {
    constructor(options) {
        this.abi = options.abi;
        this.queryRunner = options.queryRunner;
        this.legacyResultsParser = new smartcontracts_1.ResultsParser();
    }
    async query(options) {
        const query = this.createQuery(options);
        const queryResponse = await this.runQuery(query);
        this.raiseForStatus(queryResponse);
        return this.parseQueryResponse(queryResponse);
    }
    raiseForStatus(queryResponse) {
        const isOk = queryResponse.returnCode === "ok";
        if (!isOk) {
            throw new errors_1.ErrSmartContractQuery(queryResponse.returnCode, queryResponse.returnMessage);
        }
    }
    createQuery(options) {
        const preparedArguments = this.encodeArguments(options.function, options.arguments);
        return new smartContractQuery_1.SmartContractQuery({
            contract: options.contract,
            caller: options.caller,
            function: options.function,
            arguments: preparedArguments,
            value: options.value,
        });
    }
    encodeArguments(functionName, args) {
        const endpoint = this.abi?.getEndpoint(functionName);
        if (endpoint) {
            const typedArgs = smartcontracts_1.NativeSerializer.nativeToTypedValues(args, endpoint);
            return new smartcontracts_1.ArgSerializer().valuesToBuffers(typedArgs);
        }
        if (this.areArgsOfTypedValue(args)) {
            return new smartcontracts_1.ArgSerializer().valuesToBuffers(args);
        }
        if (this.areArgsBuffers(args)) {
            return args.map((arg) => Buffer.from(arg));
        }
        throw new errors_1.Err("cannot encode arguments: when ABI is not available, they must be either typed values or buffers");
    }
    areArgsOfTypedValue(args) {
        return args.every((arg) => typesystem_1.isTyped(arg));
    }
    areArgsBuffers(args) {
        for (const arg of args) {
            if (!ArrayBuffer.isView(arg)) {
                return false;
            }
        }
        return true;
    }
    async runQuery(query) {
        const queryResponse = await this.queryRunner.runQuery(query);
        return queryResponse;
    }
    parseQueryResponse(response) {
        if (!this.abi) {
            return response.returnDataParts;
        }
        const legacyQueryResponse = {
            returnCode: response.returnCode,
            returnMessage: response.returnMessage,
            getReturnDataParts: () => response.returnDataParts.map((part) => Buffer.from(part)),
        };
        const functionName = response.function;
        const endpoint = this.abi.getEndpoint(functionName);
        const legacyBundle = this.legacyResultsParser.parseQueryResponse(legacyQueryResponse, endpoint);
        const nativeValues = legacyBundle.values.map((value) => value.valueOf());
        return nativeValues;
    }
}
exports.SmartContractQueriesController = SmartContractQueriesController;
//# sourceMappingURL=smartContractQueriesController.js.map