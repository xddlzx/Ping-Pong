"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionHash = exports.Transaction = void 0;
const bignumber_js_1 = require("bignumber.js");
const address_1 = require("./address");
const constants_1 = require("./constants");
const transactionsConverter_1 = require("./converters/transactionsConverter");
const hash_1 = require("./hash");
const networkParams_1 = require("./networkParams");
const signature_1 = require("./signature");
const transactionComputer_1 = require("./transactionComputer");
const transactionPayload_1 = require("./transactionPayload");
/**
 * An abstraction for creating and signing transactions.
 */
class Transaction {
    /**
     * Creates a new Transaction object.
     */
    constructor(options) {
        this.nonce = BigInt(options.nonce?.valueOf() || 0n);
        // We still rely on "bigNumber" for value, because client code might be passing a BigNumber object as a legacy "ITransactionValue",
        // and we want to keep compatibility.
        this.value = options.value ? BigInt(new bignumber_js_1.BigNumber(options.value.toString()).toFixed(0)) : 0n;
        this.sender = this.addressAsBech32(options.sender);
        this.receiver = this.addressAsBech32(options.receiver);
        this.senderUsername = options.senderUsername || "";
        this.receiverUsername = options.receiverUsername || "";
        this.gasPrice = BigInt(options.gasPrice?.valueOf() || constants_1.TRANSACTION_MIN_GAS_PRICE);
        this.gasLimit = BigInt(options.gasLimit.valueOf());
        this.data = options.data?.valueOf() || new Uint8Array();
        this.chainID = options.chainID.valueOf();
        this.version = Number(options.version?.valueOf() || constants_1.TRANSACTION_VERSION_DEFAULT);
        this.options = Number(options.options?.valueOf() || constants_1.TRANSACTION_OPTIONS_DEFAULT);
        this.guardian = options.guardian ? this.addressAsBech32(options.guardian) : "";
        this.relayer = options.relayer ? options.relayer : address_1.Address.empty();
        this.signature = options.signature || Buffer.from([]);
        this.guardianSignature = options.guardianSignature || Buffer.from([]);
        this.relayerSignature = options.relayerSignature || Buffer.from([]);
    }
    addressAsBech32(address) {
        return typeof address === "string" ? address : address.bech32();
    }
    /**
     * Legacy method, use the "nonce" property instead.
     */
    getNonce() {
        return Number(this.nonce);
    }
    /**
     * Legacy method, use the "nonce" property instead.
     * Sets the account sequence number of the sender. Must be done prior signing.
     */
    setNonce(nonce) {
        this.nonce = BigInt(nonce.valueOf());
    }
    /**
     * Legacy method, use the "value" property instead.
     */
    getValue() {
        return this.value;
    }
    /**
     * Legacy method, use the "value" property instead.
     */
    setValue(value) {
        this.value = BigInt(value.toString());
    }
    /**
     * Legacy method, use the "sender" property instead.
     */
    getSender() {
        return address_1.Address.fromBech32(this.sender);
    }
    /**
     * Legacy method, use the "sender" property instead.
     */
    setSender(sender) {
        this.sender = typeof sender === "string" ? sender : sender.bech32();
    }
    /**
     * Legacy method, use the "receiver" property instead.
     */
    getReceiver() {
        return address_1.Address.fromBech32(this.receiver);
    }
    /**
     * Legacy method, use the "senderUsername" property instead.
     */
    getSenderUsername() {
        return this.senderUsername;
    }
    /**
     * Legacy method, use the "senderUsername" property instead.
     */
    setSenderUsername(senderUsername) {
        this.senderUsername = senderUsername;
    }
    /**
     * Legacy method, use the "receiverUsername" property instead.
     */
    getReceiverUsername() {
        return this.receiverUsername;
    }
    /**
     * Legacy method, use the "receiverUsername" property instead.
     */
    setReceiverUsername(receiverUsername) {
        this.receiverUsername = receiverUsername;
    }
    /**
     * Legacy method, use the "guardian" property instead.
     */
    getGuardian() {
        return new address_1.Address(this.guardian);
    }
    /**
     * Legacy method, use the "gasPrice" property instead.
     */
    getGasPrice() {
        return Number(this.gasPrice);
    }
    /**
     * Legacy method, use the "gasPrice" property instead.
     */
    setGasPrice(gasPrice) {
        this.gasPrice = BigInt(gasPrice.valueOf());
    }
    /**
     * Legacy method, use the "gasLimit" property instead.
     */
    getGasLimit() {
        return Number(this.gasLimit);
    }
    /**
     * Legacy method, use the "gasLimit" property instead.
     */
    setGasLimit(gasLimit) {
        this.gasLimit = BigInt(gasLimit.valueOf());
    }
    /**
     * Legacy method, use the "data" property instead.
     */
    getData() {
        return new transactionPayload_1.TransactionPayload(Buffer.from(this.data));
    }
    /**
     * Legacy method, use the "chainID" property instead.
     */
    getChainID() {
        return this.chainID;
    }
    /**
     * Legacy method, use the "chainID" property instead.
     */
    setChainID(chainID) {
        this.chainID = chainID.valueOf();
    }
    /**
     * Legacy method, use the "version" property instead.
     */
    getVersion() {
        return new networkParams_1.TransactionVersion(this.version);
    }
    /**
     * Legacy method, use the "version" property instead.
     */
    setVersion(version) {
        this.version = version.valueOf();
    }
    /**
     * Legacy method, use the "options" property instead.
     */
    getOptions() {
        return new networkParams_1.TransactionOptions(this.options.valueOf());
    }
    /**
     * Legacy method, use the "options" property instead.
     *
     * Question for review: check how the options are set by sdk-dapp, wallet, ledger, extension.
     */
    setOptions(options) {
        this.options = options.valueOf();
    }
    /**
     * Legacy method, use the "signature" property instead.
     */
    getSignature() {
        return Buffer.from(this.signature);
    }
    /**
     * Legacy method, use the "guardianSignature" property instead.
     */
    getGuardianSignature() {
        return Buffer.from(this.guardianSignature);
    }
    /**
     * Legacy method, use the "guardian" property instead.
     */
    setGuardian(guardian) {
        this.guardian = typeof guardian === "string" ? guardian : guardian.bech32();
    }
    /**
     * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
     */
    getHash() {
        return TransactionHash.compute(this);
    }
    /**
     * Legacy method, use "TransactionComputer.computeBytesForSigning()" instead.
     * Serializes a transaction to a sequence of bytes, ready to be signed.
     * This function is called internally by signers.
     */
    serializeForSigning() {
        const computer = new transactionComputer_1.TransactionComputer();
        const bytes = computer.computeBytesForSigning(this);
        return Buffer.from(bytes);
    }
    /**
     * Checks the integrity of the guarded transaction
     */
    isGuardedTransaction() {
        const hasGuardian = this.guardian.length > 0;
        const hasGuardianSignature = this.guardianSignature.length > 0;
        return this.getOptions().isWithGuardian() && hasGuardian && hasGuardianSignature;
    }
    /**
     * Legacy method, use "TransactionsConverter.transactionToPlainObject()" instead.
     *
     * Converts the transaction object into a ready-to-serialize, plain JavaScript object.
     * This function is called internally within the signing procedure.
     */
    toPlainObject() {
        // Ideally, "converters" package should be outside of "core", and not referenced here.
        const converter = new transactionsConverter_1.TransactionsConverter();
        return converter.transactionToPlainObject(this);
    }
    /**
     * Legacy method, use "TransactionsConverter.plainObjectToTransaction()" instead.
     * Converts a plain object transaction into a Transaction Object.
     *
     * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()
     */
    static fromPlainObject(plainObjectTransaction) {
        // Ideally, "converters" package should be outside of "core", and not referenced here.
        const converter = new transactionsConverter_1.TransactionsConverter();
        return converter.plainObjectToTransaction(plainObjectTransaction);
    }
    /**
     * Legacy method, use the "signature" property instead.
     * Applies the signature on the transaction.
     *
     * @param signature The signature, as computed by a signer.
     */
    applySignature(signature) {
        this.signature = signature_1.interpretSignatureAsBuffer(signature);
    }
    /**
     * Legacy method, use the "guardianSignature" property instead.
     * Applies the guardian signature on the transaction.
     *
     * @param guardianSignature The signature, as computed by a signer.
     */
    applyGuardianSignature(guardianSignature) {
        this.guardianSignature = signature_1.interpretSignatureAsBuffer(guardianSignature);
    }
    /**
     * Converts a transaction to a ready-to-broadcast object.
     * Called internally by the network provider.
     */
    toSendable() {
        return this.toPlainObject();
    }
    /**
     * Legacy method, use "TransactionComputer.computeTransactionFee()" instead.
     *
     * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties
     * @param networkConfig {@link NetworkConfig}
     */
    computeFee(networkConfig) {
        const computer = new transactionComputer_1.TransactionComputer();
        const fee = computer.computeTransactionFee(this, networkConfig);
        return new bignumber_js_1.BigNumber(fee.toString());
    }
}
exports.Transaction = Transaction;
/**
 * Legacy class, use "TransactionComputer.computeTransactionHash()" instead.
 * An abstraction for handling and computing transaction hashes.
 */
class TransactionHash extends hash_1.Hash {
    constructor(hash) {
        super(hash);
    }
    /**
     * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
     * Computes the hash of a transaction.
     */
    static compute(transaction) {
        const computer = new transactionComputer_1.TransactionComputer();
        const hash = computer.computeTransactionHash(transaction);
        return new TransactionHash(Buffer.from(hash).toString("hex"));
    }
}
exports.TransactionHash = TransactionHash;
//# sourceMappingURL=transaction.js.map