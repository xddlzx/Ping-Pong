"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressComputer = exports.Address = void 0;
const bech32 = __importStar(require("bech32"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const config_1 = require("./config");
const constants_1 = require("./constants");
const errors = __importStar(require("./errors"));
const codec_1 = require("./tokenOperations/codec");
const createKeccakHash = require("keccak");
/**
 * The length (in bytes) of a public key (from which a bech32 address can be obtained).
 */
const PUBKEY_LENGTH = 32;
const SMART_CONTRACT_HEX_PUBKEY_PREFIX = "0".repeat(16);
/**
 * An Address, as an immutable object.
 */
class Address {
    /**
     * Creates an address object, given a raw string (whether a hex pubkey or a Bech32 address), a sequence of bytes, or another Address object.
     */
    constructor(value, hrp) {
        // Legacy flow.
        if (!value) {
            this.publicKey = Buffer.from([]);
            this.hrp = hrp || config_1.LibraryConfig.DefaultAddressHrp;
            return;
        }
        // The only flow that's following the specs.
        if (ArrayBuffer.isView(value)) {
            if (value.length != PUBKEY_LENGTH) {
                throw new errors.ErrAddressCannotCreate(value);
            }
            this.publicKey = Buffer.from(value);
            this.hrp = hrp || config_1.LibraryConfig.DefaultAddressHrp;
            return;
        }
        // Legacy flow.
        if (value instanceof Address) {
            if (hrp) {
                throw new errors.ErrInvalidArgument("this variant of the Address constructor does not accept the 'hrp' argument");
            }
            this.publicKey = value.publicKey;
            this.hrp = value.hrp;
            return;
        }
        // Legacy flow.
        if (typeof value === "string") {
            if (Address.isValidHex(value)) {
                this.publicKey = Buffer.from(value, "hex");
                this.hrp = hrp || config_1.LibraryConfig.DefaultAddressHrp;
                return;
            }
            if (hrp) {
                throw new errors.ErrInvalidArgument("this variant of the Address constructor does not accept the 'hrp' argument");
            }
            // On this legacy flow, we do not accept addresses with custom hrp (in order to avoid behavioral breaking changes).
            const { hrp: decodedHrp, pubkey } = decodeFromBech32({ value, allowCustomHrp: false });
            this.publicKey = pubkey;
            this.hrp = decodedHrp;
            return;
        }
        throw new errors.ErrAddressCannotCreate(value);
    }
    /**
     * Creates an address object from a bech32-encoded string
     */
    static newFromBech32(value) {
        const { hrp, pubkey } = decodeFromBech32({ value, allowCustomHrp: true });
        return new Address(pubkey, hrp);
    }
    /**
     * Use {@link newFromBech32} instead.
     */
    static fromBech32(value) {
        // On this legacy flow, we do not accept addresses with custom hrp (in order to avoid behavioral breaking changes).
        const { hrp, pubkey } = decodeFromBech32({ value, allowCustomHrp: false });
        return new Address(pubkey, hrp);
    }
    /**
     * Creates an address object from a hex-encoded string
     */
    static newFromHex(value, hrp) {
        if (!Address.isValidHex(value)) {
            throw new errors.ErrAddressCannotCreate(value);
        }
        return new Address(Buffer.from(value, "hex"), hrp);
    }
    /**
     * Use {@link newFromHex} instead.
     */
    static fromHex(value, hrp) {
        return Address.newFromHex(value, hrp);
    }
    /**
     * @deprecated Constructing an address object from another object is deprecated.
     */
    static fromAddress(address) {
        return new Address(address);
    }
    /**
     * @deprecated Use the constructor, instead.
     */
    static fromBuffer(buffer, hrp) {
        return new Address(buffer, hrp);
    }
    /**
     * @deprecated Use {@link newFromBech32} or {@link newFromHex}.
     */
    static fromString(value, hrp) {
        return new Address(value, hrp);
    }
    static isValidHex(value) {
        return Buffer.from(value, "hex").length == PUBKEY_LENGTH;
    }
    /**
     * Creates an empty address object.
     * Generally speaking, this should not be used by client code (internal use only).
     */
    static empty() {
        return new Address("");
    }
    /**
     * Performs address validation without throwing errors
     */
    static isValid(value) {
        const decoded = bech32.decodeUnsafe(value);
        const prefix = decoded?.prefix;
        const pubkey = decoded ? Buffer.from(bech32.fromWords(decoded.words)) : undefined;
        if (prefix !== config_1.LibraryConfig.DefaultAddressHrp || pubkey?.length !== PUBKEY_LENGTH) {
            return false;
        }
        return true;
    }
    /**
     * Use {@link toHex} instead.
     */
    hex() {
        return this.toHex();
    }
    /**
     * Returns the hex representation of the address (pubkey)
     */
    toHex() {
        if (this.isEmpty()) {
            return "";
        }
        return this.publicKey.toString("hex");
    }
    /**
     * Use {@link toBech32} instead.
     */
    bech32() {
        return this.toBech32();
    }
    /**
     * Returns the bech32 representation of the address
     */
    toBech32() {
        if (this.isEmpty()) {
            return "";
        }
        let words = bech32.toWords(this.pubkey());
        let address = bech32.encode(this.hrp, words);
        return address;
    }
    /**
     * Use {@link getPublicKey} instead.
     */
    pubkey() {
        return this.getPublicKey();
    }
    /**
     * Returns the pubkey as raw bytes (buffer)
     */
    getPublicKey() {
        return this.publicKey;
    }
    /**
     * Returns the human-readable-part of the bech32 addresses.
     */
    getHrp() {
        return this.hrp;
    }
    /**
     * Returns whether the address is empty.
     */
    isEmpty() {
        return this.publicKey.length == 0;
    }
    /**
     * Compares the address to another address
     */
    equals(other) {
        if (!other) {
            return false;
        }
        return this.publicKey.toString() == other.publicKey.toString();
    }
    /**
     * Returns the bech32 representation of the address
     */
    toString() {
        return this.toBech32();
    }
    /**
     * Converts the address to a pretty, plain JavaScript object.
     */
    toJSON() {
        return {
            bech32: this.toBech32(),
            pubkey: this.toHex(),
        };
    }
    /**
     * Creates the Zero address (the one that should be used when deploying smart contracts).
     * Generally speaking, this should not be used by client code (internal use only).
     */
    static Zero() {
        return new Address("0".repeat(64));
    }
    /**
     * Use {@link isSmartContract} instead.
     */
    isContractAddress() {
        return this.isSmartContract();
    }
    /**
     * Returns whether the address is a smart contract address.
     */
    isSmartContract() {
        return this.toHex().startsWith(SMART_CONTRACT_HEX_PUBKEY_PREFIX);
    }
}
exports.Address = Address;
class AddressComputer {
    constructor(numberOfShardsWithoutMeta) {
        this.numberOfShardsWithoutMeta = numberOfShardsWithoutMeta || constants_1.CURRENT_NUMBER_OF_SHARDS_WITHOUT_META;
    }
    computeContractAddress(deployer, deploymentNonce) {
        const initialPadding = Buffer.alloc(8, 0);
        const ownerPubkey = deployer.getPublicKey();
        const shardSelector = ownerPubkey.slice(30);
        const ownerNonceBytes = Buffer.alloc(8);
        const bigNonce = new bignumber_js_1.default(deploymentNonce.toString());
        const bigNonceBuffer = codec_1.bigIntToBuffer(bigNonce);
        ownerNonceBytes.write(bigNonceBuffer.reverse().toString("hex"), "hex");
        const bytesToHash = Buffer.concat([ownerPubkey, ownerNonceBytes]);
        const hash = createKeccakHash("keccak256").update(bytesToHash).digest();
        const vmTypeBytes = Buffer.from(constants_1.WasmVirtualMachine, "hex");
        const addressBytes = Buffer.concat([initialPadding, vmTypeBytes, hash.slice(10, 30), shardSelector]);
        return new Address(addressBytes);
    }
    getShardOfAddress(address) {
        return this.getShardOfPubkey(address.getPublicKey(), this.numberOfShardsWithoutMeta);
    }
    getShardOfPubkey(pubkey, numberOfShards) {
        const maskHigh = parseInt("11", 2);
        const maskLow = parseInt("01", 2);
        const lastByteOfPubkey = pubkey[31];
        if (this.isPubkeyOfMetachain(pubkey)) {
            return constants_1.METACHAIN_ID;
        }
        let shard = lastByteOfPubkey & maskHigh;
        if (shard > numberOfShards - 1) {
            shard = lastByteOfPubkey & maskLow;
        }
        return shard;
    }
    isPubkeyOfMetachain(pubkey) {
        const metachainPrefix = Buffer.from([
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ]);
        const pubkeyPrefix = Buffer.from(pubkey).slice(0, metachainPrefix.length);
        if (metachainPrefix.equals(pubkeyPrefix)) {
            return true;
        }
        const zeroAddress = Buffer.alloc(32);
        if (zeroAddress.equals(Buffer.from(pubkey))) {
            return true;
        }
        return false;
    }
}
exports.AddressComputer = AddressComputer;
function decodeFromBech32(options) {
    const value = options.value;
    const allowCustomHrp = options.allowCustomHrp;
    let hrp;
    let pubkey;
    try {
        const decoded = bech32.decode(value);
        hrp = decoded.prefix;
        pubkey = Buffer.from(bech32.fromWords(decoded.words));
    }
    catch (err) {
        throw new errors.ErrAddressCannotCreate(value, err);
    }
    // Workaround, in order to avoid behavioral breaking changes on legacy flows.
    // In a future major release, we should drop this constraint (not exactly useful, validation should be performed in other ways)
    if (!allowCustomHrp && hrp != config_1.LibraryConfig.DefaultAddressHrp) {
        throw new errors.ErrAddressBadHrp(config_1.LibraryConfig.DefaultAddressHrp, hrp);
    }
    return { hrp, pubkey };
}
//# sourceMappingURL=address.js.map