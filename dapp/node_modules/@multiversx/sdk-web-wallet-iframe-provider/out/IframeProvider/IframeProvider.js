"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IframeProvider = void 0;
const transaction_1 = require("@multiversx/sdk-core/out/transaction");
const CrossWindowProvider_1 = require("@multiversx/sdk-web-wallet-cross-window-provider/out/CrossWindowProvider/CrossWindowProvider");
const enums_1 = require("@multiversx/sdk-web-wallet-cross-window-provider/out/enums");
const errors_1 = require("@multiversx/sdk-web-wallet-cross-window-provider/out/errors");
const constants_1 = require("../constants");
const IframeManager_1 = require("../IframeManager/IframeManager");
class IframeProvider extends CrossWindowProvider_1.CrossWindowProvider {
    constructor() {
        super();
        this.loginType = constants_1.IframeLoginTypes.metamask;
        this.windowManager = new IframeManager_1.IframeManager({
            onDisconnect: this.logout.bind(this)
        });
    }
    static getInstance() {
        if (!IframeProvider._instance) {
            IframeProvider._instance = new IframeProvider();
            return IframeProvider._instance;
        }
        return IframeProvider._instance;
    }
    init() {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const initialized = yield _super.init.call(this);
            return initialized;
        });
    }
    setLoginType(loginType) {
        this.loginType = loginType;
        this.windowManager.setLoginType(loginType);
    }
    setWalletUrl(url) {
        const newUrl = `${url}/?iframeProviderLoginType=${this.loginType}`;
        return super.setWalletUrl(newUrl);
    }
    login(options = {}) {
        const _super = Object.create(null, {
            login: { get: () => super.login }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.windowManager.setWalletWindow();
            const account = yield _super.login.call(this, options);
            if (!account.address) {
                (_a = this.windowManager.iframeWallet) === null || _a === void 0 ? void 0 : _a.remove();
                this.windowManager.walletWindow = null;
                throw new errors_1.ErrCouldNotLogin();
            }
            this.windowManager.closeWalletWindow();
            return account;
        });
    }
    dispose() {
        const _super = Object.create(null, {
            dispose: { get: () => super.dispose }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.dispose.call(this);
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            try {
                this.ensureConnected();
                yield this.windowManager.closeConnection();
            }
            catch (e) {
                console.error(e);
            }
            this.initialized = false;
            this.disconnect();
            return true;
        });
    }
    signTransaction(transaction) {
        const _super = Object.create(null, {
            signTransaction: { get: () => super.signTransaction }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.windowManager.setWalletWindow();
            const data = yield _super.signTransaction.call(this, transaction);
            this.windowManager.closeWalletWindow();
            return data;
        });
    }
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.windowManager.setWalletWindow();
            this.ensureConnected();
            const { type, payload: { data: signedPlainTransactions, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.signTransactionsRequest,
                payload: transactions.map((tx) => tx.toPlainObject())
            });
            if (error || !signedPlainTransactions) {
                this.windowManager.closeWalletWindow();
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            if (type === enums_1.WindowProviderResponseEnums.cancelResponse) {
                this.windowManager.closeWalletWindow();
                throw new errors_1.ErrTransactionCancelled();
            }
            const hasTransactions = (signedPlainTransactions === null || signedPlainTransactions === void 0 ? void 0 : signedPlainTransactions.length) > 0;
            if (!hasTransactions) {
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            const data = signedPlainTransactions.map((tx) => transaction_1.Transaction.fromPlainObject(tx));
            this.windowManager.closeWalletWindow();
            return data;
        });
    }
    guardTransactions(transactions) {
        const _super = Object.create(null, {
            guardTransactions: { get: () => super.guardTransactions }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.windowManager.setWalletWindow();
            const data = yield _super.guardTransactions.call(this, transactions);
            this.windowManager.closeWalletWindow();
            return data;
        });
    }
    signMessage(messageToSign) {
        const _super = Object.create(null, {
            signMessage: { get: () => super.signMessage }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.windowManager.setWalletWindow();
            messageToSign.signer = this.loginType;
            const data = yield _super.signMessage.call(this, messageToSign);
            this.windowManager.closeWalletWindow();
            return data;
        });
    }
    openPopupConsent() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
}
IframeProvider._instance = null;
exports.IframeProvider = IframeProvider;
//# sourceMappingURL=IframeProvider.js.map